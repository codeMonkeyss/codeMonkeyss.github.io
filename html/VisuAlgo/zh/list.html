<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="description" content="Linked List is a data structure consisting of a group of vertices (nodes) which together represent a sequence. Under the simplest form, each vertex is composed of a data and a reference (link) to the next vertex in the sequence. Try clicking Search(77) for a sample animation on searching a value in a (Singly) Linked List.Linked List and its variations are used as underlying data structure to implement List, Stack, Queue, and Deque ADTs (read this Wikipedia article about ADT if you are not familiar with that term).In this visualization, we discuss (Singly) Linked List (LL) — with a single next pointer — and its two variants: Stack and Queue, and also Doubly Linked List (DLL) — with both next and previous pointers — and its variant: Deque.Click &#39;Next&#39; (on the top right)/press &#39;Page Down&#39; to advance this e-Lecture slide, use the drop down list/press &#39;Space&#39; to jump to a specific slide, or Click &#39;X&#39; (on the bottom right)/press &#39;Esc&#39; to go to Exploration mode.">
<meta name="keywords" content="单向/双向链表 栈 队列 双端队列">
 
<meta name="csrf-token" content="kaTPcaTtnnJPvGspW7LRTya6UONjjAL7yXZSCSBh">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/list.png">
<title>VisuAlgo - 链表（单向，双向），堆栈，队列，双端队列</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common.css">
<link rel="stylesheet" href="../css/viz-1.0.1.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
      }
      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }
      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
    </style>
<style>
.execAction { padding: 5px 8px; }
.err { padding: 5px 0px; }
#actions-extras input {
  width: 35px;
  padding: 5px 8px 7px;
}

.create { bottom: 146px; }
.search { bottom: 119px; }
.insert { bottom: 92px; }
.remove { bottom: 65px; }

#createfixedsize-input input, #createuserdefined-input input { float:left; }
#createfixedsize-go p, #createuserdefined-go p { float:right; }
#createuserdefined-input input { width: 80px; }

#inserthead-input input, #inserttail-input input, #insertkth-input input { float: left; }
#insertkth-input input { margin-right: 3px; }
#inserthead-go p, #inserttail-go p, #insertkth-go p { float: right; }

#removekth-input input {  float: left; }
#removekth-go p { float: right; }
</style>
<script>
      function changeURL() {
        var URL = window.location.href.split('/');
        var val = document.getElementById("Language").value;
        URL[3] = val;
        window.location.assign(URL.join('/'));
      }
    </script>
</head>
<body>
<div id="top-bar">
<a id="home" href="/">Visu<span class="colour">Algo</span><span style="font-size: 40%">.net</span></a>
/
<select id="Language" onchange="changeURL()">
<option value="zh" selected>zh</option>
</select>
/list
<span id="title">
<a id='title-LL' class='selected-viz'>LL</a>
<a id='title-Stack'>栈</a>
<a id='title-Queue'>队列</a>
<a id='title-DLL'>DLL</a>
<a id='title-Deque'>双端队列</a>
</span>
<div id="mode-menu">
<div id='mode-button' title='exploration'>示例模式 &#9663;</div>
<div id='other-modes'>
<a title='e-Lecture'>电子讲座模式</a>
</div>
</div>
</div>
<div id="dark-overlay"></div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id='speed-control'>减速<div id='speed-input'></div>加速</div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick=goToBeginning()><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick=stepBackward()><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick=pause()><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick=play()><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick=stepForward()><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick=goToEnd()><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id='viz'></div>
<div id='current-action' class='panel'></div>
<div id='e-lecture' class='panel'></div>
<div id="overlay" hidden></div>
<div id="dropdown-temp-holder" hidden></div>
<div id="electure-1" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Linked List is a data structure consisting of a group of vertices (nodes) which together represent a sequence. Under the simplest form, each vertex is composed of a data and a reference (link) to the next vertex in the sequence. Try clicking <span class="slide-actions" onclick="doButtonAction96()">Search(77)</span> for a sample animation on searching a value in a (Singly) Linked List.</p><br><p>Linked List and its variations are used as underlying data structure to implement List, Stack, Queue, and Deque ADTs (read this <a href="https://en.wikipedia.org/wiki/Abstract_data_type" target="_blank"><u>Wikipedia article about ADT</u></a> if you are not familiar with that term).</p><br><p>In this visualization, we discuss (Singly) Linked List (LL) — with a single next pointer — and its two variants: Stack and Queue, and also Doubly Linked List (DLL) — with both next and previous pointers — and its variant: Deque.</p><br><p>Click &#39;Next&#39; (on the top right)/press &#39;Page Down&#39; to advance this e-Lecture slide, use the drop down list/press &#39;Space&#39; to jump to a specific slide, or Click &#39;X&#39; (on the bottom right)/press &#39;Esc&#39; to go to Exploration mode.</p>
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
Please <a href="login"><u>login</u></a> if you are a repeated visitor or <a href="login"><u>register</u></a> for an (optional) free account first.</p>
<div id='electure-dropdown'>
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. 链表</option>
<option value="1-1">&nbsp;&nbsp;&nbsp;1-1. 5种模式</option>
<option value="2">2. 动机</option>
<option value="2-1">&nbsp;&nbsp;&nbsp;2-1. 列表抽象数据类型</option>
<option value="2-2">&nbsp;&nbsp;&nbsp;2-2. 结果</option>
<option value="2-3">&nbsp;&nbsp;&nbsp;2-3. 数组实现 - 第一部分<br></option>
<option value="2-4">&nbsp;&nbsp;&nbsp;2-4. 数组实现 - 第二部分</option>
<option value="2-5">&nbsp;&nbsp;&nbsp;2-5. 时间复杂性小结<br></option>
<option value="2-6">&nbsp;&nbsp;&nbsp;2-6. 固定空间问题<br></option>
<option value="2-7">&nbsp;&nbsp;&nbsp;2-7. 变量空间</option>
<option value="2-8">&nbsp;&nbsp;&nbsp;2-8. 观察</option>
<option value="3">3. 链表（LL）</option>
<option value="3-1">&nbsp;&nbsp;&nbsp;3-1. 链表的顶点C++实现<br></option>
<option value="3-2">&nbsp;&nbsp;&nbsp;3-2. 答案</option>
<option value="3-3">&nbsp;&nbsp;&nbsp;3-3. 链表，其他数据元素</option>
<option value="3-4">&nbsp;&nbsp;&nbsp;3-4. 变化</option>
<option value="3-5">&nbsp;&nbsp;&nbsp;3-5. 获取（i）- 比数组慢很多</option>
<option value="3-6">&nbsp;&nbsp;&nbsp;3-6. 搜索（v）-不优于数组<br></option>
<option value="3-7">&nbsp;&nbsp;&nbsp;3-7. 插入 - 四种情况</option>
<option value="3-8">&nbsp;&nbsp;&nbsp;3-8. 插入（i, v) - 在头节点插入（i=0)</option>
<option value="3-9">&nbsp;&nbsp;&nbsp;3-9. 答案</option>
<option value="3-10">&nbsp;&nbsp;&nbsp;3-10. 插入(i, v) - 插入v到一个空的链表</option>
<option value="3-11">&nbsp;&nbsp;&nbsp;3-11. 插入（i, v) - 在[1, N-1] 种插入</option>
<option value="3-12">&nbsp;&nbsp;&nbsp;3-12. 插入(i, v) - </option>
<option value="3-13">&nbsp;&nbsp;&nbsp;3-13. 答案<br></option>
<option value="3-14">&nbsp;&nbsp;&nbsp;3-14. 移除 - 三种情况</option>
<option value="3-15">&nbsp;&nbsp;&nbsp;3-15. 移除（i）- 在头节点移除(i = 0)</option>
<option value="3-16">&nbsp;&nbsp;&nbsp;3-16. 答案<br></option>
<option value="3-17">&nbsp;&nbsp;&nbsp;3-17. 移除（i）- 在[1, N-2]种移除</option>
<option value="3-18">&nbsp;&nbsp;&nbsp;3-18. <span style="white-space: normal;">Remove(i) - At Tail (i = N-1) - 第一部分</span><br></option>
<option value="3-19">&nbsp;&nbsp;&nbsp;3-19. <span style="white-space: normal;">Remove(i) - At Tail (i = N-1) - 第二部分</span><br></option>
<option value="3-20">&nbsp;&nbsp;&nbsp;3-20. 答案<br></option>
<option value="3-21">&nbsp;&nbsp;&nbsp;3-21. 时间复杂度小结</option>
<option value="3-22">&nbsp;&nbsp;&nbsp;3-22. 链表的应用</option>
<option value="4">4. 堆栈</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. 设计选择<br></option>
<option value="4-2">&nbsp;&nbsp;&nbsp;4-2. 结果</option>
<option value="4-3">&nbsp;&nbsp;&nbsp;4-3. 栈的应用</option>
<option value="4-4">&nbsp;&nbsp;&nbsp;4-4. 括号匹配问题<br></option>
<option value="4-5">&nbsp;&nbsp;&nbsp;4-5. 时间复杂度为O(n)的解法（用 栈）</option>
<option value="4-6">&nbsp;&nbsp;&nbsp;4-6. 计算后缀表达式<br></option>
<option value="4-7">&nbsp;&nbsp;&nbsp;4-7. 时间复杂度为O(n)的解法（用 栈）<br></option>
<option value="5">5. 队列</option>
<option value="5-1">&nbsp;&nbsp;&nbsp;5-1. 数组实现问题 - 第一部分</option>
<option value="5-2">&nbsp;&nbsp;&nbsp;5-2. 数组实现问题 - 第二部分<br></option>
<option value="5-3">&nbsp;&nbsp;&nbsp;5-3. 数组实现问题 - 第三部分<br></option>
<option value="5-4">&nbsp;&nbsp;&nbsp;5-4. 数组实现问题 - 第四部分<br></option>
<option value="5-5">&nbsp;&nbsp;&nbsp;5-5. 这个时候就需要用到链表了</option>
<option value="5-6">&nbsp;&nbsp;&nbsp;5-6. 队列的应用</option>
<option value="6">6. 双向链表（DLL）</option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. <span style="white-space: normal;">Remove(i) - At Tail (i = N-1),&nbsp;</span>重新访问<br></option>
<option value="6-2">&nbsp;&nbsp;&nbsp;6-2. 固定常数额外的步骤</option>
<option value="7">7. 双端队列（Deque）</option>
<option value="7-1">&nbsp;&nbsp;&nbsp;7-1. 出列的应用</option>
<option value="8">8. 总结</option>
<option value="9">9. 更多</option>
<option value="9-1">&nbsp;&nbsp;&nbsp;9-1. 潜在的讨论话题<br></option>
<option value="9-2">&nbsp;&nbsp;&nbsp;9-2. 我们现在的答案</option>
<option value="9-3">&nbsp;&nbsp;&nbsp;9-3. <span style="white-space: normal;">C++ STL 和 Java API 的实现</span><br></option>
<option value="9-4">&nbsp;&nbsp;&nbsp;9-4. Python and OCaml Standard Library</option>
<option value="9-5">&nbsp;&nbsp;&nbsp;9-5. 在线测试</option>
<option value="9-6">&nbsp;&nbsp;&nbsp;9-6. <ul><li>在线评判练习<br></li></ul></option>
<option value="99">99. 状态面板</option>
<option value="99-1">&nbsp;&nbsp;&nbsp;99-1. 代码追踪面板</option>
<option value="99-2">&nbsp;&nbsp;&nbsp;99-2. 媒体控制</option>
<option value="99-3">&nbsp;&nbsp;&nbsp;99-3. 返回 ”探索模式“</option>
</select>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-next' data-nextid="1-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-1-1" class="electure-dialog" style="top:60px;left:200px;width:500px;">
这里我们将把五种不同的数据结构包括链表（Linked List）， 栈（Stack)，队列（Queue）， 双向链表（Double LinkedList)，双端队列（Double Ended Queue)全部放在链表的环节下。为了多样性，我们随机加载不同的模式：HTTPS://VisualGo.NET/En/List. 但是，您可以直接使用以下URL快捷方式访问单个模式：<div><ol style="white-space: normal;"><li><a href="en/ll"><u>en/ll</u></a>,</li><li><a href="en/stack"><u>en/stack</u></a>,</li><li><a href="en/queue"><u>en/queue</u></a>,</li><li><a href="en/dll"><u>en/dll</u></a>,</li><li><a href="en/deque"><u>en/deque</u></a>.</li></ol></div>
<hr>
<p>Pro-tip: Since you are not <a href="login"><u>logged-in</u></a>, you may be a first time visitor who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b> to advance to the next slide, <b>[PageUp]</b> to go back to the previous slide, <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
几乎所有的计算机科学本科专业都会教链表数据结构。原因如下：<div><ol><li>它是一个简单的线性数据结构。</li><li>做为一个抽象数据类型，它有很广泛的应用。比如，学生名单，活动清单，约会清单等（尽管还有其他更高级的数据结构可以更好地完成相同的应用程序），也可以用来实现堆栈/队列/ 双端队列。</li><li>有些比较特殊的情况来说明为什么需要选择一个合适的数据结构去实现你的目的。</li><li>它具有各种定制的方式，因此通常在面向对象编程（OOP）中来教这种链表数据结构。<br></li></ol></div>
<hr>
<p>Another pro-tip: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2017). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="1-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-2-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
列表的顺序是非常重要的。其中位置顺序{<span style="white-space: normal;">a</span><sub style="white-space: normal;">0</sub><span style="white-space: normal;">, a</span><sub style="white-space: normal;">1</sub><span style="white-space: normal;">, ..., a</span><sub style="white-space: normal;">N-2</sub><span style="white-space: normal;">, a</span><sub style="white-space: normal;">N-1</sub> }。常见列表ADT操作为：<div><ol><li>获取（i）- 也许是一个微不足道的操作，返回<span style="font-family: monospace; white-space: normal;">a</span><sub style="font-family: monospace; white-space: normal;">i</sub>的值（基于0的索引），<br></li><li>搜索（v ）-决定是否存在项/数据v（并报告其位置）或不存在（并且通常在列表中报告不存在的索引-1），<br></li><li>插入（i，v）-插入项目/数据v，在列表中的位置/索引 i，这个操作会有一个可能的问题在与他需要把索引i后面的所有数据都向后移动一位。</li><li>删除（i）- 删除列表中特定位置/索引i的项，这可能会让这个数据i后面的数据全部向前移动一位。</li></ol><div>讨论：如果我们想要在列表中移除一个具体的值v，我们要如何做？</div></div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-2-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-2-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
（紧凑）数组是实现列表ADT（抽象数据类型）的一个很好的候选对象，因为它是处理项目集合的简单结构。<br>当我们说密集阵列（compact array) 时，我们指的是一个没有间隙的数组，即如果数组中有n个项（大小m，其中m&gt;=n），那么只有索引[0…n-1 ]的空间被占用，其他索引[n.M.1]应该保持空。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-4">下一个 <u>PgDn</u></div>
</div>
<div id="electure-2-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
让紧凑数组名称为A，它的索引是<span style="white-space: normal;">[0..</span><b style="white-space: normal;">N</b><span style="white-space: normal;">-1]&nbsp;</span>的。<div><ol><li>获取（i），返回A[i]。如果数组不紧凑，这个简单的操作将会不必要地复杂化。</li><li>搜索（v），我们逐一检查每个索引i<span style="white-space: normal;">∈</span> [0…n-1 ]，看看是否A[i]==v。这是因为v（如果存在）可以在索引[0…n-1 ]中的任何地方。</li><li>插入（i，v），我们将项[i，N-1 ]移到[i+1...N]（从最后面往后移动），并设置一个A[i]＝v。这使得v在索引i中被正确插入并依旧保持紧凑性。<br></li><li>删除（i），我们将项<span style="white-space: normal;">&nbsp;∈&nbsp;</span>[i+1…N-1 ]移到[i, N-2]，重写旧A[i]。这是为了保持紧凑。<br></li></ol></div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-3">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-5">下一个 <u>PgDn</u></div>
</div>
<div id="electure-2-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
get(i), 非常快：只需要访问一次，O（1）。另一个CS模块：“计算机架构”会讨论了这个数组索引操作的O（1）性能的细节。<br>search(v), 在最佳情况下，v在第一位置O（1）中找到。在最坏的情况下，在列表中没有发现V，并且我们需要O（n）扫描来确定。<br>insert(i, v), 在最佳情况下插入（i，v），在i＝n处插入，没有元素的移位，O（1）。在最坏的情况下，在i＝0处插入，我们移动所有n个元素，O（n）。<br>remove(i), 在最佳情况下，在i＝n-1处移除，没有元素的移位，O（1）。在最坏的情况下，在i＝0处移除，我们移动所有n个元素，O（n）。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-4">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-6">下一个 <u>PgDn</u></div>
</div>
<div id="electure-2-6" class="electure-dialog" style="top:60px;left:60px;width:500px;">
密集阵列(compact array)的大小是M且不是无限的，而是有限的数。这带来了一个问题，因为在许多应用中，你可能事先不知道数组的大小。<br>如果M太大，那么闲置的空间就会被浪费掉。如果M太小，那么我们很容易耗尽空间。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-5">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-7">下一个 <u>PgDn</u></div>
</div>
<div id="electure-2-7" class="electure-dialog" style="top:60px;left:60px;width:500px;">
解决方案：使M成为变量。因此，当数组满时，我们创建一个更大的数组（通常是两倍大），并将元素从旧数组移动到新数组。因此，除了（通常很大的）物理计算机存储器大小之外，没有更多的限制。<br><a href="http://en.cppreference.com/w/cpp/container/vector" target="_blank" style="white-space: normal;"><u>C++ STL std::vector</u></a><span style="white-space: normal;">,&nbsp;</span><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html" target="_blank" style="white-space: normal;"><u>Java Vector</u></a><span style="white-space: normal;">, 或者&nbsp;</span><a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html" target="_blank" style="white-space: normal;"><u>Java ArrayList</u></a><span style="white-space: normal;">&nbsp;实现</span>所有可变大小的数组列表。<br>然而，经典的基于数组的空间浪费和复制/转移项目的浪费仍然是有问题的。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-6">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-8">下一个 <u>PgDn</u></div>
</div>
<div id="electure-2-8" class="electure-dialog" style="top:60px;left:60px;width:500px;">
对于固定大小的集合，即我们知道它有多少个元素，或者它最多有多少个元素，比如Max是M个元素，那么简单数组（array)可以被考虑去实现你的需要。<br>对于具有未知大小m的可变大小的集合，以及诸如插入/移除之类的动态操作是常见的，简单数组(array)会是一个糟糕的选择。<br>对于这样的应用，有更好的数据结构。让我们阅读…<br><div><br></div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-7">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
现在我们介绍链表数据结构。它使用指针来允许条目/数据在内存中不连续（这是一个<a href="translation/zh/list/none/all/1?slide=2-2" style="white-space: normal;"><u>简单数组</u></a>的主要区别）。通过将项目i与其相邻项i+1通过指针相关联，将项目从索引0排序为索引N-1。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-8">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-1" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>In its basic form, a single vertex (node) in the Linked List has this rough structure:</p><pre>struct Vertex { // we can use either C struct or C++/Java class<br>  int item; // the data is stored here, an integer in this example<br>  Vertex* next; // this pointer tells us where is the next vertex<br>};</pre><p>Using the default example Linked List [22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)] for illustration, we have:<br><b>a<sub>0</sub></b> with its <b>item</b> = 22 and its <b>next</b> = <b>a<sub>1</sub></b>,<br><b>a<sub>1</sub></b> with its <b>item</b> = 2 and its <b>next</b> = <b>a<sub>2</sub></b>,<br>...<br><b>a<sub>6</sub></b> with its <b>item</b> = 89 and its <b>next</b> = <b>null</b>.</p><br><p>Discussion: Which one is better for a C++ implementation of Linked List? struct or class? How about Java implementation?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-2" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-3" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>We also have a few additional data that we remember in this Linked List data structure. We use the default example Linked List [22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)] for illustration.</p><ol><li>The <b>head</b> pointer points to <b>a<sub>0</sub></b> — it is 22, nothing points to the head item,</li><li>The <b>tail</b> pointer points to <b>a<sub>N-1</sub></b> — it is <b>a<sub>6</sub></b> = 89, nothing is after the tail item.</li></ol><p>That&#39;s it, we only add two more extra variables in data structure.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-4">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-4" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
请注意，在许多计算机科学教科书中关于如何实现一个（单）链表有这各种细微差别，例如（使用尾指针或不使用，循环或否，使用虚设头项），请参阅<span style="white-space: normal;"><a href="translation/zh/list/none/all/1?slide=9-1" style="text-decoration-line: underline; white-space: normal;">此幻灯片</a>。</span><br>我们在这个可视化中的版本（尾部指针，不是循环的，没有虚设头项）可能与你在课堂上学习的不大相同，但是基本的想法应该不变。<br>在这个可视化中，每个顶点都有整数项，但是根据需要可以很容易地将其更改为任何其他数据类型。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-3">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-5">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-5" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Since we only keep the head and tail pointers, list traversal subroutine is needed to reach positions other than the head (index 0) and the tail (index <b>N</b>-1).</p><br><p>As this sub-routine is so frequently used, we will abstract it out as a function. The code below is written in C++.</p><pre>Vertex* Get(int i) { // returns the vertex<br>  Vertex* ptr = head; // we have to start from head<br>  for (int k = 0; k &lt; i; k++) // advance forward i time(s)<br>    ptr = ptr-&gt;next; // the pointers are pointing to the higher index<br>  return ptr;<br>}</pre><p>It runs in O(<b>N</b>) as <b>i</b> can be as big as index <b>N</b>-2.<br>Compare this with <a href="?slide=2-4"><u>array</u></a> where we can access index <b>i</b> in O(<b>1</b>) time.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-4">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-6">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-6" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>As we only have direct reference to the first head item and the last tail item, plus the pointers are pointing to the <b>right</b> (higher position/index), we can only access the rest by starting from the head item and hopping through the next pointers. On the default [22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)], we have:</p><p><br></p><p><span class="slide-actions" onclick="doButtonAction96()">Search(77)</span> — found in the example above at position/index 2 (0-based indexing).</p><br><p><span class="slide-actions" onclick="doButtonAction97()">Search(7)</span> — not found in the example above, and this is only known after all <b>N</b> items are examined, so <samp>Search(v)</samp> has O(<b>N</b>) worst case time complexity.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-5">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-7">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-7" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
由于链表的特性，它比简单数组有更多的情况。<br>大多数第一次学习链表的CS学生通常不知道所有的情况，直到他们发现他们自己的链接列表代码失败时。在这个电子讲课中，我们直接阐述所有的案例。<br>对于插入（i，v），有四个（有效）可能性，即v项被添加到：<ol><li>头节点（在当前第一个项目之前），i＝0，<br></li><li>空链表（与先前的情况类似）<br></li><li>当前链表的尾部，i＝n，<br></li><li>链表的其他位置，i＝〔1…n-1〕。</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-6">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-8">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-8" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>The (C++) code for insertion at head is simple and efficient, in O(<b>1</b>):</p><pre>Vertex* vtx = new Vertex(); // create new vertex vtx from item v<br>vtx-&gt;item = v;<br>vtx-&gt;next = head; // link this new vertex to the (old) head vertex<br>head = vtx; // the new vertex becomes the new head</pre><p>Try <span class="slide-actions" onclick="doButtonAction100()">InsertHead(50)</span>, which is <samp>insert(0, 50)</samp>, on the example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)].</p><br><p>Discussion: What happen if we use <a href="?slide=2-5"><u>array</u></a> implementation for insertion at head of the list?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-7">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-9">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-9" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-8">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-10">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-10" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
空数据结构是一个常见的极端/特殊情况，如果没有正确测试，常常会导致意外的崩溃。将新项目插入到当前空列表中，即在索引i＝0中是有效的。幸运的是，插入头部的伪代码也适用于空列表，在这里我们使用与<a href="translation/zh/list/none/all/1?slide=3-8" style="white-space: normal;"><u>此幻灯片</u></a><span style="white-space: normal;">.</span>中相同的代码（通过稍微的改变，但我们还需要设置tail = head）。<br>尝试<span class="slide-actions" onclick="doButtonAction103()">InsertHead(50)</span>，它是插入（0, 50），但在上面的空链表上。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-9">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-11">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-11" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>With the Linked List traversal <samp>Get(i)</samp> sub-routine, we can now implement insertion in the middle of the Linked List as follows (in C++):</p><pre>Vertex* pre = Get(i-1); // traverse to (i-1)-th vertex, O(N)<br>aft = pre-&gt;next; // aft cannot be null, think about it<br>Vertex* vtx = new Vertex(); // create new vertex<br>vtx-&gt;item = v;<br>vtx-&gt;next = aft; // link this<br>pre-&gt;next = vtx; // and this</pre><p>Try <span class="slide-actions" onclick="doButtonAction102()">Insert(3, 44)</span> on the example Linked List&nbsp;&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)].</p><br><p>Also try <span class="slide-actions" onclick="doButtonAction104()">Insert(6, 55)</span> on the same example Linked List. This is a corner case: Insert at the position of tail item, shifting the tail to one position to its right.</p><br><p>This operation is slow, O(<b>N</b>), due to the need for traversing the list (e.g. if <b>i</b> close to <b>N</b>-1).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-10">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-12">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-12" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>If we also remember the tail pointer as with the implementation <a href="?slide=3-3"><u>in this e-Lecture</u></a> (which is advisable as it is just one additional pointer variable), we can perform insertion beyond the tail item (at <b>i = N</b>) efficiently, in O(<b>1</b>):</p><pre>Vertex* vtx = new Vertex(); // this is also a C++ code<br>vtx-&gt;item = v; // create new vertex vtx from item v<br>tail-&gt;next = vtx; // just link this, as tail is the i = (N-1)-th item<br>tail = vtx; // now update the tail pointer</pre><p>Try <span class="slide-actions" onclick="doButtonAction101()">InsertTail(10)</span>, which is <samp>insert(7, 10)</samp>, on the example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)]&nbsp;. A common misconception is to say that this is insertion at tail. Insertion at tail element is <samp>insert(N-1, v)</samp>. This insertion <b>beyond</b> the tail is <samp>insert(N, v)</samp>.</p><br><p>Discussion: What happen if we use <a href="?slide=2-5"><u>array</u></a> implementation for insertion beyond the tail of the list?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-11">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-13">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-13" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-12">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-14">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-14" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
对于remove（i），有三种可能性：<div><ol><li>链表的头（当前第一项），i＝0，它影响头指针。<br></li><li>链表的尾部，i＝n-1，它影响尾部指针<br></li><li>链表的其他位置，i＝〔1…N-2〕。<br></li></ol><div>讨论：将该幻灯片与<a href="translation/zh/list/none/all/1?slide=3-7" style="white-space: normal;"><u>插入幻灯片</u></a>进行比较，以实现细微差别。从一个空链接列表中删除任何东西是有效的操作吗？<br></div></div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-13">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-15">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-15" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
这种情况很简单：<div>if (head == NULL) return; // 避免当SLL为空时崩溃</div><div>Vertex* temp = head; // 之后我们可以删除它</div><div>head = head-&gt;next; // 更新头部指针</div><div>delete temp; // 删除旧指针<div>在上面的（较短）示例链表<span style="white-space: normal;">&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6 (tail)]&nbsp;</span>上反复尝试<span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span>。它将继续正确地工作直到链表包含一个项目，其中头=尾部项目。如果LL已经是空的，因为它是无效的，我们阻止执行。</div><div>讨论：如果我们使用<a href="translation/zh/list/none/all/1?slide=2-4" style="white-space: normal;"><u>简单数组</u></a>实现来移除列表的头，会发生什么？</div></div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-14">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-16">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-16" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-15">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-17">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-17" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>With the Linked List traversal <samp>Get(i)</samp> sub-routine (<a href="?slide=3-5"><u>discussed earlier</u></a>), we can now implement removal of the middle item of the Linked List as follows (in C++):</p><pre>Vertex* pre = Get(i-1); // traverse to (i-1)-th vertex, O(N)<br>Vertex* del = pre-&gt;next, aft = del-&gt;next;<br>pre-&gt;next = aft; // bypass del<br>delete del;</pre><p>Try <span class="slide-actions" onclick="doButtonAction107()">Remove(5)</span>, the element at index <b>N-2</b> (as <b>N = 7</b> in the example&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)]&nbsp;.<br>This is the worst O(<b>N</b>) case on the example above.</p><br><p>Note that <b>Remove(N-1)</b> is removal at tail that requires us to update the tail pointer, see the next case.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-16">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-18">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-18" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>We can implement the removal of the tail of the Linked List as follows, assuming that the Linked List has more than 1 item (in C++):</p><pre>Vertex* pre = head;<br>temp = head-&gt;next;<br>while (temp-&gt;next != null) // while my neighbor is not the tail<br>  pre = pre-&gt;next, temp = temp-&gt;next;<br>pre-&gt;next = null; // alternatively: pre = Get(N-2), temp = Get(N-1)<br>delete temp; // temp = (old) tail<br>tail = pre; // update tail pointer</pre><p>Try <span class="slide-actions" onclick="doButtonAction106()">RemoveTail()</span> repeatedly on the (shorter) example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6 (tail)]. It will continuously working correctly up until the Linked List contains one item where the head = the tail item and we switch to <a href="?slide=3-15"><u>removal at head</u></a> case. We prevent execution if the LL is already empty as it is an illegal case.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-17">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-19">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-19" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Actually, if we also maintain the size of the Linked List <b>N</b> (compare with <a href="?slide=3-3"><u>this slide</u></a>), we can use the Linked List traversal sub-routine <samp>Get(i)</samp> to implement the removal of the tail of the Linked List this way (in C++):</p><pre>Vertex* pre = Get(N-2); // go to one index just before tail, O(N)<br>pre-&gt;next = null;<br>delete tail;<br>tail = pre; // we have access to old tail</pre><p>Notice that this operation is slow, O(<b>N</b>), just because of the need to update the tail pointer from item <b>N</b>-1 backwards by one unit to item <b>N</b>-2 so that future insertion after tail remains correct... This deficiency will be <a href="?slide=6-1"><u>later addressed</u></a> in Doubly Linked List variant.</p><br><p>Discussion: What happen if we use <a href="?slide=2-5"><u>array</u></a> implementation for removal of tail of the list?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-18">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-20">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-20" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-19">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-21">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-21" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
get（i）是慢的：O（n）。在链表中，我们需要执行从头部元素的顺序访问。<br>search（v）在最佳情况下，v在第一位置中找到, O(1)。在最坏的情况下，在列表中没有发现v，并且我们需要O（n）扫描来确定。<div>insert(i, v)在最佳情况下，插入i＝0或i＝n，在头和尾指针帮助，O（1）。在最坏的情况下，在i＝n-1处插入，我们需要在找到项n-2（在尾部前的一项），O（N）。<br><br>删除（i）在最佳情况下，删除i＝0，头指针帮助，O（1）。在最坏的情况下，在i＝n-1处删除，因为需要更新尾指针O（n）。<br></div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-20">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-22">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-22" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
将<a href="translation/zh/list/none/all/1?slide=3-21" style="white-space: normal;"><u>链表</u></a>与<span style="white-space: normal;">&nbsp;</span><a href="translation/zh/list/none/all/1?slide=2-5" style="white-space: normal;"><u>紧凑数组</u></a>进行比较，纯（单列）链表应用程序是罕见的，因为更简单的可缩放紧凑数组（vector）可以更好地完成工作。<br>然而，允许顶点在内存中不连续的链表的基本概念，让<a href="translation/zh/list/none/all/1?slide=4" style="white-space: normal;"><u>堆栈</u></a><span style="white-space: normal;">&nbsp;和&nbsp;</span><a href="translation/zh/list/none/all/1?slide=5" style="white-space: normal;"><u>队列</u></a><span style="white-space: normal;">.</span>的可以成为一个极好的可调整大小的数据结构。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-21">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="4">下一个 <u>PgDn</u></div>
</div>
<div id="electure-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
堆栈是一种特殊的抽象数据结构或者组合，其主要的（仅有的）操作为将元素加入栈中，称为进栈和将元素移除，称为出栈。堆栈是一种后进先出(LIFO-Last-In-First-Out) 的数据结构。<div><br></div><div>在我们的可视化中，堆栈基本上是一个受保护的单向链表，我们仅能查找栈头的元素（peek），在栈头插入新的元素(入栈)和将现有的元素从栈头移除(出栈)。</div><div><br></div><div>所有操作的时间复杂度为O(1)。</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-22">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-4-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>In most implementations and also in this visualization, Stack is basically a <b>protected</b> (Singly) Linked List where we can only peek at the head item, push a new item only to the head (<a href="?slide=3-9"><u>insert at head</u></a>), e.g. try <span class="slide-actions" onclick="doButtonAction99()">InsertHead(6)</span>, and pop existing item only from the head (<a href="?slide=3-14"><u>remove from head</u></a>), e.g. try <span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span>. All operations are O(1).</p><br><p>In this visualization, we orientate the (Single) Linked List top down, with the head/tail item at the top/bottom, respectively. In the example, we have [2 (top/head)-&gt;7-&gt;5-&gt;3-&gt;1-&gt;9 (bottom/tail)].</p><br><p>Discussion: Can we use vector, a resizeable array, to implement Stack ADT efficiently?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-4-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-4-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
Stack（堆栈）在教科书中有一些非常经典的应用，例如：<br><ol><li>一些其他有趣的应用程序但没有用于教学目的。<br></li><li>括号匹配，<br></li><li>后缀计算器，<br></li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-4">下一个 <u>PgDn</u></div>
</div>
<div id="electure-4-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
数学表达式可以变得相当复杂，例如 <samp style="white-space: normal;">{[x+2]^(2+5)-2}*(y+5)</samp><span style="white-space: normal;">.</span><br>括号匹配问题是检查给定输入中所有括号是否正确匹配的问题，即（with）、[with ]和{with}等。<br>括号匹配对于检查源代码的合法性同样有用。<br>讨论：我们可以使用堆栈的LIFO行为来解决这个问题。那么如何解决呢？<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-3">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-5">下一个 <u>PgDn</u></div>
</div>
<div id="electure-4-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-4">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-6">下一个 <u>PgDn</u></div>
</div>
<div id="electure-4-6" class="electure-dialog" style="top:60px;left:60px;width:500px;">
后缀表达式是一个数学表达式：<span style="font-family: monospace; white-space: normal;">operand1，operand2，operator</span>格式，不同于我们一般使用的表达式: o<samp style="white-space: normal;">perand1 operator operand2</samp><span style="white-space: normal;">.</span><br>例如，表达式2 3 + 4 *是（2 +3）*4的后缀版本。<br>在后缀表达式中，我们不需要括号。<br>讨论：我们还可以使用堆栈来有效地解决这个问题。那如何呢？<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-5">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-7">下一个 <u>PgDn</u></div>
</div>
<div id="electure-4-7" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-6">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="5">下一个 <u>PgDn</u></div>
</div>
<div id="electure-5" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Queue is another Abstract Data Type in which the items in the collection are kept <b>in order</b> and the main operations on the collection are the addition of items to the back position (enqueue) and removal of items from the front position (dequeue).</p><br><p>It is known as <b>First-In-First-Out (FIFO)</b> data structure as the first item to be enqueued will eventually be the first item to be dequeued, as in real life queues (see below).</p><br><img src="../img/queue_illustration.png" width="100%" alt="Queue Illustration">
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-7">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-5-1" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
如果我们简单地使用<a href="translation/zh/list/none/all/1?slide=2-3" style="white-space: normal;"><u>紧凑数组</u></a>实现这个队列ADT是a<sub>0</sub>是队列的前面，a<sub>n-1</sub>是队列的后端，我们将遇到与dequeue(出列）操作相关的主要性能问题。<br>这是因为在紧凑数组后面的插入速度很快，O（1），但是由于需要移位项目，所以在紧凑数组前面的移除是慢的，请查看<a href="translation/zh/list/none/all/1?slide=2-5" style="white-space: normal;"><u>此幻灯片</u></a>。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-5-2" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
另一种可能的数组（Array）实现是通过两个索引来避免在出列操作期间的项目转移：front（队列前端最项目）和back（队列最尾端的项目）。<br>假设我们使用大小为m＝8项的数组，并且我们的队列的内容如下：<span style="font-family: monospace; white-space: normal;">[2,4,1,7,-,-,-,-]&nbsp;</span>具有前面＝0和后面＝3。<br>如果我们调用<span style="white-space: normal;">dequeue</span>，我们有[-, 4, 1, 1, 7, -，-，-，-]，front = 0＋1＝1，back＝3。<br>如果我们调用enque(5)，我们有<span style="font-family: monospace; white-space: normal;">[-,4,1,7,5,-,-,-]</span>，front＝1，back＝3＋1＝4。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-5-3" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
然而，许多出列和如列操作，我们可能有<samp style="white-space: normal;">[-,-,-,-,-,6,2,3]</samp><span style="white-space: normal;">,&nbsp;</span><b style="white-space: normal;">front = 5</b><span style="white-space: normal;">, and&nbsp;</span><b style="white-space: normal;">back = 7</b>。到目前为止，我们不能插队任何东西，尽管我们在数组的前面有很多空的空间。<br>如果我们允许前索引和后索引在索引M-1到达索引0时“回滚”到索引，则有效地使数组“循环”，并且我们可以使用空的空间。<br>例如，如果我们调用<span style="white-space: normal;">&nbsp;enqueue</span>（8），我们有[8，-，-，-，-，6，2，3]，前面＝5，后面＝（7＋1）% 8＝0。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-4">下一个 <u>PgDn</u></div>
</div>
<div id="electure-5-4" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
然而，这并不能解决数组实现的主要问题：数组的项以连续的方式存储在计算机内存中。<br>稍后再进行几个入列操作，我们可能有[8，10，11，12，13，6，2，3]，front＝5，back＝4。在这一点上，我们不能插队任何其他东西。<br>我们可以放大阵列，例如使M＝2×8＝16，但是这将需要在比较慢的O（n）过程中从索引前（front）到后（back）再复制项目，以具有[6，2，3，8，10，11，12，13，-，-，-，-，-，-，-]，前面（front）＝0，后面（back）＝7。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-3">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-5">下一个 <u>PgDn</u></div>
</div>
<div id="electure-5-5" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
回想一下，在队列中，我们只需要列表的两个极端，一个只用于插入（入队），一个用于删除（出列）。<br>如果我们回顾<a href="translation/zh/list/none/all/1?slide=3-21" style="white-space: normal;"><u>这个幻灯片</u></a>，我们看到在单链接列表中尾部中插入和在头部中移除的是快非常快的，即O（1）。因此，我们将单链表的头/尾分别指定为队列的前/后。然后，因为链表中的项目没有连续存储在计算机内存中，所以我们的链表的大小可以根据需要增加和缩小。<br>在我们的可视化中，队列基本上是一个受保护的单链表，在这里我们只能查看头部项目，将一个新的项目排队到在当前尾之后的一个位置，例如尝试<span class="slide-actions" onclick="doButtonAction108()">Enqueue(random-integer)</span>，并从头部中删除现有的项目，例如，尝试<span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span>（这也是出列操作）。所有的运算都是O（1）。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-4">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-6">下一个 <u>PgDn</u></div>
</div>
<div id="electure-5-6" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
队列ADT通常用于模拟实际队列。<br>队列ADT的一个非常重要的应用是在<span style="white-space: normal;">&nbsp;</span><a href="translation/zh/list/none/all/sssp" style="white-space: normal;"><u>广度优先搜索</u></a>图遍历算法中。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-5">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="6">下一个 <u>PgDn</u></div>
</div>
<div id="electure-6" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<div>双向链表几乎和单向列表一样。唯一的不同是每一个节点都要两个指针。与单向列表相同的是他的继承点都指向下一个节点（如果存在）。但是每个节点有一个额外的指针指向前面的一个节点（如果存在）。</div><div>使用这个额外的指针能够让我们从链表的末尾开始向前迭代，但是这样会使用两倍的内存。但是他的好处是我们会很容易的搜索，插入或者<span style="white-space: normal;">&nbsp;</span><u style="white-space: normal;"><a href="translation/zh/list/noshown/all/1?slide=3-18" style="white-space: normal;">删除比较靠后的节点</a></u>，其时间复杂度是O（1）。如果用单向列表做那么时间复杂度为O（n）。</div><div>在这个可视化的课件中，请注意双向链表的边(edge)是无向（其实也就是双向）边。</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-6">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="6-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-6-1" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
在单链表中删除尾元素的主要问题是我们必须更新尾部指针，以便在删除后尾部指针能指向一个项目(即使我们可以通过尾指针直接访问尾项)。<br>双链表的可以从后面向前移动，我们可以找到尾部指针前的一个项目通过tail-&gt;prev…因此，我们可以通过这种方式实现尾部的移除：<br>Vertex* temp = tail; / /记住尾部项目<br>tail = tail-&gt;prev; //实现O（1）性能的关键步骤<br>tail-&gt;next = null; //删除这个悬空引用<div>delete temp; // 删除旧的尾部指针；<br>现在这个操作是O（1）。尝试<span class="slide-actions" onclick="doButtonAction106()">RemoveTail()</span>示例DLL [22（head）&lt; - &gt; 2 &lt; - &gt; 77 &lt; - &gt; 6 &lt; - &gt; 43 &lt; - &gt; 76 &lt; - &gt; 89（tail）]。<br></div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="6-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-6-2" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>As we have one more pointer <b>prev</b> for each vertex, their values need to be updated too during each insertion or removal. Try all these operations on example DLL [22 (head)&lt;-&gt;2&lt;-&gt;77&lt;-&gt;6&lt;-&gt;43&lt;-&gt;76&lt;-&gt;89 (tail)].</p><br><p>Try <span class="slide-actions" onclick="doButtonAction100()">InsertHead(50)</span> — additional step: 22&#39;s <b>prev</b> pointer points to new head 50.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction101()">InsertTail(10)</span> — additional step: 10&#39;s <b>prev</b> pointer points to old tail 89.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction102()">Insert(3, 44)</span> — additional step: 6&#39;s/44&#39;s <b>prev</b> pointers point to 44/77, respectively.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span> — set new head 2&#39;s <b>prev</b> pointer to null.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction107()">Remove(5)</span> — set 89&#39;s <b>prev</b> pointer to 43.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="7">下一个 <u>PgDn</u></div>
</div>
<div id="electure-7" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
双端队列是一种抽象的数据结构，它是队列的拓展，它可以在队列的两端（头或尾）将元素加入或移除。<div>在我们的可视化中，双端队列基本上是受保护的双链表。我们仅能搜索头/尾的元素（读取头/尾），在头/尾插入新的元素（从头/尾推进），将现有头/尾元素移除（删除头/尾）。所有的操作复杂度为O(1)。</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-7-1" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
双端队列一般用来比较高级的应用，例如在宽度优先搜素算法中找到0/1的加权图最短的路径，滑动窗口技术。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="8">下一个 <u>PgDn</u></div>
</div>
<div id="electure-8" class="electure-dialog" style="bottom:200px;left:60px;width:500px;">
创建操作对于所有五种模式都是相同的。<br>然而，在五种模式之间的搜索/插入/移除操作存在细微差别。<br>对于堆栈，您只能从顶部/顶部查看/限制搜索，推/限制插入和弹出/限制删除。<br>对于队列，您只能从前面窥视/限制搜索，从后面推/限制插入，以及从前面弹出/限制删除。<br>对于双端队列，您可以从前/后，但不能从中间偷看/限制搜索，入队/限制插入，出队/限制删除。<br>单链表和双链表不具有这样的限制。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="9">下一个 <u>PgDn</u></div>
</div>
<div id="electure-9" class="electure-dialog" style="top:60px;left:60px;width:500px;">
我们已经结束了这个电子讲座。<br>但是你可以提前阅读一些额外的挑战。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="8">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-9-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
以下是关于链表的更深入的讨论：<br><ol><li>如果我们不存储尾部指针，会发生什么？<br></li><li>如果我们使用仿真头怎么办？</li><li>如果最后一个尾部项目指向头部项目呢？</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-9-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-9-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<ul><li>C++ STL：<a href="http://en.cppreference.com/w/cpp/container/forward_list" target="_blank" style="white-space: normal;"><u>forward_list</u></a><span style="white-space: normal;">&nbsp;</span>（单链表），<a href="http://en.cppreference.com/w/cpp/container/stack" target="_blank" style="white-space: normal;"><u>堆栈</u></a><span style="white-space: normal;">&nbsp;</span>，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html" target="_blank" style="white-space: normal;"><u>队列</u></a><span style="white-space: normal;">&nbsp;</span>（双链表），<a href="http://en.cppreference.com/w/cpp/container/deque" target="_blank" style="white-space: normal;"><u>deque</u></a>（实际上不使用双向链表，但另一种技术，看cppreference）</li></ul>Java API：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank" style="white-space: normal;"><u>链表</u></a>（已经是双链表）<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html" target="_blank" style="white-space: normal;"><u>堆栈</u></a><span style="white-space: normal;">&nbsp;</span><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html" target="_blank" style="white-space: normal;"><u>队列</u></a>（实际上是一个接口，通常使用链表）<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html" target="_blank" style="white-space: normal;"><u>双端队列</u></a>（实际上是一个接口，通常使用LinkedList类）
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-4">下一个 <u>PgDn</u></div>
</div>
<div id="electure-9-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Python:<br><a href="https://docs.python.org/3/tutorial/datastructures.html" target="_blank"><u>list</u></a> for List/Stack/Queue<br><a href="https://docs.python.org/3/library/collections.html#collections.deque" target="_blank"><u>deque</u></a></p><br><p>OCaml:<br><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html" target="_blank"><u>List</u></a><br><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Stack.html" target="_blank"><u>Stack</u></a><br><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Queue.html" target="_blank"><u>Queue</u></a><br>No built-in support for Deque</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-3">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-5">下一个 <u>PgDn</u></div>
</div>
<div id="electure-9-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
有关这一数据结构的一些更有趣的问题，请在<a href="training?diff=Medium&amp;n=7&amp;tl=0&amp;module=list" style="white-space: normal;"><u>链表</u></a><span style="white-space: normal;">&nbsp;</span>训练模块上实践（不需要登录，只有初级的和中等难度）。<br>但是，对于注册用户，您应该登录，然后转到<span style="white-space: normal;">&nbsp;</span><a href="training" style="white-space: normal;"><u>主训练页面</u></a><span style="white-space: normal;">&nbsp;</span>，完成这个模块，这样您的成就将被记录在您的帐户。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-4">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-6">下一个 <u>PgDn</u></div>
</div>
<div id="electure-9-6" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<ul><li>我们也有一些编程问题，在某种程度上需要使用链表、堆栈、队列或双端队列等数据结构：<a href="https://uva.onlinejudge.org/external/119/11988.pdf" title="" target="_blank" style="white-space: normal;"><u>UVA 11988 - 破键盘（又名北菊文本）</u></a><span style="white-space: normal;">,&nbsp;</span><a href="https://open.kattis.com/problems/backspace" title="" target="_blank" style="white-space: normal;"><u>Kattis-退格</u></a><span style="white-space: normal;">, and&nbsp;</span><a href="https://open.kattis.com/problems/integerlists" title="" target="_blank" style="white-space: normal;"><u>Kattis-整数列表</u></a><span style="white-space: normal;">.</span><br></li></ul><br>尝试巩固和提高你对数据结构的理解。如果可以简化你的算法，你可以使用C++， STL或Java API。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-5">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="99">下一个 <u>PgDn</u></div>
</div>
<div id="electure-99" class="electure-dialog" style="right:150px;bottom:335px;width:500px;">
当操作进行时，状态面板将会有每个步骤的描述。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-6">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-99-1" class="electure-dialog" style="right:170px;bottom:275px;width:180px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-99-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-120px;width:260px;">
使用用户控件控制动画！可用的快捷键有：<div>空格键：绘制／停止／重绘</div><div>左／右箭头：上一步／下一步</div><div>-／+：减缓／增加速度</div><div><br></div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-99-3" class="electure-dialog" style="top:70px;right:60px;width:300px;">
<p>Return to &#39;Exploration Mode&#39; to start exploring!</p><br><p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-2">上一个 <u>PgUp</u></div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>关闭</u></span>
</div>
<div id="actions" class="panel">
<p id="create">创建</p>
<p id="search" class="execAction" onClick="searchGeneric()">搜索(v)</p>
<p id="insert">插入(i,v)</p>
<p id="remove" class="execAction" onClick="removeGeneric()">移除(i)</p>
</div>
<div id="actions-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide actions panel" /></div>
<div id="actions-extras">
<div class="create action-menu-pullout">
<div id="create-empty" class="execAction new-menu-option coloured-menu-option" onClick="empty()"><p>清空</p></div>
<div id="create-random" class="execAction new-menu-option coloured-menu-option" onClick="random()"><p>随机</p></div>
<div id="create-random-sorted" class="execAction new-menu-option coloured-menu-option" onClick="randomSorted()"><p>随机排序</p></div>
<div id="create-random-fixed-size" class="execAction new-menu-option coloured-menu-option" onclick="createModelingOpen('createfixedsize')"><p>随机固定大小</p>
<div id="createfixedsize-input" class="new-menu-option">
<input type="number" id="v-create-size" title="Enter the size of the linked list" autocomplete="off" min=1 max=10 value=7>
<div id="createfixedsize-go" class="execAction coloured-menu-option" onClick="randomFixedSize()" title="Create random fixed size linked list"><p>执行</p></div>
</div>
</div>
<div id="create-from-arr" class="execAction new-menu-option coloured-menu-option" onclick="createModelingOpen('createuserdefined')"><p><span style="white-space: normal;">--- 用户自定义列表&nbsp;---</span><br></p>
<div id="createuserdefined-input" class="new-menu-option">
<input type="text" id="v-create-arr" title="Enter the elements separated by comma" autocomplete="off" value="1,2,3">
<div id="createuserdefined-go" class="execAction coloured-menu-option" onClick="nonRandom()" title="Create random fixed size linked list"><p>执行</p></div>
</div>
</div>
 <div id="create-err" class="err"></div>
</div>
<div class="search action-menu-pullout">

<div id="search-peek-front" style="display: none;" class="execAction new-menu-option coloured-menu-option" onclick="peekDeque('front')"><p>前面</p></div>
<div id="search-peek-back" style="display: none;" class="execAction new-menu-option coloured-menu-option" onclick="peekDeque('back')"><p>返回</p></div>

<div id="search-input" class="new-menu-option">v = <input type="number" id="v-search" title="Enter an Integer" autocomplete="off" min=0 max=99 value=5></div>
<div id="search-go" class="execAction coloured-menu-option" onclick="searchVertex()"><p>执行</p></div>
<div id="search-err" class="err"></div>
</div>
<div class="insert action-menu-pullout">


<div id="pushtop-input" style="display: none;" class="new-menu-option">v = <input type="number" id="v-push-top-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=53></div>
<div id="pushtop-go" style="display: none;" class="execAction coloured-menu-option" onclick="pushTop()"><p>执行</p></div>

<div id="enqueueback-input" style="display: none;" class="new-menu-option">v = <input type="number" id="v-enqueue-back-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=57></div>
<div id="enqueueback-go" style="display: none;" class="execAction coloured-menu-option" onclick="enqueueBack()"><p>执行</p></div>

<div id="insert-deque-input" style="display: none;" class="new-menu-option">v = <input type="number" id="v-insert-deque-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=57></div>
<div id="insert-deque-front" style="display: none;" class="execAction new-menu-option coloured-menu-option" onclick="insertDeque('front')"><p>前面</p></div>
<div id="insert-deque-back" style="display: none;" class="execAction new-menu-option coloured-menu-option" onclick="insertDeque('back')"><p>返回</p></div>


<div id="insert-head" class="execAction new-menu-option coloured-menu-option" onclick="insertModelingOpen('inserthead')"><p><span style="white-space: normal;">i = 0 (头部），v =</span></p>
<div id="inserthead-input" class="new-menu-option">
<input type="number" id="v-insert-head-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=85>
<div id="inserthead-go" class="execAction coloured-menu-option" onClick="insertHead()" title="Insert to Head"><p>执行</p></div>
</div>
</div>
<div id="insert-tail" class="execAction new-menu-option coloured-menu-option" onclick="insertModelingOpen('inserttail')"><p><span style="white-space: normal;">i = N (在尾部之后），v =&nbsp;</span><br></p>
<div id="inserttail-input" class="new-menu-option">
<input type="number" id="v-insert-tail-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=80>
<div id="inserttail-go" class="execAction coloured-menu-option" onClick="insertTail()" title="Insert to Tail"><p>执行</p></div>
</div>
</div>
<div id="insert-kth" class="execAction new-menu-option coloured-menu-option" onclick="insertModelingOpen('insertkth')"><p><span style="white-space: normal;">在i（1…n-1）和v＝中同时指定i</span><br></p>
<div id="insertkth-input" class="new-menu-option">
<input type="number" id="v-insert-kth" title="Enter an Integer" autocomplete="off" min=1 max=9 value=2>
<input type="number" id="v-insert-kth-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=90>
<div id="insertkth-go" class="execAction coloured-menu-option" onClick="insertKth()" title="Insert to kth"><p>执行</p></div>
</div>
</div>
<div id="insert-err" class="err"></div>
</div>
<div class="remove action-menu-pullout">

<div id="remove-deque-front" style="display:none;" class="execAction new-menu-option coloured-menu-option" onclick="removeDeque('front')"><p>前面</p></div>
<div id="remove-deque-back" style="display:none;" class="execAction new-menu-option coloured-menu-option" onclick="removeDeque('back')"><p>返回</p></div>

<div id="remove-head" class="execAction new-menu-option coloured-menu-option" onClick="removeHead()"><p>移除<span style="white-space: normal;">&nbsp;i = 0&nbsp;</span>头部</p></div>
<div id="remove-tail" class="execAction new-menu-option coloured-menu-option" onClick="removeTail()"><p>移除 <span style="white-space: normal;">&nbsp;i = N-1&nbsp;</span>尾部</p></div>
<div id="remove-kth" class="execAction new-menu-option coloured-menu-option" onclick="removeModelingOpen('removekth')"><p>在[ 1…N-2 ]中指定i<br></p>
<div id="removekth-input" class="new-menu-option">
<input type="number" id="v-remove-kth" title="Enter an Integer" autocomplete="off" min=1 max=8 value=2>
<div id="removekth-go" class="execAction coloured-menu-option" onClick="removeKth()" title="Remove k-th"><p>执行</p></div>
</div>
</div>
<div id="remove-err" class="err"></div>
</div>
</div>
<div id="bottom-bar">
<a id="trigger-about">关于</a>
</div>
<div id="about" class="overlays">
<h4>关于</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo在2011年由Steven Halim博士概念化，作为一个工具，帮助他的学生更好地理解数据结构和算法，让他们自己和自己的步伐学习基础。<br>VisuAlgo包含许多高级算法，这些算法在Steven Halim博士的书（“竞争规划”，与他的兄弟Felix Halim博士合作）和其他书中讨论。今天，一些高级算法的可视化/动画只能在VisuAlgo中找到。<br>虽然专门为新加坡国立大学（NUS）学生采取各种数据结构和算法类（例如CS1010，CS1020，CS2010，CS2020，CS3230和CS3230），作为在线学习的倡导者，我们希望世界各地的好奇心发现这些可视化也很有用。<br>VisuAlgo不是从一开始就设计为在小触摸屏（例如智能手机）上工作良好，因为需要满足许多复杂的算法可视化，需要大量的像素和点击并拖动手势进行交互。一个令人尊敬的用户体验的最低屏幕分辨率为1024x768，并且只有着陆页相对适合移动设备。<br>VisuAlgo是一个正在进行的项目，更复杂的可视化仍在开发中。<br>最令人兴奋的发展是自动问题生成器和验证器（在线测验系统），允许学生测试他们的基本数据结构和算法的知识。这些问题是通过一些规则随机生成的，学生的答案会在提交给我们的评分服务器后立即自动分级。这个在线测验系统，当它被更多的世界各地的CS教师采用，应该技术上消除许多大学的典型计算机科学考试手动基本数据结构和算法问题。通过在通过在线测验时设置小（但非零）的重量，CS教练可以（显着地）增加他/她的学生掌握这些基本问题，因为学生具有几乎无限数量的可以立即被验证的训练问题他们参加在线测验。培训模式目前包含12个可视化模块的问题。我们将很快添加剩余的8个可视化模块，以便VisuAlgo中的每个可视化模块都有在线测验组件。<br>另一个积极的发展分支是VisuAlgo的国际化子项目。我们要为VisuAlgo系统中出现的所有英语文本准备一个CS术语的数据库。这是一个很大的任务，需要众包。一旦系统准备就绪，我们将邀请VisuAlgo游客贡献，特别是如果你不是英语母语者。目前，我们还以各种语言写了有关VisuAlgo的公共注释：<br>
<a href="https://weibo.com/p/230418436e9ee80102v4rk" target='_blank'><u>zh</u></a>, <a href='https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689' target='_blank'><u>id</u></a>, <a href="https://blog.naver.com/visualgo_nus" target='_blank'><u>kr</u></a>, <a href='https://www.facebook.com/groups/163215593699283/permalink/824003417620494/' target='_blank'><u>vn</u></a>, <a href='http://pantip.com/topic/32736343' target='_blank'><u>th</u></a>.</p>
</div>
</div>

<script src="../js/jquery-3.3.1.min.js"></script>
<script>
      var PHP_DOMAIN = "";

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        //setTimeout(function() {
          if (retval) { // mode == "exploration" && // now not only for exploration mode, but check if this opens other problems
            $('#current-action').show();
            $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
            $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
            triggerRightPanels();
            isPlaying = true;
          }
        //}, 500);
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.right-links').css('background', surpriseColour);
        $('#login-go').css('background', surpriseColour);

        $('.colour').css("color", surpriseColour); // name
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
          // temporary quick fix for Google Chrome Aug 2016 issue...
          setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 100); // force resize/redraw...
          setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        });

        // overlays stuffs
        $('#trigger-about').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#about').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('.close-overlay').click(function() {
          $('.overlays').fadeOut(function() {
            $('#dark-overlay').fadeOut();
          });
        });

        $('#dark-overlay').click(function() {
          $('.overlays').fadeOut();
          $('#dark-overlay').fadeOut();
        });
      });
    </script>

<script src="../js/jquery-ui.min.js"></script>
<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.3.js"></script>
<script src="../js/visualgo_print.js"></script>
<script src="../js/graph_library.js"></script>
<script>
      function runSlide(slide) {
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 1 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '1-1') {
          $("#e-lecture").html("slide " + slide + " (" + 3 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 4 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-1') {
          $("#e-lecture").html("slide " + slide + " (" + 6 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-2') {
          $("#e-lecture").html("slide " + slide + " (" + 7 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-3') {
          $("#e-lecture").html("slide " + slide + " (" + 9 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-4') {
          $("#e-lecture").html("slide " + slide + " (" + 10 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-5') {
          $("#e-lecture").html("slide " + slide + " (" + 12 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-6') {
          $("#e-lecture").html("slide " + slide + " (" + 13 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-7') {
          $("#e-lecture").html("slide " + slide + " (" + 15 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-8') {
          $("#e-lecture").html("slide " + slide + " (" + 16 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 18 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-1') {
          $("#e-lecture").html("slide " + slide + " (" + 19 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-2') {
          $("#e-lecture").html("slide " + slide + " (" + 21 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-3') {
          $("#e-lecture").html("slide " + slide + " (" + 22 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-4') {
          $("#e-lecture").html("slide " + slide + " (" + 24 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-5') {
          $("#e-lecture").html("slide " + slide + " (" + 25 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-6') {
          $("#e-lecture").html("slide " + slide + " (" + 27 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-7') {
          $("#e-lecture").html("slide " + slide + " (" + 28 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-8') {
          $("#e-lecture").html("slide " + slide + " (" + 30 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-9') {
          $("#e-lecture").html("slide " + slide + " (" + 31 + "%)");
          $("#title-LL").click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-10') {
          $("#e-lecture").html("slide " + slide + " (" + 33 + "%)");
          $("#title-LL").click();
empty();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-11') {
          $("#e-lecture").html("slide " + slide + " (" + 34 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-12') {
          $("#e-lecture").html("slide " + slide + " (" + 36 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-13') {
          $("#e-lecture").html("slide " + slide + " (" + 37 + "%)");
          $("#title-LL").click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-14') {
          $("#e-lecture").html("slide " + slide + " (" + 39 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-15') {
          $("#e-lecture").html("slide " + slide + " (" + 40 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-16') {
          $("#e-lecture").html("slide " + slide + " (" + 42 + "%)");
          $("#title-LL").click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-17') {
          $("#e-lecture").html("slide " + slide + " (" + 43 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-18') {
          $("#e-lecture").html("slide " + slide + " (" + 45 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-19') {
          $("#e-lecture").html("slide " + slide + " (" + 46 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-20') {
          $("#e-lecture").html("slide " + slide + " (" + 48 + "%)");
          $("#title-LL").click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-21') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-22') {
          $("#e-lecture").html("slide " + slide + " (" + 51 + "%)");
          $("#title-LL").click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 53 + "%)");
          $('#title-Stack').click();
$("#v-create-arr").val("2,7,5,3,1,9");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 54 + "%)");
          $('#title-Stack').click();
$("#v-create-arr").val("2,7,5,3,1,9");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-2') {
          $("#e-lecture").html("slide " + slide + " (" + 56 + "%)");
          $('#title-Stack').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-3') {
          $("#e-lecture").html("slide " + slide + " (" + 57 + "%)");
          $('#title-Stack').click();

          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-4') {
          $("#e-lecture").html("slide " + slide + " (" + 59 + "%)");
          $('#title-Stack').click();

          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-5') {
          $("#e-lecture").html("slide " + slide + " (" + 60 + "%)");
          $('#title-Stack').click();

          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-6') {
          $("#e-lecture").html("slide " + slide + " (" + 62 + "%)");
          $('#title-Stack').click();

          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-7') {
          $("#e-lecture").html("slide " + slide + " (" + 63 + "%)");
          $('#title-Stack').click();

          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 65 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-1') {
          $("#e-lecture").html("slide " + slide + " (" + 66 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-2') {
          $("#e-lecture").html("slide " + slide + " (" + 68 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-3') {
          $("#e-lecture").html("slide " + slide + " (" + 69 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-4') {
          $("#e-lecture").html("slide " + slide + " (" + 71 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-5') {
          $("#e-lecture").html("slide " + slide + " (" + 72 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-6') {
          $("#e-lecture").html("slide " + slide + " (" + 74 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 75 + "%)");
          $('#title-DLL').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 77 + "%)");
          $('#title-DLL').click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6-2') {
          $("#e-lecture").html("slide " + slide + " (" + 78 + "%)");
          $('#title-DLL').click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 80 + "%)");
          $('#title-Deque').click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-1') {
          $("#e-lecture").html("slide " + slide + " (" + 81 + "%)");
          $('#title-Deque').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '8') {
          $("#e-lecture").html("slide " + slide + " (" + 83 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9') {
          $("#e-lecture").html("slide " + slide + " (" + 84 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-1') {
          $("#e-lecture").html("slide " + slide + " (" + 86 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-2') {
          $("#e-lecture").html("slide " + slide + " (" + 87 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-3') {
          $("#e-lecture").html("slide " + slide + " (" + 89 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-4') {
          $("#e-lecture").html("slide " + slide + " (" + 90 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-5') {
          $("#e-lecture").html("slide " + slide + " (" + 92 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-6') {
          $("#e-lecture").html("slide " + slide + " (" + 93 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99') {
          $("#e-lecture").html("slide " + slide + " (" + 95 + "%)");
          
          hideEntireActionsPanel();
 
          showStatusPanel();
          showCodetracePanel();
      
        }
        if (slide == '99-1') {
          $("#e-lecture").html("slide " + slide + " (" + 96 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-2') {
          $("#e-lecture").html("slide " + slide + " (" + 98 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-3') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };

      function pushState(slideValue) {
        var url = '/zh/list';
        if (typeof slideValue != 'undefined' && slideValue != null) url += '?slide=' + slideValue;
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5); 
        $('#overlay').show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      $(function() {
        var slide = getUrlParameter('slide');
        
        $.get('/hasvisited' + '/list', function(data) {
          var hasVisited = data['hasvisited'] == '1';
          if (!hasVisited) {
            var postData = {
              '_token': 'kaTPcaTtnnJPvGspW7LRTya6UONjjAL7yXZSCSBh',
              'page': '/list'.substring(1),
            };

            $.post("/visitpage", postData, function(data) {
              // non critical request...
            });

            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
            }

            $("#mode-menu a").trigger("click");
          }
          else {
            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
              $('#mode-menu a').click();
            }    
          }
        }).fail(function() {
          if (typeof slide != undefined && slide != null) {
            cur_slide = slide;
            $('#mode-menu a').click();
          }
        });

        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
      
        $('#electure-1-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-1-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
      
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
      
        $('#electure-2-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
        $('#electure-2-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
      
        $('#electure-2-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
        $('#electure-2-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
      
        $('#electure-2-3 .electure-next').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
        $('#electure-2-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
      
        $('#electure-2-4 .electure-next').click(function() {
          hidePopup();
          runSlide('2-5');
          pushState('2-5');
        });
        $('#electure-2-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
      
        $('#electure-2-5 .electure-next').click(function() {
          hidePopup();
          runSlide('2-6');
          pushState('2-6');
        });
        $('#electure-2-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
      
        $('#electure-2-6 .electure-next').click(function() {
          hidePopup();
          runSlide('2-7');
          pushState('2-7');
        });
        $('#electure-2-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-5');
          pushState('2-5');
        });
      
        $('#electure-2-7 .electure-next').click(function() {
          hidePopup();
          runSlide('2-8');
          pushState('2-8');
        });
        $('#electure-2-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-6');
          pushState('2-6');
        });
      
        $('#electure-2-8 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-7');
          pushState('2-7');
        });
      
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-8');
          pushState('2-8');
        });
      
        $('#electure-3-1 .electure-next').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
        $('#electure-3-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
      
        $('#electure-3-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
        $('#electure-3-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
      
        $('#electure-3-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
        $('#electure-3-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
      
        $('#electure-3-4 .electure-next').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
        $('#electure-3-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
      
        $('#electure-3-5 .electure-next').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
        $('#electure-3-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
      
        $('#electure-3-6 .electure-next').click(function() {
          hidePopup();
          runSlide('3-7');
          pushState('3-7');
        });
        $('#electure-3-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
      
        $('#electure-3-7 .electure-next').click(function() {
          hidePopup();
          runSlide('3-8');
          pushState('3-8');
        });
        $('#electure-3-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
      
        $('#electure-3-8 .electure-next').click(function() {
          hidePopup();
          runSlide('3-9');
          pushState('3-9');
        });
        $('#electure-3-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-7');
          pushState('3-7');
        });
      
        $('#electure-3-9 .electure-next').click(function() {
          hidePopup();
          runSlide('3-10');
          pushState('3-10');
        });
        $('#electure-3-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-8');
          pushState('3-8');
        });
      
        $('#electure-3-10 .electure-next').click(function() {
          hidePopup();
          runSlide('3-11');
          pushState('3-11');
        });
        $('#electure-3-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-9');
          pushState('3-9');
        });
      
        $('#electure-3-11 .electure-next').click(function() {
          hidePopup();
          runSlide('3-12');
          pushState('3-12');
        });
        $('#electure-3-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-10');
          pushState('3-10');
        });
      
        $('#electure-3-12 .electure-next').click(function() {
          hidePopup();
          runSlide('3-13');
          pushState('3-13');
        });
        $('#electure-3-12 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-11');
          pushState('3-11');
        });
      
        $('#electure-3-13 .electure-next').click(function() {
          hidePopup();
          runSlide('3-14');
          pushState('3-14');
        });
        $('#electure-3-13 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-12');
          pushState('3-12');
        });
      
        $('#electure-3-14 .electure-next').click(function() {
          hidePopup();
          runSlide('3-15');
          pushState('3-15');
        });
        $('#electure-3-14 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-13');
          pushState('3-13');
        });
      
        $('#electure-3-15 .electure-next').click(function() {
          hidePopup();
          runSlide('3-16');
          pushState('3-16');
        });
        $('#electure-3-15 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-14');
          pushState('3-14');
        });
      
        $('#electure-3-16 .electure-next').click(function() {
          hidePopup();
          runSlide('3-17');
          pushState('3-17');
        });
        $('#electure-3-16 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-15');
          pushState('3-15');
        });
      
        $('#electure-3-17 .electure-next').click(function() {
          hidePopup();
          runSlide('3-18');
          pushState('3-18');
        });
        $('#electure-3-17 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-16');
          pushState('3-16');
        });
      
        $('#electure-3-18 .electure-next').click(function() {
          hidePopup();
          runSlide('3-19');
          pushState('3-19');
        });
        $('#electure-3-18 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-17');
          pushState('3-17');
        });
      
        $('#electure-3-19 .electure-next').click(function() {
          hidePopup();
          runSlide('3-20');
          pushState('3-20');
        });
        $('#electure-3-19 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-18');
          pushState('3-18');
        });
      
        $('#electure-3-20 .electure-next').click(function() {
          hidePopup();
          runSlide('3-21');
          pushState('3-21');
        });
        $('#electure-3-20 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-19');
          pushState('3-19');
        });
      
        $('#electure-3-21 .electure-next').click(function() {
          hidePopup();
          runSlide('3-22');
          pushState('3-22');
        });
        $('#electure-3-21 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-20');
          pushState('3-20');
        });
      
        $('#electure-3-22 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3-22 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-21');
          pushState('3-21');
        });
      
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-22');
          pushState('3-22');
        });
      
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
      
        $('#electure-4-2 .electure-next').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
      
        $('#electure-4-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
      
        $('#electure-4-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
      
        $('#electure-4-5 .electure-next').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
        $('#electure-4-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
      
        $('#electure-4-6 .electure-next').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
        $('#electure-4-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
      
        $('#electure-4-7 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
      
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
      
        $('#electure-5-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
      
        $('#electure-5-2 .electure-next').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
        $('#electure-5-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
      
        $('#electure-5-3 .electure-next').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
        $('#electure-5-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
      
        $('#electure-5-4 .electure-next').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
        $('#electure-5-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
      
        $('#electure-5-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
        $('#electure-5-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
      
        $('#electure-5-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
      
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
      
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
      
        $('#electure-6-2 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
      
        $('#electure-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
      
        $('#electure-7-1 .electure-next').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-7-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
      
        $('#electure-8 .electure-next').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
      
        $('#electure-9 .electure-next').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
        $('#electure-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
      
        $('#electure-9-1 .electure-next').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
        $('#electure-9-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
      
        $('#electure-9-2 .electure-next').click(function() {
          hidePopup();
          runSlide('9-3');
          pushState('9-3');
        });
        $('#electure-9-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
      
        $('#electure-9-3 .electure-next').click(function() {
          hidePopup();
          runSlide('9-4');
          pushState('9-4');
        });
        $('#electure-9-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
      
        $('#electure-9-4 .electure-next').click(function() {
          hidePopup();
          runSlide('9-5');
          pushState('9-5');
        });
        $('#electure-9-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-3');
          pushState('9-3');
        });
      
        $('#electure-9-5 .electure-next').click(function() {
          hidePopup();
          runSlide('9-6');
          pushState('9-6');
        });
        $('#electure-9-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-4');
          pushState('9-4');
        });
      
        $('#electure-9-6 .electure-next').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
        $('#electure-9-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-5');
          pushState('9-5');
        });
      
        $('#electure-99 .electure-next').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
        $('#electure-99 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-6');
          pushState('9-6');
        });
      
        $('#electure-99-1 .electure-next').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
        $('#electure-99-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
      
        $('#electure-99-2 .electure-next').click(function() {
          hidePopup();
          runSlide('99-3');
          pushState('99-3');
        });
        $('#electure-99-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
      
        $('#electure-99-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
      
 

        // temporary quick fix for Google Chrome Aug 2016 issue..., put at last part so that everything else has been loaded
        // setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 500);
        // setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        // I turn it off on 14 June 2018, seems 'ok'?
      });

      function doButtonAction96() {
        CUSTOM_ACTION('search','77');
      }
      function doButtonAction97() {
        CUSTOM_ACTION('search','7');
      }
      function doButtonAction98() {
        CUSTOM_ACTION('peek');
      }
      function doButtonAction99() {
        CUSTOM_ACTION('push','6');
      }
      function doButtonAction100() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('insert_head','50');
      }
      function doButtonAction101() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('insert_tail','10');
      }
      function doButtonAction102() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('insert_kth','3,44');
      }
      function doButtonAction103() {
        empty();
CUSTOM_ACTION('insert_head','50');
      }
      function doButtonAction104() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('insert_kth','6,55');
      }
      function doButtonAction105() {
        CUSTOM_ACTION('remove_head');
      }
      function doButtonAction106() {
        CUSTOM_ACTION('remove_tail');
      }
      function doButtonAction107() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('remove_kth','5');
      }
      function doButtonAction108() {
        CUSTOM_ACTION('enqueue');
      }

      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();  
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}
    </script>
<script type="text/javascript">

// List Widget
// original author: Steven Kester Yuwono, then cleaned and maintained by Steven Halim

var BACK_EDGE_CONST = 5000;

var List = function() {
  var self = this;
  var graphWidget = new GraphWidget();
  var activeStatus = "list";
  var maxSize = 10;
  var maxStackSize = 7;

  var valueRange = [1, 99]; // Range of valid values of List vertexes allowed
  var maxHeightAllowed = 10;

  var initialArray = [15, 6, 23, 4, 7, 71, 5, 50];
  var initialStackArray = [15, 6, 50, 4];

  /*
   * iL: Internal representation of List in this object
   * The keys are the text of the vertices, and the value is the attributes of the corresponding vertex encapsulated in a JS object, which are:
   * - "prev": text of the prev vertex. If the vertex is root Vertex, the value is null
   * - "next": text of the right child. No child -> null
   * - "cx": X-coordinate of center of the vertex
   * - "cy": Y-coordinate of center of the vertex
   * - "height": height of the Vertex. Height of root is 0
   * - "vtxIdx": Vertex class number of the corresponding Vertex
   *
   * In addition, there is a key called "head" in iL, containing the text of the root Vertex.
   * If List is empty, root is null.
   */

  var iL = {};
  var amountVertex = 0;
  var vertexClassNumberCounter = 9;
  iL["head"] = null;

  init(generateRandomArray(Math.floor((Math.random()*5 + 3))));

  this.setActiveStatus = function(newActiveStatus) {
    if (activeStatus != newActiveStatus) {
      clearScreen();
      activeStatus = newActiveStatus;
      init(generateRandomArray(Math.floor((Math.random()*5 + 3))));
    }
  }

  this.getActiveStatus = function() { return activeStatus; }

  this.widgetRecalculatePosition = function() { recalculatePosition(); }

  this.getGraphWidget = function() { return graphWidget; }

  /* FIRST MENU: Create */

  this.generate = function(initArr) { init(initArr); }

  function generateRandomArray(vertexAmt) {
    var initArr = new Array();
    while (initArr.length < vertexAmt) {
      var random = Math.floor(1 + Math.random()*98);
      if ($.inArray(random, initArr) < 0)
        initArr.push(random);
    }
    return initArr;
  }

  this.generateRandom = function(isSorted) {
    var initArr = generateRandomArray(Math.floor((Math.random()*5 + 3))); // [3..7]
    if (isSorted) initArr.sort(function(a, b) { return a-b; }); // sort it first
    init(initArr);
    return true;
  };

  this.generateRandomFixedSize = function(val) {
    if (activeStatus == "stack") {
      if (val > maxStackSize) {
        $('#create-err').html('抱歉，最大的结点值上限为<span style="white-space: normal;">&nbsp;{maxSize}</span>'.replace("{maxSize}", maxStackSize));
        return false;
      }
    }
    else {
      if (val > maxSize) {
        $('#create-err').html('抱歉，最大的结点值上限为<span style="white-space: normal;">&nbsp;{maxSize}</span>'.replace("{maxSize}", maxSize));
        return false;
      }
    }
    var initArr = generateRandomArray(val);
    init(initArr);
    return true;
  }

  this.generateUserDefined = function(vertexTextArr) {
    var vertexAmt = vertexTextArr.length;
    if (activeStatus == "stack") {
      if (vertexAmt > maxStackSize) {
        $('#create-err').html('抱歉，最大的结点值上限为<span style="white-space: normal;">&nbsp;{maxSize}</span>'.replace("{maxSize}", maxStackSize));
        return false;
      }
    }
    else {
      if (vertexAmt > maxSize) {
        $('#create-err').html('抱歉，最大的结点值上限为<span style="white-space: normal;">&nbsp;{maxSize}</span>'.replace("{maxSize}", maxSize));
        return false;
      }
    }

    if (vertexTextArr == '') { // prevent creation of empty list
      $('#create-err').html('抱歉，最小的结点值为1');
      return false;
    }

    var initArr = new Array();
    for (i = 0; i < vertexTextArr.length; i++) {
      var vt = parseInt(vertexTextArr[i]);
      if (!isNaN(vt) && $.inArray(vt, initArr) < 0) // remove duplicates
        initArr.push(vt);
    }
    init(initArr);
    return true;
  }

  this.getA = function() {
    var theArr = [], currentVertex = iL["head"];
    while (currentVertex != null) {
      theArr.push(currentVertex);
      currentVertex = iL[currentVertex]["next"];
    }
    return theArr;
  }

  /* SECOND MENU: Search (LL, DLL) or Peek (Stack, Queue, Deque -- additional Peek back) */

  this.search = function(val, callback) {
    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = createState(iL), curVtxIdx, key, index = 0;

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The current Linked List is empty, we return NOT_FOUND.
      cs["status"] = '现在的链表为空，我们返还“未找到”';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      // temp = head, index = 0
      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["extratext"] = curVtxIdx + (curVtxIdx == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/temp";
      // This is the current Linked List.
      // We want to search for value v = {val} starting from the head (index 0).
      cs["status"] = '这是现在的链表<div>我们想要从头部（指数为0）开始搜找值<span style="white-space: normal; font-size: 13px;">&nbsp;{val}&nbsp;</span></div>'.replace("{val}", val);
      cs["lineNo"] = 2;
      stateList.push(cs);

      // while (temp.data != input)
      while (parseInt(currentVertex) != parseInt(val)) {
        vertexTraversed[currentVertex] = true;
        cs = createState(iL, vertexTraversed, edgeTraversed);
        // Comparing {currentVertex} with {val} (index = {index}).
        // {currentVertex} is not equal to {val} so we have to continue.
        cs["status"] = '<span style="white-space: normal;">将 {currentVertex} 和 {val} (指数&nbsp;= {index}) 进行 比较.</span><br style="white-space: normal;"><span style="white-space: normal;">{currentVertex} 不等于 {val} 所以我们继续</span>'.replace("{currentVertex}", currentVertex).replace("{val}", val).replace("{index}", index).replace("{currentVertex}", currentVertex).replace("{val}", val);
        cs["vl"][curVtxIdx]["extratext"] = curVtxIdx + (curVtxIdx == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/temp";
        cs["lineNo"] = 3;
        stateList.push(cs);

        // case when vertex is not found
        currentVertex = iL[currentVertex]["next"];
        if (currentVertex == null) {
          // temp = temp.next, index++
          cs = createState(iL, vertexTraversed, edgeTraversed);
          // We try advancing temp to the next vertex.
          // But...
          cs["status"] = '我们试着将临时指针前进到下一个结点<div>但是......</div>';
          cs["lineNo"] = 4;
          stateList.push(cs);

          // if temp == null
          //   return -1
          cs = createState(iL, vertexTraversed, edgeTraversed);
          // temp is null (we have gone past the tail after O(N) step(s)).
          // We conclude that value {val} is NOT_FOUND in the Linked List.
          cs["status"] = '临时指针为空（我们已经距离尾部经过了O(N)步）<div>我们得到结论值<span style="white-space: normal; font-size: 13px;">{val} 在链表中“未找到”</span></div>'.replace("{val}", val);
          cs["lineNo"] = [5, 6];
          stateList.push(cs);

          break;
        }

        // temp = temp.next, index++
        // if temp == null
        curVtx = iL[currentVertex]["prev"];
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        var edgeHighlighted = iL[curVtx]["vtxIdx"];
        edgeTraversed[edgeHighlighted] = true;
        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
          edgeTraversed[edgeHighlighted + BACK_EDGE_CONST] = true;
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = curVtxIdx + (curVtxIdx == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/temp";
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
        // So temp advances to the next vertex.
        // temp is not null, continue searching.
        cs["status"] = '所以临时前进到下一个结点<div>临时不为空，继续搜找</div>';
        cs["lineNo"] = [4, 5];
        stateList.push(cs);

        index++;
      }

      // case when vertex is found
      if (currentVertex != null) {
        // return index
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = curVtxIdx + (curVtxIdx == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/temp";
        // Found value v = {val} at this highlighted vertex so we return index {index}.
        // The whole operation is O(N).
        cs["status"] = '<span style="white-space: normal;">在这个高亮的节点找到了值{val}，所以我们返还指数 {index}&nbsp;</span><div><span style="white-space: normal;">整个操作的复杂度为O(N)</span><div><span style="white-space: normal;"> </span></div><div><span style="white-space: normal;"> </span></div><div><span style="white-space: normal;"> </span></div><div><span style="white-space: normal;"> </span></div><div><span style="white-space: normal;"> </span></div></div>'.replace("{val}", val).replace("{index}", index);
        cs["lineNo"] = 7;
        stateList.push(cs);
      }
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(4);
    return true;
  };

  this.peek = function(isHead, callback) {
    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = createState(iL), curVtxIdx, key, index = 0;

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The current Linked List is empty, we return NOT_FOUND.
      cs["status"] = '现在的链表为空，我们返还“未找到”';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      if (!isHead) {
        while (true) { // go to tail
          if (iL[currentVertex]["next"] != null) currentVertex = iL[currentVertex]["next"];
          else break;
        }
      }

      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      // Return the value stored at the head: {currentVertex}.
      cs["status"] = (isHead ? '返还储存在头部的值：<span style="white-space: normal;">{currentVertex}</span>' : '返还储存在尾部的值：<span style="white-space: normal;">{currentVertex}</span>').replace("{currentVertex}", currentVertex);
      cs["lineNo"] = 2;
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(isHead ? 3 : 9);
    return true;
  }

  /* THIRD MENU: Insert (LL, DLL, minor differences only)/Push (Stack)/Enqueue (Queue, Deque) */

  this.insertHead = function(v, callback) {
    var val = parseInt(v);
    var tempinternalList = deepCopy(iL);

    // 1. Check whether value is number
    if (isNaN(val)) {
      // Please fill in an Integer.
      $('#insert-err').html('请填写一个数字');
      return false;
    }
    // 2. No duplicates allowed. Also works if more than one similar value are inserted
    if (tempinternalList[val] != null) {
      // No duplicate vertex allowed!
      $('#insert-err').html('不能有重复的结点！');
      if (typeof callback == 'function') callback();
      return false;
    }
    // 3. Check range
    if (parseInt(val) < valueRange[0] || parseInt(val) > valueRange[1]) {
      // Sorry, only values between {range0} and {range1} can be inserted.
      $('#insert-err').html('抱歉，只能插入值域在<span style="white-space: normal;">&nbsp;{range0} 和 {range1}之间的值&nbsp;</span>'.replace("{range0}", valueRange[0]).replace("{range1}", valueRange[1]));
      return false;
    }
    // 4. check size
    if (activeStatus == "stack") {
      if (amountVertex >= maxStackSize) {
        // Sorry, the maximum size is {maxSize}.
        $('#insert-err').html('抱歉，最大的尺寸为<span style="white-space: normal;">{maxSize}</span>'.replace("{maxSize}", maxStackSize));
        return false;
      }
    }
    else {
      if (amountVertex >= maxSize) {
        // Sorry, the maximum size is {maxSize}.
        $('#insert-err').html('抱歉，最大的尺寸为<span style="white-space: normal;">{maxSize}</span>'.replace("{maxSize}", maxSize));
        return false;
      }
    }

    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;
    if (amountVertex >= 1) cs = createState(iL);
    else                   cs = {};

    // Begin insertion, first, update internal representation
    iL[parseInt(val)] = {
      "next": null,
      "vtxIdx": vertexClassNumberCounter++
    };

    // modified this part for linked list insertion
    var newVtx = parseInt(val);
    var oldHeadIdx;

    iL[newVtx]["cx"] = 50;
    iL[newVtx]["cy"] = 120;

    // if linked list is empty
    amountVertex++;
    if (amountVertex > 1) {
      var tempChild = iL["head"];
      oldHeadIdx = iL[tempChild]["vtxIdx"];
      iL[newVtx]["next"] = tempChild;
      iL[tempChild]["prev"] = newVtx;
      iL["head"] = newVtx;
    }
    else
      iL["head"] = newVtx;

    // Then, draw edge
    var newVtxIdx = iL[parseInt(val)]["vtxIdx"];

    if (amountVertex > 1) {
      // Vertex vtx = new Vertex(v)
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][newVtxIdx]["extratext"] = "vtx";
      cs["vl"][oldHeadIdx]["extratext"] = "head";
      cs["el"][newVtxIdx]["state"] = OBJ_HIDDEN;
      if ((activeStatus == "doublylist") || (activeStatus == "deque"))
        cs["el"][newVtxIdx + BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
      // Create new vertex to store value {val}.
      cs["status"] = '创建一个新的结点来储存值<span style="white-space: normal;">{val}</span>'.replace("{val}", val);
      cs["lineNo"] = 1;
      stateList.push(cs);

      // vtx.next = head
      cs = createState(iL, vertexTraversed, edgeTraversed);
      var edgeHighlighted = iL[newVtx]["vtxIdx"];
      cs["el"][edgeHighlighted]["animateHighlighted"] = true;
      cs["el"][edgeHighlighted]["state"] = EDGE_HIGHLIGHTED;
      cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][newVtxIdx]["extratext"] = "vtx";
      cs["vl"][oldHeadIdx]["extratext"] = "head";
      if ((activeStatus == "doublylist") || (activeStatus == "deque"))
        cs["el"][newVtxIdx + BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
      // Now, temp.next points to the current head.
      cs["status"] = '现在, vtx.next 指向新的头部';
      cs["lineNo"] = 2;
      stateList.push(cs);

      if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
        // if (head != null) head.prev = vtx
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][oldHeadIdx]["extratext"] = "head";
        cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][newVtxIdx]["extratext"] = "vtx";
        cs["el"][newVtxIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
        cs["el"][newVtxIdx+BACK_EDGE_CONST]["animateHighlighted"] = true;
        // (Old) head.prev points to vtx.
        cs["status"] = '（旧）head.prev 指向 vtx';
        cs["lineNo"] = 3;
        stateList.push(cs);
      }
    }
    else {
      // Vertex vtx = new Vertex(v)
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][newVtxIdx]["extratext"] = "vtx";
      // Create new vertex to store value {val}.
      // But as head is currently null, temp.next remains null.
      cs["status"] = '创建一个新的结点来储存值<span style="white-space: normal;">{val}</span>'.replace("{val}", val) + '<br>但因为头部现在为空，临时的后继仍然为空。';
      cs["lineNo"] = [1, 2];
      stateList.push(cs);
    }

    // head = vtx
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = "head/vtx";
    // Now, head points to vtx.
    cs["status"] = '现在, head 指向 vtx';
    if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      cs["lineNo"] = 4;
    else
      cs["lineNo"] = 3;
    stateList.push(cs);

    if (amountVertex == 1) {
      // tail = head
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][newVtxIdx]["extratext"] = "head/tail/vtx";
      // Tail points to head.
      cs["status"] = '尾部指针指向头部';
      cs["lineNo"] = 3;
      stateList.push(cs);
    }

    recalculatePosition();
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = "head" + (amountVertex == 1 ? "/tail" : "") + "/vtx";
    // Re-layout the Linked List for visualization.
    // The whole process is O({N}).
    cs["status"] = '再次铺展链表。<div>整个过程复杂度为 <span style="white-space: normal; font-size: 13px;">O({N}).</span></div>'.replace("{N}", "1");
    cs["lineNo"] = 0;
    stateList.push(cs);

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(1);
    return true;
  }

  this.insertTail = function(v, callback) {
    if (amountVertex == 0) return this.insertHead(v, callback);

    var val = parseInt(v);
    var tempinternalList = deepCopy(iL); // Use this to simulate internal insertion

    // 1. Check whether value is number
    if (isNaN(val)) {
      // Please fill in an Integer.
      $('#insert-err').html('请填写一个数字');
      if (typeof callback == 'function') callback();
      return false;
    }
    // 2. No duplicates allowed. Also works if more than one similar value are inserted
    if (tempinternalList[val] != null) {
      // No duplicate vertex allowed!
      $('#insert-err').html('不能有重复的结点！');
      if (typeof callback == 'function') callback();
      return false;
    }
    // 3. Check range
    if (parseInt(val) < valueRange[0] || parseInt(val) > valueRange[1]) {
      // Sorry, only values between {range0} and {range1} can be inserted.
      $('#insert-err').html('抱歉，只能插入值域在<span style="white-space: normal;">&nbsp;{range0} 和 {range1}之间的值&nbsp;</span>'.replace("{range0}", valueRange[0]).replace("{range1}", valueRange[1]));
      if (typeof callback == 'function') callback();
      return false;
    }
    // 4. check size
    if (amountVertex >= maxSize) {
      // Sorry, the maximum size is {maxSize}.
      $('#insert-err').html('抱歉，最大的尺寸为<span style="white-space: normal;">{maxSize}</span>'.replace("{maxSize}", maxSize));
      if (typeof callback == 'function') callback();
      return false;
    }

    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;

    // Find prev
    while (currentVertex != val && currentVertex != null) {
      var nextVertex;
      nextVertex = iL[currentVertex]["next"];
      if (nextVertex == null) break;
      else                    currentVertex = nextVertex;
    }

    // Begin insertion, first, update internal representation
    var newVtx = parseInt(val);
    var oldTailIdx = iL[currentVertex]["vtxIdx"];

    iL[parseInt(val)] = {
      "next": null,
      "vtxIdx": vertexClassNumberCounter++
    };

    if (currentVertex != null) {
      iL[parseInt(val)]["prev"] = currentVertex;
      iL[currentVertex]["next"] = parseInt(val);
    }
    else {
      iL[parseInt(val)]["prev"] = null;
      iL["head"] = parseInt(val);
    }

    amountVertex++;
    recalculatePosition();

    var newVtxIdx = iL[parseInt(val)]["vtxIdx"];
    curVtxIdx = iL[currentVertex]["vtxIdx"];

    // Vertex vtx = new vertex(v)
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][newVtxIdx]["extratext"] = "vtx";
    cs["vl"][oldTailIdx]["extratext"] = "tail";
    cs["el"][curVtxIdx]["state"] = OBJ_HIDDEN;
    if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      cs["el"][curVtxIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
    // Create new vertex to store value {val}.
    cs["status"] = '创建一个新的结点来储存值<span style="white-space: normal;">{val}</span>'.replace("{val}", val);
    cs["lineNo"] = 1;
    stateList.push(cs);

    // tail.next = vtx
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][newVtxIdx]["extratext"] = "vtx";
    cs["vl"][oldTailIdx]["extratext"] = "tail";
    cs["el"][curVtxIdx]["state"] = EDGE_TRAVERSED;
    cs["el"][curVtxIdx]["animateHighlighted"] = true;
    if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      cs["el"][curVtxIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
    // Now vtx.next points to new vertex.
    cs["status"] = '现在 临时的后继指针指向新结点';
    cs["lineNo"] = 2;
    stateList.push(cs);

    if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][curVtxIdx]["extratext"] = "tail";
      cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][newVtxIdx]["extratext"] = "vtx";
      cs["el"][curVtxIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
      cs["el"][curVtxIdx+BACK_EDGE_CONST]["animateHighlighted"] = true;
      // Update prev pointer of the new vertex to point back to the (old) tail.
      cs["status"] = '更新新结点的pre 指针为指向（旧）尾部的指针';
      cs["lineNo"] = 2;
      stateList.push(cs);
    }

    // tail = vtx
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = "tail/vtx";
    // Now, tail points to the new vertex too.
    // The whole operation is O(1) if we maintain the tail pointer.
    cs["status"] = '现在，尾部指针也指向新的结点。<div>如果我们保留尾部指针，整个操作的复杂度为O(1)</div>';
    cs["lineNo"] = 3;
    stateList.push(cs);

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(2);
    return true;
  }

  this.insertKth = function(index, v, callback) {
    // index checking start
    if (isNaN(index)) {
      // Please fill in an Integer.
      $('#insert-err').html('请填写一个数字');
      return false;
    }
    if ((index < 1) || (index > amountVertex)) {
      // Please enter a valid index between [1..{limit}].
      $('#insert-err').html('请在<span style="white-space: normal;">&nbsp;[0..{limit}] 范围内</span>输入一个有效的指数'.replace("{limit}", Math.max(1, amountVertex-1)));
      return false;
    }

    // check if it is insertion at index 0/N i.e. insert head/tail, respectively (will no longer be used?)
    if (index == 0)            return this.insertHead(v);
    if (index == amountVertex) return this.insertTail(v);

    var val = parseInt(v);
    var tempinternalList = deepCopy(iL); // Use this to simulate internal insertion

    // 1. Check whether value is number
    if (isNaN(val)) {
      // Please fill in an Integer.
      $('#insert-err').html('请填写一个数字');
      return false;
    }
    // 2. No duplicates allowed. Also works if more than one similar value are inserted
    if (tempinternalList[val] != null) {
      // No duplicate vertex allowed!
      $('#insert-err').html('不能有重复的结点！');
      return false;
    }
    // 3. Check range
    if (parseInt(val) < valueRange[0] || parseInt(val) > valueRange[1]) {
      // Sorry, only values between {range0} and {range1} can be inserted.
      $('#insert-err').html('抱歉，只能插入值域在<span style="white-space: normal;">&nbsp;{range0} 和 {range1}之间的值&nbsp;</span>'.replace("{range0}", valueRange[0]).replace("{range1}", valueRange[1]));
      return false;
    }
    // 4. check size
    if (amountVertex >= maxSize) {
      // Sorry, the maximum size is {maxSize}.
      $('#insert-err').html('抱歉，最大的尺寸为<span style="white-space: normal;">{maxSize}</span>'.replace("{maxSize}", maxSize));
      return false;
    }

    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {};
    var temp1Idx, temp2Idx, newVtxIdx;

    // Vertex prev = head
    cs = createState(iL, vertexTraversed, edgeTraversed);
    temp1Idx = iL[currentVertex]["vtxIdx"];
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = "0/head/pre";
    vertexTraversed[currentVertex] = true;
    // Set prev to head.
    cs["status"] = '设定临时指针 temp1 为 头部';
    cs["lineNo"] = 1;
    stateList.push(cs);

    // Find prev
    // for (k = 0; k < i; k++)
    var i = 0;
    for (var k = 0; k < index-1; k++) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      temp1Idx = iL[currentVertex]["vtxIdx"];
      cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
      vertexTraversed[currentVertex] = true;
      // Increment k, index specified has not been reached.
      // k is now: {k}.
      cs["status"] = '递减k，特定的指数还没有达到。<div>k现在是：<span style="white-space: normal; font-size: 13px;">{k}</span></div>'.replace("{k}", k);
      cs["lineNo"] = 2;
      stateList.push(cs);

      var nextVertex;
      nextVertex = iL[currentVertex]["next"];

      if (nextVertex == null) break;
      else                    currentVertex = nextVertex;

      // pre = pre.next
      curVtx = iL[currentVertex]["prev"];
      cs = createState(iL, vertexTraversed, edgeTraversed);
      var edgeHighlighted = iL[curVtx]["vtxIdx"];
      edgeTraversed[edgeHighlighted] = true;
      cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
      cs["el"][edgeHighlighted]["animateHighlighted"] = true;
      cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
      // We set prev to the next vertex.
      cs["status"] = 'We set prev to the next vertex.';
      cs["lineNo"] = 3;
      stateList.push(cs);

      i++;
    }

    if (currentVertex != null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      temp1Idx = iL[currentVertex]["vtxIdx"];
      cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
      vertexTraversed[currentVertex] = true;
      // We have found the insertion point.
      // We continue the next insertion step.
      cs["status"] = '我们找到了插入点。<br><div>我们继续下一步插入的操作</div>';
      cs["lineNo"] = 2;
      stateList.push(cs);
    }

    // Begin insertion, first, update internal representation
    // Vertex aft = pre.next
    var temp2Vertex = iL[currentVertex]["next"];
    temp2Idx = iL[temp2Vertex]["vtxIdx"];
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
    cs["vl"][temp2Idx]["extratext"] = (i+1) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
    cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
    cs["el"][temp1Idx]["animateHighlighted"] = true;
    edgeTraversed[temp1Idx] = true;
    // The specified index is found.
    // pre is before the insertion point and aft is the insertion point.
    cs["status"] = '指定的';
    cs["lineNo"] = 4;
    stateList.push(cs);

    iL[parseInt(val)] = {
      "next": null,
      "vtxIdx": vertexClassNumberCounter++
    };
    amountVertex++;
    //modified this part for linked list insertion
    var newVtx = parseInt(val);
    newVtxIdx = iL[parseInt(val)]["vtxIdx"];
    var tempChild;

    iL[newVtx]["cx"] = iL[temp2Vertex]["cx"];
    iL[newVtx]["cy"] = iL[temp2Vertex]["cy"] + 70;

    // vertex vtx = new Vertex(v)
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
    cs["vl"][temp2Idx]["extratext"] = (i+1) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = "vtx";
    // Create new vertex to store value {val}.
    cs["status"] = '创建一个新的结点来储存值<span style="white-space: normal;">{val}</span>'.replace("{val}", val);
    cs["lineNo"] = 5;
    stateList.push(cs);
    edgeTraversed[newVtxIdx] = true;

    // RELINK THE POINTERs
    iL[newVtx]["next"] = temp2Vertex;
    iL[temp2Vertex]["prev"] = newVtx;

    // vtx.next = aft
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
    cs["vl"][temp2Idx]["extratext"] = (i+1) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = "vtx";
    cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
    cs["el"][newVtxIdx]["state"] = EDGE_GREEN;
    cs["el"][newVtxIdx]["animateHighlighted"] = true;
    if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      cs["el"][newVtxIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
    // v.next points to aft.
    cs["status"] = '<span style="white-space: normal;">vtx.next 指向 aft.</span>';
    cs["lineNo"] = 6;
    stateList.push(cs);

    // aft.prev = v (for DLL and deque)
    if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
      cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
      cs["vl"][temp2Idx]["extratext"] = (i+1) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
      cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][newVtxIdx]["extratext"] = "vtx";
      cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
      cs["el"][newVtxIdx]["state"] = EDGE_GREEN;
      cs["el"][newVtxIdx+BACK_EDGE_CONST]["state"] = EDGE_GREEN;
      cs["el"][temp1Idx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
      // aft.prev points to vtx.
      cs["status"] = '<span style="white-space: normal;">aft.prev 指向 vtx.</span>';
      cs["lineNo"] = 6;
      stateList.push(cs);
    }

    iL[currentVertex]["next"] = newVtx;
    iL[newVtx]["prev"] = currentVertex;

    // pre.next = vtx
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
    cs["vl"][temp2Idx]["extratext"] = (i+2) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = (i+1) + "/vtx";
    cs["el"][newVtxIdx]["state"] = EDGE_GREEN;
    cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
    if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      cs["el"][temp1Idx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
    // pre.next points to vtx.
    cs["status"] = 'pre.next 指向  vtx';
    cs["lineNo"] = 7;
    stateList.push(cs);

    // vtx.prev = pre
    if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
      cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
      cs["vl"][temp2Idx]["extratext"] = (i+2) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
      cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][newVtxIdx]["extratext"] = temp2Idx + "/vtx";
      cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
      cs["el"][temp1Idx+BACK_EDGE_CONST]["state"] = EDGE_TRAVERSED;
      // vtx.prev points to pre.
      cs["status"] = '<span style="white-space: normal;">vtx.prev 指向 to pre.</span>';
      cs["lineNo"] = 7;
      stateList.push(cs);
    }

    recalculatePosition();
    cs = createState(iL, {}, {});
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = (i+1) + "/vtx";
    // Re-layout the Linked List for visualization.
    // The whole process is O({N}).
    cs["status"] = '再次铺展链表。<div>整个过程复杂度为 <span style="white-space: normal; font-size: 13px;">O({N}).</span></div>'.replace("{N}", "N");
    cs["lineNo"] = 0;
    stateList.push(cs);

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(0);
    return true;
  }

  /* FOURTH MENU: Remove */

  this.removeHead = function(callback) {
    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The Linked List is already empty.
      // No action is performed.
      cs["status"] = '链表已经空了。<div>无操作。</div>';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      if (iL[currentVertex]["next"] == null) { // head has no next vertex
        // temp = head
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        // The head is the only vertex in this List.
        cs["status"] = '头部是这个列表中唯一一个结点。';
        cs["lineNo"] = 2;
        stateList.push(cs);

        // head = head.next
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        // Head points to next (which is null).
        cs["status"] = '头部指针指向下一个(即为空)。';
        cs["lineNo"] = 3;
        stateList.push(cs);

        curVtxIdx = iL[currentVertex]["vtxIdx"];

        // delete temp
        iL["head"] = null;
        delete iL[currentVertex];
        delete vertexTraversed[currentVertex];
        delete edgeTraversed[curVtxIdx];

        cs = createState(iL, vertexTraversed, edgeTraversed);
        // Remove head vertex.
        // We now have an empty List.
        cs["status"] = '移除前端结点。<div>我们现在有一个空的列表。</div>';
        cs["lineNo"] = 4;
        stateList.push(cs);
      }
      else { // head has next vertex
        // temp = head
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = "head/temp";
        // The head has a next vertex.
        cs["status"] = '头部指针已有下一个结点。';
        cs["lineNo"] = 2;
        stateList.push(cs);

        var rightChildVertex = iL[currentVertex]["next"];
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        nextVtxIdx = iL[rightChildVertex]["vtxIdx"];

        // head = head.next
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = "temp";
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        cs["vl"][nextVtxIdx]["extratext"] = "head";
        cs["el"][curVtxIdx]["state"] = EDGE_GREEN;
        cs["el"][curVtxIdx]["animateHighlighted"] = true;
        // head points to the next vertex.
        cs["status"] = '头部指针指向下一个结点。';
        cs["lineNo"] = 3;
        stateList.push(cs);

        iL["head"] = rightChildVertex;
        iL[rightChildVertex]["prev"] = null;

        // delete temp
        delete iL[currentVertex];
        delete vertexTraversed[currentVertex];
        delete edgeTraversed[curVtxIdx];
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        // Delete temp = (previous) head.
        cs["status"] = '删除 临时 = (之前的) 头部。';
        cs["lineNo"] = 4;
        stateList.push(cs);

        if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
          // head.prev = null
          cs = createState(iL, vertexTraversed, edgeTraversed);
          cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
          // Set head.prev to null for consistency purpose.
          cs["status"] = '为了一致性，将头部的前继设置为空。';
          cs["lineNo"] = 5;
          stateList.push(cs);
        }

        // relayout
        amountVertex--;
        recalculatePosition(); // this line triggers some D3.js errors although OK? find the root cause?
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        if (amountVertex == 1) cs["vl"][nextVtxIdx]["extratext"] = "head/tail";
        // Re-layout the Linked List for visualization.
        // The whole process is O({N}).
        cs["status"] = '再次铺展链表。<div>整个过程复杂度为 <span style="white-space: normal; font-size: 13px;">O({N}).</span></div>'.replace("{N}", "1");
        stateList.push(cs);
      }
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(5);
    return true;
  }

  this.removeTail = function(callback) {
    if (amountVertex == 1) return this.removeHead(callback); // special case

    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The Linked List is already empty.
      // No action is performed.
      cs["status"] = '链表已经空了。<div>无操作。</div>';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      var nextVertex = iL[currentVertex]["next"], nextVtxIdx;

      // Vertex pre = head
      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["extratext"] = "head/pre";
      // Set up pre pointer.
      // pre will eventually point to the last vertex before tail.
      cs["status"] = '建立 pre 指针。<div>pre 将在指向尾部前最终指向最后一个结点。</div>';
      cs["lineNo"] = 2;
      stateList.push(cs);

      // temp = head.next
      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["extratext"] = "head/pre";
      nextVtxIdx = iL[nextVertex]["vtxIdx"];
      cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][nextVtxIdx]["extratext"] = (iL[nextVertex]["next"] == null ? "tail/" : "") + "temp";
      cs["el"][curVtxIdx]["animateHighlighted"] = true;
      cs["el"][curVtxIdx]["state"] = EDGE_TRAVERSED;
      // Set up temp pointer.
      // temp will eventually point to the current tail.
      cs["status"] = '建立临时指针。<div>指针最终会指向现有的尾部。</div>';
      cs["lineNo"] = 3;
      stateList.push(cs);

      // Find vertex
      var i = 0;
      while (true) {
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = (i == 0 ? "head/" : "") + "pre";
        nextVtxIdx = iL[nextVertex]["vtxIdx"];
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        cs["vl"][nextVtxIdx]["extratext"] = (iL[nextVertex]["next"] == null ? "tail/" : "") + "temp";
        vertexTraversed[currentVertex] = true;
        // Check if temp.next is null.
        cs["status"] = '检查临时的后继是否为空。';
        cs["lineNo"] = 4;
        stateList.push(cs);

        if (iL[nextVertex]["next"] != null) {
          nextVertex = iL[nextVertex]["next"];
          currentVertex = iL[currentVertex]["next"];
          i++;
        }
        else
          break;

        // pre = pre.next, temp = temp.next
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = (i == 0 ? "head/" : "") + "pre";
        nextVtxIdx = iL[nextVertex]["vtxIdx"];
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        cs["vl"][nextVtxIdx]["extratext"] = (iL[nextVertex]["next"] == null ? "tail/" : "") + "temp";
        vertexTraversed[currentVertex] = true;
        curVtx = iL[currentVertex]["prev"];
        var edgeHighlighted = iL[curVtx]["vtxIdx"];
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
        edgeTraversed[edgeHighlighted] = true;
        var edgeHighlighted2 = iL[currentVertex]["vtxIdx"];
        cs["el"][edgeHighlighted2]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted2]["state"] = EDGE_GREEN;
        // It is not null.
        // So both pre and temp pointers advance to their next vertex.
        cs["status"] = '它不是空。<div>所以pre和临时的指针都移至他们下一个结点。</div>';
        cs["lineNo"] = 5;
        stateList.push(cs);
      }

      // pre.next = null
      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      nextVtxIdx = iL[nextVertex]["vtxIdx"];
      cs["el"][curVtxIdx]["state"] = OBJ_HIDDEN;
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["extratext"] = (i == 0 ? "head/" : "") + "pre";
      nextVtxIdx = iL[nextVertex]["vtxIdx"];
      cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][nextVtxIdx]["extratext"] = "tail/temp";
      vertexTraversed[currentVertex] = true;
      // It is null.
      // So set the next of pre (the new tail) to null.
      cs["status"] = '它为空。<div>所以我们将pre的后继（新的尾部）设为空。</div>';
      cs["lineNo"] = 6;
      stateList.push(cs);

      var curVtx = iL[nextVertex]["prev"];
      if (curVtx != null) iL[curVtx]["next"] = null;
      else                iL["head"] = null;

      // delete temp, tail = pre
      delete iL[nextVertex];
      delete vertexTraversed[nextVertex];
      delete edgeTraversed[nextVtxIdx];

      amountVertex--;

      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      if (amountVertex == 1) cs["vl"][curVtxIdx]["extratext"] = "head/tail";
      // Delete temp (the previous tail) then update the tail pointer to prev (the current tail). The whole process is O(N) just to find the pre pointer.
      cs["status"] = '删除临时（原来的尾部）然后将尾部的指针设置为pre（现在的尾部）。<div>整个找到pre指针过程的复杂度为O(N) 。</div>';
      cs["lineNo"] = 7;
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(6);
    return true;
  }

  this.removeTailDLL = function(callback) {
    if (amountVertex == 1) return this.removeHead(callback);

    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {};

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The Linked List is already empty.
      // No action is performed.
      cs["status"] = '链表已经空了。<div>无操作。</div>';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      var nextVertex = iL[currentVertex]["next"];
      var curVtxIdx, nextVtxIdx;

      // Find tail vertex
      while (true) {
        if (iL[nextVertex]["next"] != null) {
          nextVertex = iL[nextVertex]["next"];
          currentVertex = iL[currentVertex]["next"];
        }
        else
          break;
      }

      curVtxIdx = iL[currentVertex]["vtxIdx"];
      nextVtxIdx = iL[nextVertex]["vtxIdx"];

      // temp = tail
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][nextVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][nextVtxIdx]["extratext"] = "tail/temp";
      // Set temp to (old) tail.
      cs["status"] = '将临时设置为（原来的）尾部。';
      cs["lineNo"] = 2;
      stateList.push(cs);

      // tail = tail.prev
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][nextVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][nextVtxIdx]["extratext"] = "temp";
      cs["el"][curVtxIdx + BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][curVtxIdx]["extratext"] = "tail";
      // Set tail to tail.prev
      cs["status"] = '将尾部设置为尾部的前继';
      cs["lineNo"] = 3;
      stateList.push(cs);

      // tail.next = null
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][curVtxIdx]["extratext"] = "tail";
      cs["vl"][nextVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][nextVtxIdx]["extratext"] = "temp";
      cs["el"][curVtxIdx]["state"] = OBJ_HIDDEN;
      vertexTraversed[currentVertex] = true;
      // Set the next of (new) tail to null.
      cs["status"] = '将(新的) 尾部的后继设置为空。';
      cs["lineNo"] = 4;
      stateList.push(cs);

      var curVtx = iL[nextVertex]["prev"];
      if (curVtx != null) iL[curVtx]["next"] = null;
      else                iL["head"] = null;

      delete iL[nextVertex];
      delete vertexTraversed[nextVertex];
      delete edgeTraversed[nextVtxIdx];

      amountVertex--;

      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      if (amountVertex == 1) cs["vl"][curVtxIdx]["extratext"] = "head/tail";
      // Delete temp.
      // The whole operations is just O(1) as we can access (old) tail.prev.
      cs["status"] = '删除临时。<div>整个操作的复杂度为O(1) 因为我们可以使用(原来的) 尾部的前继。</div>';
      cs["lineNo"] = 5;
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(8);
    return true;
  }

  this.removeKth = function(v, callback) {
    var index = parseInt(v);

    // Check whether value is number
    if (isNaN(index)) {
      $('#remove-err').html('请填写一个数字');
      return false;
    }
    if (amountVertex < 3) {
      // This operation only works for N bigger than 2.
      $('#remove-err').html('这个操作仅限于N&gt;2');
      return false;
    }
    if ((index < 1) || (index >= amountVertex-1)) {
      // Please enter a valid index between [1..{limit}].
      $('#remove-err').html('请在<span style="white-space: normal;">&nbsp;[0..{limit}] 范围内</span>输入一个有效的指数'.replace("{limit}", Math.max(1, amountVertex-2)));
      return false;
    }

    if (index == 0) return this.removeHead(); // not going to be executable
    if (index == amountVertex-1) {
      if (this.getActiveStatus() == "doublylist") return this.removeTailDLL();
      else                                        return this.removeTail();
    }

    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, prevVtx = iL["head"], delVtx, afterVtx, cs = {};
    var prevIdx, delIdx, afterIdx;

    if (prevVtx == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The Linked List is already empty.
      // No action is performed.
      cs["status"] = '链表已经空了。<div>无操作。</div>';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      // Vertex pre = head
      prevIdx = iL[prevVtx]["vtxIdx"];
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][prevIdx]["extratext"] = "0/head/pre";
      // Set prev to head.
      // Pointer prev will stop at one vertex before the deleted vertex.
      cs["status"] = '将 pre 指向头部。<div>指针pre会在已删除结点的前一个结点停下。</div>';
      cs["lineNo"] = 2;
      stateList.push(cs);

      // Find vertex
      for (i = 0; i < index-1; i++) {
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][prevIdx]["extratext"] = i + (i == 0 ? "/head" : "") + "/pre";
        vertexTraversed[prevVtx] = true;
        // Index specified has not been reached.
        // k = {k}.
        cs["status"] = '指定的索引还未达到。<div>k={i} </div>'.replace("{k}", i);
        cs["lineNo"] = 3;
        stateList.push(cs);

        // important assignment
        var edgeHighlighted = iL[prevVtx]["vtxIdx"]; // before moving
        prevVtx = iL[prevVtx]["next"];
        prevIdx = iL[prevVtx]["vtxIdx"];

        // pre = pre.next
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][prevIdx]["extratext"] = (i+1) + "/pre";
        edgeTraversed[edgeHighlighted] = true;
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
        // Pointer prev advances to the next vertex.
        cs["status"] = '指针 pre 移至下一个结点。';
        cs["lineNo"] = 4;
        stateList.push(cs);
      }

      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][prevIdx]["extratext"] = i + "/pre";
      vertexTraversed[prevVtx] = true;
      // k is 0, prev now points to one vertex behind the vertex to-be-deleted.
      // We stop searching and continue with the removal.
      cs["status"] = 'k为0，pre 现在指向将要被删除的结点。<div>我们停止搜找，继续移除的步骤。</div>';
      cs["lineNo"] = 3;
      stateList.push(cs);

      var delVertex = iL[prevVtx]["next"];
      delIdx = iL[delVertex]["vtxIdx"];
      var afterVertex = iL[delVertex]["next"];
      afterIdx = iL[afterVertex]["vtxIdx"];

      // Vertex del = prev.next
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][prevIdx]["extratext"] = i + "/pre";
      cs["vl"][delIdx]["state"] = VERTEX_RED_FILL;
      cs["vl"][delIdx]["extratext"] = (i+1) + "/del";
      cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][afterIdx]["extratext"] = (i+2) + "/aft";
      edgeTraversed[prevIdx] = edgeTraversed[delIdx] = true;
      cs["el"][prevIdx]["animateHighlighted"] = cs["el"][delIdx]["animateHighlighted"] = true;
      cs["el"][prevIdx]["state"] = EDGE_HIGHLIGHTED;
      cs["el"][delIdx]["state"] = EDGE_RED;
      if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
        cs["el"][prevIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
        cs["el"][delIdx+BACK_EDGE_CONST]["state"] = EDGE_RED;
      }
      vertexTraversed[prevVtx] = true;
      // We store reference to the vertex to-be-deleted.
      // We also store reference to the vertex after the to-be-deleted vertex.
      cs["status"] = '我们储存将要被删除结点的引用。<div>我们也储存将要被删除结点之后的结点的引用。</div>';
      cs["lineNo"] = 5;
      stateList.push(cs);

      // prev.next = after, after.prev = prev (for DLL and deque)
      iL[delVertex]["cy"] = 50+iL[delVertex]["cy"];
      iL[prevVtx]["next"] = afterVertex;
      iL[afterVertex]["prev"] = prevVtx;

      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][prevIdx]["extratext"] = i + "/pre";
      cs["vl"][delIdx]["state"] = VERTEX_RED_FILL;
      cs["vl"][delIdx]["extratext"] = "del";
      cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][afterIdx]["extratext"] = (i+1) + "/aft";
      cs["el"][prevIdx]["animateHighlighted"] = true;
      cs["el"][prevIdx]["state"] = EDGE_HIGHLIGHTED;
      if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
        cs["el"][prevIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
        cs["el"][delIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
      }
      // We connect the vertex behind the vertex to-be-deleted (pointer prev) with the next vertex after the vertex to-be-deleted (pointer after).
      cs["status"] = '我们把将要被删除结点(指针 pre) 和 它之后的结点(指针 after) 连接起来。';
      cs["lineNo"] = 6;
      stateList.push(cs);

      // delete temp
      delete iL[delVertex];
      delete vertexTraversed[delVertex];
      delete edgeTraversed[delIdx];
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
      // Now we delete this vertex.
      cs["status"] = '现在我们删除这个结点';
      cs["lineNo"] = 7;
      stateList.push(cs);
      amountVertex--;

      // relayout list
      recalculatePosition();
      cs = createState(iL, {}, {});
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
      if (amountVertex == 1) cs["vl"][afterIdx]["extratext"] = "head/tail";
      // Re-layout the Linked List for visualization.
      // The whole process is O({N}).
      cs["status"] = '再次铺展链表。<div>整个过程复杂度为 <span style="white-space: normal; font-size: 13px;">O({N}).</span></div>'.replace("{N}", "N");
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(7);
    return true;
  }

  function init(initArr) {
    amountVertex = 0;
    clearScreen();

    for (var i = 0; i < initArr.length; i++) {
      var curVtx = iL["head"];
      var newVtx = parseInt(initArr[i]);

      if (curVtx == null) {
        iL["head"] = parseInt(newVtx);
        iL[newVtx] = {
          "prev": null,
          "next": null,
          "vtxIdx": amountVertex
        };
      }
      else {
        while (true) { // go to tail
          if (iL[curVtx]["next"] == null) break;
          curVtx = iL[curVtx]["next"];
        }
        iL[curVtx]["next"] = newVtx;
        iL[newVtx] = {
          "prev": curVtx,
          "next": null,
          "vtxIdx": amountVertex
        }
      }

      amountVertex++;
    }

    recalculatePosition();

    for (key in iL) {
      if (key == "head") continue;
      graphWidget.addVertex(iL[key]["cx"], iL[key]["cy"], key, iL[key]["vtxIdx"], true, (iL["head"] == key ? "head" : (iL[key]["next"] == null ? "tail" : ""))); // iL[key]["vtxIdx"] + 
    }

    for (key in iL) {
      if (key == "head") continue;
      if (key == iL["head"]) continue;
      var curVtx = iL[key]["prev"];

      graphWidget.addEdge(iL[curVtx]["vtxIdx"], iL[key]["vtxIdx"], iL[curVtx]["vtxIdx"], EDGE_TYPE_DE, 1, true);
      if ((activeStatus == "doublylist") || (activeStatus == "deque"))
        graphWidget.addEdge(iL[key]["vtxIdx"], iL[curVtx]["vtxIdx"], iL[curVtx]["vtxIdx"]+BACK_EDGE_CONST, EDGE_TYPE_DE, 1, true);
    }
  }

  function clearScreen() {
    var key;

    for (key in iL) {
      if (key == "head") continue;
      graphWidget.removeEdge(iL[key]["vtxIdx"] + BACK_EDGE_CONST);
      graphWidget.removeEdge(iL[key]["vtxIdx"]);
    }

    for (key in iL) {
      if (key == "head") continue;
      graphWidget.removeVertex(iL[key]["vtxIdx"]);
    }

    iL = {};
    iL["head"] = null;
    amountVertex = 0;
  }

  this.getN = function() {
    return amountVertex;
  }

  /*
   * iLObject: a JS object with the same structure of iL. This means the List doen't have to be the List stored in this class
   * vertexTraversed: JS object with the vertexes of the List which are to be marked as traversed as the key
   * edgeTraversed: JS object with the edges of the List which are to be marked as traversed as the key
   */

  function createState(iLObject, vertexTraversed, edgeTraversed) {
    if (vertexTraversed == null || vertexTraversed == undefined || !(vertexTraversed instanceof Object))
      vertexTraversed = {};
    if (edgeTraversed == null || edgeTraversed == undefined || !(edgeTraversed instanceof Object))
      edgeTraversed = {};

    var state = {
      "vl": {},
      "el": {}
    };
    var key;

    for (key in iLObject) {
      if (key == "head") continue;

      idx = iLObject[key]["vtxIdx"];

      state["vl"][idx] = {};
      state["vl"][idx]["cx"] = iLObject[key]["cx"];
      state["vl"][idx]["cy"] = iLObject[key]["cy"];
      state["vl"][idx]["text"] = key;
      state["vl"][idx]["state"] = VERTEX_DEFAULT;

      if (iLObject[key]["next"] == null) continue;

      parentChildEdgeId = iLObject[key]["vtxIdx"];

      state["el"][parentChildEdgeId] = {};

      state["el"][parentChildEdgeId]["vertexA"] = iLObject[key]["vtxIdx"];
      state["el"][parentChildEdgeId]["vertexB"] = iLObject[iLObject[key]["next"]]["vtxIdx"];
      state["el"][parentChildEdgeId]["type"] = EDGE_TYPE_DE;
      state["el"][parentChildEdgeId]["weight"] = 1;
      state["el"][parentChildEdgeId]["state"] = EDGE_DEFAULT;
      state["el"][parentChildEdgeId]["animateHighlighted"] = false;

      // add an edge for doubly linked list
      if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
        parentChildEdgeId = iLObject[key]["vtxIdx"]+BACK_EDGE_CONST;
        state["el"][parentChildEdgeId] = {};

        state["el"][parentChildEdgeId]["vertexA"] = iLObject[iLObject[key]["next"]]["vtxIdx"];
        state["el"][parentChildEdgeId]["vertexB"] = iLObject[key]["vtxIdx"];
        state["el"][parentChildEdgeId]["type"] = EDGE_TYPE_DE;
        state["el"][parentChildEdgeId]["weight"] = 1;
        state["el"][parentChildEdgeId]["state"] = EDGE_DEFAULT;
        state["el"][parentChildEdgeId]["animateHighlighted"] = false;
      }
    }

    var cur = iLObject["head"], idx = 0;
    while (cur != null) {
      curIdx = iLObject[cur]["vtxIdx"];
      // state["vl"][curIdx]["extratext"] = idx;
           if (idx == 0)                      state["vl"][curIdx]["extratext"] = "head";
      else if (iLObject[cur]["next"] == null) state["vl"][curIdx]["extratext"] = "tail";
      cur = iLObject[cur]["next"];
      idx++;
    }

    for (key in vertexTraversed) {
      idx = iLObject[key]["vtxIdx"];
      state["vl"][idx]["state"] = VERTEX_TRAVERSED;
    }

    for (key in edgeTraversed) {
      state["el"][key]["state"] = EDGE_TRAVERSED;
      if (state["el"][key+BACK_EDGE_CONST] != null) state["el"][key+BACK_EDGE_CONST] = EDGE_TRAVERSED;
    }

    return state;
  }

  // modified recalculateposition
  function recalculatePosition() {
    updatePosition(iL["head"]);

    function updatePosition(currentVertex) {
      if (currentVertex == null) return;

      if (activeStatus == "stack") { // relayout vertical
        if (currentVertex == iL["head"])
          iL[currentVertex]["cy"] = 20;
        else {
          var curVtx = iL[currentVertex]["prev"]
          iL[currentVertex]["cy"] = iL[curVtx]["cy"] + 70;
        }
        iL[currentVertex]["cx"] = 350;
      }
      else { // relayout horizontal
        if (currentVertex == iL["head"])
          iL[currentVertex]["cx"] = 50;
        else {
          var curVtx = iL[currentVertex]["prev"];
          iL[currentVertex]["cx"] = iL[curVtx]["cx"] + 80;
        }
        iL[currentVertex]["cy"] = 50;
      }

      updatePosition(iL[currentVertex]["next"]);
    }
  }

  function populatePseudocode(act) {
    switch (act) {
      case 4: // search
        $('#code1').html('如果为空，返还 未找到');
        $('#code2').html('<span style="white-space: normal;">index = 0, temp = head</span>');
        $('#code3').html('while (临时的数据 != 输入值)');
        $('#code4').html('&nbsp&nbsp' + '<span style="white-space: normal;">index++, temp = temp.next</span>');
        $('#code5').html('&nbsp&nbsp如果 临时==空');
        $('#code6').html('&nbsp&nbsp&nbsp&nbsp返还 未找到');
        $('#code7').html('返还 索引');
        break;
      case 3: // peek
        $('#code1').html('如果为空，返还 未找到');
        $('#code2').html('返还头部的值');
        $('#code3').html('');
        $('#code4').html('');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 9: // peek back
        $('#code1').html('如果为空，返还 未找到');
        $('#code2').html('返还尾部的值');
        $('#code3').html('');
        $('#code4').html('');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;

      case 1: // insertHead
        $('#code1').html('结点 临时 = new 结点（输入值）');
        $('#code2').html('临时的后继 = 头部');
        if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
          $('#code3').html('if (头部 != 空) 头部的前继 = 临时');
          if (amountVertex == 1)
            $('#code4').html('头部=临时, 尾部=头部');
          else
            $('#code4').html('头部=临时');
        }
        else if (amountVertex == 1) {
          $('#code3').html('头部=临时, 尾部=头部');
          $('#code4').html('');
        }
        else {
          $('#code3').html('头部=临时');
          $('#code4').html('');
        }
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 2: // insertTail
        $('#code1').html('结点 临时 = new 结点（输入值）');
        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
          $('#code2').html('尾部的后继 = 临时，临时的前继 = 尾部');
        else
          $('#code2').html('尾部的后继=临时');
        $('#code3').html('尾部=临时');
        $('#code4').html('');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 0: // Insert
        $('#code1').html('Vertex pre = head');
        $('#code2').html('for (k = 0; k < i-1; k++)');
        $('#code3').html('&nbsp&nbsp' + '临时1 = 临时1的后继');
        $('#code4').html('Vertex aft = pre.next');
        $('#code5').html('顶点 vtx= new 顶点（v）');
        if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
          $('#code6').html('<span style="white-space: normal;">vtx.next = aft, aft.prev = vtx</span>');
          $('#code7').html('<span style="white-space: normal;">pre.next = vtx, vtx.prev = pre</span>');
        }
        else {
          $('#code6').html('<span style="white-space: normal;">vtx.next = aft</span>');
          $('#code7').html('<span style="white-space: normal;">pre.next = vtx</span>');
        }
        break;

      case 5: // remove head
        $('#code1').html('如果为空，不做任何改变');
        $('#code2').html('临时=头部');
        $('#code3').html('头部 = 头部的后继');
        $('#code4').html('删除临时指针');
        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
          $('#code5').html('if (头部 != 空) 头部的前继 = 空');
        else
          $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 6: // remove tail (SLL)
        $('#code1').html('如果为空，不做任何改变');
        $('#code2').html('结点 pre = 头部');
        $('#code3').html('临时 = 头部的后继');
        $('#code4').html('while （临时的后继 != 空）');
        $('#code5').html('&nbsp&nbsp' + 'pre = pre的后继');
        $('#code6').html('pre的后继 = 空');
        $('#code7').html('删除临时，尾部=pre');
        break;
      case 7: // remove kth
        $('#code1').html('如果为空，不做任何改变');
        $('#code2').html('节点 pre = 头部');
        $('#code3').html('for (k = 0; k < i-1; k++)');
        $('#code4').html('&nbsp&nbsp' + 'pre = pre的后继');
        $('#code5').html('节点 del = pre的后继，aft=del的后继');
        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
          $('#code6').html('pre的后继=aft，aft的前继=pre');
        else
          $('#code6').html('pre的后继=aft //跳过 del');
        $('#code7').html('删除 del');
        break;
      case 8: // remove tail (DLL, easier)
        $('#code1').html('如果为空，不做任何改变');
        $('#code2').html('临时=尾部');
        $('#code3').html('尾部=尾部前继');
        $('#code4').html('尾部的后继=空');
        $('#code5').html('删除临时指针');
        $('#code6').html('');
        $('#code7').html('');
        break;
    }
  }
}



// List actions
// actions panel stuff
var actionsWidth = 150;
var statusCodetraceWidth = 420;
var isCreateOpen = false, isSearchOpen = false, isInsertOpen = false, isRemoveOpen = false;

function openCreate() {
  $(".create").css("bottom","146px");
  $('#createfixedsize-input').hide();
  $('#createuserdefined-input').hide();
  if (!isCreateOpen) {
    $('.create').fadeIn('fast');
    isCreateOpen = true;
  }
}

function closeCreate() {
  if (isCreateOpen) {
    $('.create').fadeOut('fast');
    $('#create-err').html("");
    isCreateOpen = false;
  }
}

function openSearch() {
  if (!isSearchOpen) {
    $('.search').fadeIn('fast');
    isSearchOpen = true;
  }
}

function closeSearch() {
  if (isSearchOpen) {
    $('.search').fadeOut('fast');
    $('#search-err').html("");
    isSearchOpen = false;
  }
}

function openInsert() {
  $(".insert").css("bottom","92px");
  $('#insertkth-input').hide();
  $('#inserthead-input').hide();
  $('#inserttail-input').hide();
  if (!isInsertOpen) {
    $('.insert').fadeIn('fast');
    isInsertOpen = true;
  }
}

function closeInsert() {
  if(isInsertOpen) {
    $('.insert').fadeOut('fast');
    $('#insert-err').html("");
    isInsertOpen = false;
  }
}

function openRemove() {
  $(".remove").css("bottom","65px");
  $('#removekth-input').hide();
  if (!isRemoveOpen) {
    $('.remove').fadeIn('fast');
    isRemoveOpen = true;
  }
}

function closeRemove() {
  if (isRemoveOpen) {
    $('.remove').fadeOut('fast');
    $('#remove-err').html("");
    isRemoveOpen = false;
  }
}

function hideEntireActionsPanel() {
  closeCreate();
  closeSearch();
  closeInsert();
  closeRemove();
  hideActionsPanel();
}



// local
// title changing
function SOP() {
  if (isPlaying) stop();
  showActionsPanel();
  hideStatusPanel();
  hideCodetracePanel();
  $("#title-LL").text("LL");
  $("#title-DLL").text("DLL");
}

$('#title-LL').click(function() {
  SOP();
  displayList();
  changeTextList();
  lw.setActiveStatus("list");
  $("#title-LL").text('链表');
});

$('#title-Stack').click(function() {
  SOP();
  displayStack();
  changeTextStack();
  lw.setActiveStatus("stack");
});

$('#title-Queue').click(function() {
  SOP();
  displayQueue();
  changeTextQueue();
  lw.setActiveStatus("queue");
});

$('#title-DLL').click(function() {
  SOP();
  displayList();
  changeTextDoublyList();
  lw.setActiveStatus("doublylist");
  $("#title-DLL").text('双向链表');
});

$('#title-Deque').click(function() {
  SOP();
  displayDeque();
  changeTextDeque();
  lw.setActiveStatus("deque");
});

var lw = new List(), gw;

$(function() {
  $('#play').hide();
  gw = lw.getGraphWidget();
  var five_modes = ["LL", "Stack", "Queue", "DLL", "Deque"];
  $('#title-'+five_modes[Math.floor(Math.random()*5)]).click(); // randomly open one of the five default example every time

  var llMode = getQueryVariable("mode");
  if (llMode.length > 0) {
    $('#title-' + llMode).click();
  }
  var createLL = getQueryVariable("create");
  if (createLL.length > 0) {
    var newLL = createLL.split(",");
    lw.generate(newLL);
  }
  var operation = getQueryVariable("operation");
  var operationValue = getQueryVariable("operationValue");
  var operationMode = getQueryVariable("operationMode");
  if (operation.length > 0) {
    switch (operation) {
      case "insert":
        openInsert();
        insertModelingOpen(operationMode);
        $("#" + operationMode + "-input input").val(operationValue);
    }
  }

  $('#create').click(function() {
    closeSearch();
    closeInsert();
    closeRemove();
    openCreate();
  });

  $('#search').click(function() {
    closeCreate();
    closeInsert();
    closeRemove();
    openSearch();
  });

  $('#insert').click(function() {
    closeCreate();
    closeSearch();
    closeRemove();
    openInsert();
  });

  $('#remove').click(function() {
    closeCreate();
    closeSearch();
    closeInsert();
    openRemove();
  });
});

function allOff() {
  $("#search-input").css("display", "none");
  $("#search-go").css("display", "none");
  $("#search-peek-front").css("display", "none");
  $("#search-peek-back").css("display", "none");

  $("#insert-head").css("display", "none");
  $("#insert-tail").css("display", "none");
  $("#insert-kth").css("display", "none");
  $("#pushtop-input").css("display", "none");
  $("#pushtop-go").css("display", "none");
  $("#enqueueback-input").css("display", "none");
  $("#enqueueback-go").css("display", "none");
  $("#insert-deque-input").css("display", "none");
  $("#insert-deque-front").css("display", "none");
  $("#insert-deque-back").css("display", "none");

  $("#remove-head").css("display", "none");
  $("#remove-tail").css("display", "none");
  $("#remove-kth").css("display", "none");
  $("#remove-deque-front").css("display", "none");
  $("#remove-deque-back").css("display", "none");
}

function displayList() {
  allOff();

  $("#search-input").css("display", "");
  $("#search-go").css("display", "");

  $("#insert-head").css("display", "");
  $("#insert-tail").css("display", "");
  $("#insert-kth").css("display", "");

  $("#remove-head").css("display", "");
  $("#remove-tail").css("display", "");
  $("#remove-kth").css("display", "");
}

function displayStack() {
  allOff();

  $("#pushtop-input").css("display", "");
  $("#pushtop-go").css("display", "");
}

function displayQueue() {
  allOff();

  $("#enqueueback-input").css("display", "");
  $("#enqueueback-go").css("display", "");
}

function displayDeque() {
  allOff();

  $("#search-peek-front").css("display", "");
  $("#search-peek-back").css("display", "");

  $("#insert-deque-input").css("display", "");
  $("#insert-deque-front").css("display", "");
  $("#insert-deque-back").css("display", "");

  $("#remove-deque-front").css("display", "");
  $("#remove-deque-back").css("display", "");
}

function changeTextList() {
  $("#create").text('创建');
  $("#search").text('搜索');
  $("#insert").text('插入');
  $("#remove").text('移除');
}

function changeTextStack() {
  $("#create").text('创建');
  $("#search").text('返还第一个');
  $("#insert").text('插入一个');
  $("#remove").text('移除第一个');
}

function changeTextQueue() {
  $("#create").text('创建');
  $("#search").text('返还第一个');
  $("#insert").text('入队');
  $("#remove").text('出队');
}

function changeTextDoublyList() {
  $("#create").text('创建');
  $("#search").text('搜索');
  $("#insert").text('插入');
  $("#remove").text('移除');
}

function changeTextDeque() {
  $("#create").text('创建');
  $("#search").text('返还第一个');
  $("#insert").text('入队');
  $("#remove").text('出队');
}

function empty() {
  if (isPlaying) stop();
  if (lw.generateRandomFixedSize(0)) {
    $('#progress-bar').slider("option", "max", 0);
    closeCreate();
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function random() {
  if (isPlaying) stop();
  if (lw.generateRandom(false)) {
    $('#progress-bar').slider("option", "max", 0);
    closeCreate();
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function randomSorted() {
  if (isPlaying) stop();
  if (lw.generateRandom(true)) {
    $('#progress-bar').slider("option", "max", 0);
    closeCreate();
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function randomFixedSize() {
  if (isPlaying) stop();
  var input = $('#v-create-size').val();
  input = parseInt(input);
  if (lw.generateRandomFixedSize(input)) {
    $('#progress-bar').slider("option", "max", 0);
    closeCreate();
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function nonRandom() {
  if (isPlaying) stop();
  var input = $('#v-create-arr').val();
  input = input.split(",");
  if (lw.generateUserDefined(input)) {
    $('#progress-bar').slider("option", "max", 0);
    closeCreate();
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function searchVertex(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#v-search').val());
  commonAction(lw.search(input, callback), "搜索 " + input);
  setTimeout(function() {
    if (Math.random() > 0.5) // 50% chance totally random
      $('#v-search').val(1 + Math.floor(Math.random()*99)); 
    else { // 50% something that is inside the list
      var a = lw.getA();
      $('#v-search').val(a[Math.floor(Math.random()*a.length)]);
    }
  }, 500);
}

function peekStack(callback) {
  if (isPlaying) stop();
  commonAction(lw.peek(true, callback), '查看最前端元素（头部）');
}

function peekQueue(callback) {
  if (isPlaying) stop();
  commonAction(lw.peek(true, callback), '查看前端（头部）');
}

function searchGeneric(callback) {
       if (lw.getActiveStatus() == "stack")
    peekStack(callback);
  else if (lw.getActiveStatus() == "queue")
    peekQueue(callback);
}

function peekDeque(location, callback) {
  if (isPlaying) stop();
  if (location == "front")
    commonAction(lw.peek(true, callback), '查看前端（头部）');
  else
    commonAction(lw.peek(false, callback), '查看后端（尾部）');
}

function insertHead(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#v-insert-head-value').val());
  commonAction(lw.insertHead(input, callback), '将<span style="white-space: normal;">&nbsp;{input} 插入前端</span>'.replace("{input}", input));
  setTimeout(function() { $('#v-insert-head-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function insertTail(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#v-insert-tail-value').val());
  commonAction(lw.insertTail(input, callback), '<span style="white-space: normal;">&nbsp;将{input} 插入前端</span><br>'.replace("{input}", input));
  setTimeout(function() { $('#v-insert-tail-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function insertKth(callback) {
  if (isPlaying) stop();
  var index = parseInt($('#v-insert-kth').val());
  var input = parseInt($('#v-insert-kth-value').val());
  commonAction(lw.insertKth(index, input, callback), '<span style="white-space: normal;">&nbsp;在指数为{index}的位置插入{input}</span>'.replace("{input}", input).replace("{index}", index));
  setTimeout(function() {
    $('#v-insert-kth').val(1 + Math.floor(Math.random()*(lw.getN()-1))); // [1..N-1]
    $('#v-insert-kth-value').val(1 + Math.floor(Math.random()*99));
  }, 500);
}

function pushTop(callback) {
  if (isPlaying) stop();
  var input = $('#v-push-top-value').val();
  commonAction(lw.insertHead(input, callback), '<span style="white-space: normal;">将 {input} 插入前端（头部）</span>'.replace("{input}", input));
  setTimeout(function() { $('#v-push-top-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function enqueueBack(callback) {
  if (isPlaying) stop();
  var input = $('#v-enqueue-back-value').val();
  commonAction(lw.insertTail(input, callback), '<span style="white-space: normal;">&nbsp;将{input} 插入后端（队尾）</span><br>'.replace("{input}", input));
  setTimeout(function() { $('#v-enqueue-back-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function insertDeque(location) {
  if (isPlaying) stop();
  var input = $('#v-insert-deque-value').val();
  if (location == "front")
    commonAction(lw.insertHead(input), '<span style="white-space: normal;">&nbsp;将{input} 插入前端（队头）</span><br>'.replace("{input}", input));
  else
    commonAction(lw.insertTail(input), '<span style="white-space: normal;">&nbsp;将{input} 插入后端（队尾）</span><br>'.replace("{input}", input));
  setTimeout(function() { $('#v-insert-deque-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function removeHead(callback) { // PS both pop/stack and dequeue/queue also calls the same thing: remove head
  if (isPlaying) stop();
  commonAction(lw.removeHead(callback), '移除<span style="white-space: normal;">&nbsp;i = 0&nbsp;</span>头部');
}

function removeTail(callback) {
  if (isPlaying) stop();
  if (lw.getActiveStatus() == "doublylist" || lw.getActiveStatus() == "deque")
    commonAction(lw.removeTailDLL(callback), '移除 <span style="white-space: normal;">&nbsp;i = N-1&nbsp;</span>尾部');
  else
    commonAction(lw.removeTail(callback), '移除 <span style="white-space: normal;">&nbsp;i = N-1&nbsp;</span>尾部');
}

function removeKth(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#v-remove-kth').val());
  commonAction(lw.removeKth(input, callback), '<span style="white-space: normal;">移除指数{input}</span>'.replace("{input}", input));
  setTimeout(function() { $('#v-remove-kth').val(1 + Math.floor(Math.random()*(lw.getN()-2))); }, 500); // [1..N-2]
}

function removeGeneric(callback) {
  if ((lw.getActiveStatus() == "stack") || (lw.getActiveStatus() == "queue"))
    removeHead(callback);
}

function removeDeque(location) {
  if (isPlaying) stop();
  if (location == "front")
    commonAction(lw.removeHead(), '从前端移除（头部）');
  else
    commonAction(lw.removeTailDLL(), '从尾端移除（尾部）');
}

function createModelingOpen(modelingType) {
  $(".create").css("bottom", "119px");
  if (modelingType != "createfixedsize")
    $('#createfixedsize-input').fadeOut('fast');
  if (modelingType != "createuserdefined")
    $('#createuserdefined-input').fadeOut('fast');
  $('#'+modelingType+'-input').fadeIn('fast');
}

function insertModelingOpen(modelingType) {
  $(".insert").css("bottom", "65px");
  if (modelingType != "insertkth")
    $('#insertkth-input').fadeOut('fast');
  if (modelingType != "inserthead")
    $('#inserthead-input').fadeOut('fast');
  if (modelingType != "inserttail")
    $('#inserttail-input').fadeOut('fast');
  $('#'+modelingType+'-input').fadeIn('fast');
}

function removeModelingOpen(modelingType) {
  $(".remove").css("bottom", "38px");
  $('#'+modelingType+'-input').fadeIn('fast');
}

// Implement these functions in each visualisation
// var userGraph = {
//   'vl': {},
//   'el': {},
// };

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  //if (lw) userGraph = lw.getGraph();
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  //loadGraph(userGraph);
}

// Lecture action functions
function CUSTOM_ACTION(action, data, mode) {
       if (action == 'search') {
    hideSlide(function() {
      $('#v-search').val(data); // force
      searchVertex(showSlide);
    });
  }
  else if (action == 'peek') {
    hideSlide(function() {
      searchGeneric(showSlide);
    });
  }
  else if (action == 'insert_head') {
    hideSlide(function() {
      $('#v-insert-head-value').val(data); // force
      insertHead(showSlide);
    });
  }
  else if (action == 'insert_tail') {
    hideSlide(function() {
      $('#v-insert-tail-value').val(data); // force
      insertTail(showSlide);
    });
  }
  else if (action == 'insert_kth') {
    hideSlide(function() {
      $('#v-insert-kth').val(data.split(",")[0]); // force
      $('#v-insert-kth-value').val(data.split(",")[1]); // force
      insertKth(showSlide);
    });
  }
  else if (action == 'remove_head') {
    var a = lw.getA();
    if (a.length > 0) {
      hideSlide(function() {
        removeHead(showSlide);
      });
    }
    else
      alert('The Linked List is already empty'); // put in variable?
  }
  else if (action == 'remove_tail') {
    var a = lw.getA();
    if (a.length > 0) {
      hideSlide(function() {
        removeTail(showSlide);
      });
    }
    else
      alert('The Linked List is already empty'); // put in variable?
  }
  else if (action == 'remove_kth') {
    hideSlide(function() {
      $('#v-remove-kth').val(data); // force
      removeKth(showSlide);
    });
  }
  else if (action == 'push') {
    hideSlide(function() {
      $('#v-push-top-value').val(data); // force
      pushTop(showSlide);
    });
  }
  else if (action == 'enqueue') {
    var a = lw.getA();
    if (a.length < 10) {
      var randval = 1 + Math.floor(Math.random()*99);
      while (a.includes(randval))
        randval = 1 + Math.floor(Math.random()*99);
      hideSlide(function() {
        $('#v-enqueue-back-value').val(randval); // force random
        enqueueBack(showSlide);
      });
    }
    else
      alert('The Linked List is already too long for this visualization'); // put in variable?
  }
}
</script>
</body>
</html>
