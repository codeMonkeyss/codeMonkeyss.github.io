<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="description" content="A Binary Search Tree (BST) is a binary tree in which each vertex has only up to 2 children that satisfies BST property: All vertices in the left subtree of a vertex must hold a value smaller than its own and all vertices in the right subtree of a vertex must hold a value larger than its own (we have assumption that all values are distinct integers in this visualization and small tweak is needed to cater for duplicates/non integer). Try clicking Search(7) for a sample animation on searching a random value &amp;in; [1..99] in the random BST above.An Adelson-Velskii Landis (AVL) tree is a self-balancing BST that maintains it&#39;s height to be O(log N) when having N vertices in the AVL tree.Click &#39;Next&#39; (on the top right)/press &#39;Page Down&#39; to advance this e-Lecture slide, use the drop down list/press &#39;Space&#39; to jump to a specific slide, or Click &#39;X&#39; (on the bottom right)/press &#39;Esc&#39; to go to Exploration mode.">
<meta name="keywords" content="Binary Search Tree BST Balanced Adelson Velskii Landis AVL Map Set Search Insert Delete Predecessor Successor Inorder VisuAlgo Data Structure Algorithm Visualization Animation Online Learning Tutorial Lecture">
 
<meta name="csrf-token" content="kaTPcaTtnnJPvGspW7LRTya6UONjjAL7yXZSCSBh">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/bst.png">
<title>VisuAlgo - 二叉搜索树，高度平衡树</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common.css">
<link rel="stylesheet" href="../css/viz-1.0.1.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
      }
      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }
      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
    </style>
<style>
.execAction { padding: 5px 8px; }
.err { padding: 5px 0px; }
#actions-extras input {
  width: 35px;
  padding: 5px 8px 7px;
}

#insert-input input, #remove-input input { width: 100px; }

.create { bottom: 200px; }
.search { bottom: 173px; }
.insert { bottom: 146px; }
.remove { bottom: 119px; }
.predsucc { bottom: 92px; }
.inorder { bottom: 65px; }
</style>
<script>
      function changeURL() {
        var URL = window.location.href.split('/');
        var val = document.getElementById("Language").value;
        URL[3] = val;
        window.location.assign(URL.join('/'));
      }
    </script>
</head>
<body>
<div id="top-bar">
<a id="home" href="/">Visu<span class="colour">Algo</span><span style="font-size: 40%">.net</span></a>
/
<select id="Language" onchange="changeURL()">
<option value="zh" selected>zh</option>
</select>
/bst
<span id="title">
<a id='title-BST' class='selected-viz'>二叉搜索树<br></a>
<a id='title-AVL'>自平衡二叉查找树（AVL 树）</a>
</span>
<div id="mode-menu">
<div id='mode-button' title='exploration'>示例模式 &#9663;</div>
<div id='other-modes'>
<a title='e-Lecture'>电子讲座模式</a>
</div>
</div>
</div>
<div id="dark-overlay"></div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id='speed-control'>减速<div id='speed-input'></div>加速</div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick=goToBeginning()><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick=stepBackward()><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick=pause()><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick=play()><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick=stepForward()><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick=goToEnd()><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id='viz'></div>
<div id='current-action' class='panel'></div>
<div id='e-lecture' class='panel'></div>
<div id="overlay" hidden></div>
<div id="dropdown-temp-holder" hidden></div>
<div id="electure-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>A Binary Search Tree (BST) is a binary tree in which each vertex has only up to 2 children that satisfies <b>BST property</b>: All vertices in the left subtree of a vertex must hold a value smaller than its own and all vertices in the right subtree of a vertex must hold a value larger than its own (we have assumption that all values are distinct integers in this visualization and small tweak is needed to cater for duplicates/non integer). Try clicking <span class="slide-actions" onclick="doButtonAction1()">Search(7)</span> for a sample animation on searching a random value &in; [1..99] in the random BST above.</p><br><p>An Adelson-Velskii Landis (AVL) tree is a <b>self-balancing</b> BST that maintains it&#39;s height to be O(log <b>N</b>) when having <b>N</b> vertices in the AVL tree.</p><br><p>Click &#39;Next&#39; (on the top right)/press &#39;Page Down&#39; to advance this e-Lecture slide, use the drop down list/press &#39;Space&#39; to jump to a specific slide, or Click &#39;X&#39; (on the bottom right)/press &#39;Esc&#39; to go to Exploration mode.</p>
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
Please <a href="login"><u>login</u></a> if you are a repeated visitor or <a href="login"><u>register</u></a> for an (optional) free account first.</p>
<div id='electure-dropdown'>
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. 二叉搜索树</option>
<option value="2">2. BST和平衡BST（AVL树）</option>
<option value="3">3. 动机</option>
<option value="3-1">&nbsp;&nbsp;&nbsp;3-1. 什么样的表ADT？<br></option>
<option value="3-2">&nbsp;&nbsp;&nbsp;3-2. 使用Sorted Array / Vector<br></option>
<option value="3-3">&nbsp;&nbsp;&nbsp;3-3. 使用Sorted Array / Vector</option>
<option value="3-4">&nbsp;&nbsp;&nbsp;3-4. O（log N）复杂性？</option>
<option value="3-5">&nbsp;&nbsp;&nbsp;3-5. 其他表ADT操作</option>
<option value="3-6">&nbsp;&nbsp;&nbsp;3-6. 答案<br></option>
<option value="3-7">&nbsp;&nbsp;&nbsp;3-7. 链接表怎么样？<br></option>
<option value="3-8">&nbsp;&nbsp;&nbsp;3-8. 答案<br></option>
<option value="3-9">&nbsp;&nbsp;&nbsp;3-9. <ul><li>哈希表怎么样？<br></li></ul></option>
<option value="3-10">&nbsp;&nbsp;&nbsp;3-10. The Solution</option>
<option value="4">4. 可视化</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. BST 的节点属性</option>
<option value="4-2">&nbsp;&nbsp;&nbsp;4-2. BST的属性</option>
<option value="5">5. BST的操作</option>
<option value="5-1">&nbsp;&nbsp;&nbsp;5-1. 一些其他的 BST操作</option>
<option value="5-2">&nbsp;&nbsp;&nbsp;5-2. 静态与动态数据结构</option>
<option value="6">6. 搜索(v)<br></option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. FindMin() and FindMax()</option>
<option value="6-2">&nbsp;&nbsp;&nbsp;6-2. O（h）时间复杂性</option>
<option value="7">7. 后继(v)</option>
<option value="7-1">&nbsp;&nbsp;&nbsp;7-1. 前驱(v)</option>
<option value="7-2">&nbsp;&nbsp;&nbsp;7-2. O（h）时间复杂性<br></option>
<option value="8">8. 中序遍历<br></option>
<option value="8-1">&nbsp;&nbsp;&nbsp;8-1. O(N)的时间复杂度</option>
<option value="8-2">&nbsp;&nbsp;&nbsp;8-2. 答案</option>
<option value="8-3">&nbsp;&nbsp;&nbsp;8-3. 前序遍历和后序遍历<br></option>
<option value="9">9. 插入(v)<br></option>
<option value="9-1">&nbsp;&nbsp;&nbsp;9-1. O（h）时间复杂性</option>
<option value="9-2">&nbsp;&nbsp;&nbsp;9-2. 在线测验</option>
<option value="10">10. 删除（v） - 三个可能的案例</option>
<option value="10-1">&nbsp;&nbsp;&nbsp;10-1. 删除（v） - 案例1<br></option>
<option value="10-2">&nbsp;&nbsp;&nbsp;10-2. 删除（v） - 案例2</option>
<option value="10-3">&nbsp;&nbsp;&nbsp;10-3. 删除（v） - 案例3<br></option>
<option value="10-4">&nbsp;&nbsp;&nbsp;10-4. 删除（v） - 案例3讨论</option>
<option value="10-5">&nbsp;&nbsp;&nbsp;10-5. 答案</option>
<option value="10-6">&nbsp;&nbsp;&nbsp;10-6. O（h）时间复杂性</option>
<option value="11">11. 创建BST</option>
<option value="12">12. 间奏曲<br></option>
<option value="12-1">&nbsp;&nbsp;&nbsp;12-1. 尝试探索模式</option>
<option value="13">13. 平衡 BST</option>
<option value="13-1">&nbsp;&nbsp;&nbsp;13-1. AVL 树</option>
<option value="13-2">&nbsp;&nbsp;&nbsp;13-2. 额外的BST属性：身高（v）</option>
<option value="13-3">&nbsp;&nbsp;&nbsp;13-3. 高度的正式定义（v）<br></option>
<option value="13-4">&nbsp;&nbsp;&nbsp;13-4. 小测试</option>
<option value="13-5">&nbsp;&nbsp;&nbsp;13-5. BST高度的下限<br></option>
<option value="13-6">&nbsp;&nbsp;&nbsp;13-6. 下限的推导</option>
<option value="13-7">&nbsp;&nbsp;&nbsp;13-7. BST高度的上限<br></option>
<option value="13-8">&nbsp;&nbsp;&nbsp;13-8. 答案 <br></option>
<option value="13-9">&nbsp;&nbsp;&nbsp;13-9. 联合约束<br></option>
<option value="14">14. AVL 树</option>
<option value="14-1">&nbsp;&nbsp;&nbsp;14-1. 步骤1：有效维持高度（v）<br></option>
<option value="14-2">&nbsp;&nbsp;&nbsp;14-2. 第2步：定义AVL树不变量</option>
<option value="14-3">&nbsp;&nbsp;&nbsp;14-3. Proof - 1</option>
<option value="14-4">&nbsp;&nbsp;&nbsp;14-4. 证明 - 2</option>
<option value="14-5">&nbsp;&nbsp;&nbsp;14-5. 证明 - 3</option>
<option value="14-6">&nbsp;&nbsp;&nbsp;14-6. 证明 - 4</option>
<option value="14-7">&nbsp;&nbsp;&nbsp;14-7. 第3步：保持不变性</option>
<option value="14-8">&nbsp;&nbsp;&nbsp;14-8. 介绍旋转树</option>
<option value="14-9">&nbsp;&nbsp;&nbsp;14-9. 非平凡的O（1）树旋转的伪码</option>
<option value="14-10">&nbsp;&nbsp;&nbsp;14-10. 四个重新平衡案例</option>
<option value="14-11">&nbsp;&nbsp;&nbsp;14-11. 在AVL树中插入（v）</option>
<option value="14-12">&nbsp;&nbsp;&nbsp;14-12. 答案<br></option>
<option value="14-13">&nbsp;&nbsp;&nbsp;14-13. 在AVL树中删除（v）</option>
<option value="14-14">&nbsp;&nbsp;&nbsp;14-14. AVL树摘要</option>
<option value="15">15. 附加功能</option>
<option value="15-1">&nbsp;&nbsp;&nbsp;15-1. 那2个额外的BST操作</option>
<option value="15-2">&nbsp;&nbsp;&nbsp;15-2. Side Usage of Balanced BST?</option>
<option value="15-3">&nbsp;&nbsp;&nbsp;15-3. 在线测验</option>
<option value="15-4">&nbsp;&nbsp;&nbsp;15-4. 在线评测练习</option>
<option value="15-5">&nbsp;&nbsp;&nbsp;15-5. 答案</option>
<option value="99">99. 状态面板</option>
<option value="99-1">&nbsp;&nbsp;&nbsp;99-1. 代码追踪面板</option>
<option value="99-2">&nbsp;&nbsp;&nbsp;99-2. 媒体控制</option>
<option value="99-3">&nbsp;&nbsp;&nbsp;99-3. 返回 ”探索模式“</option>
</select>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-next' data-nextid="2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-2" class="electure-dialog" style="top:60px;left:280px;width:500px;">
<p>To toggle between the standard Binary Search Tree and the AVL Tree (only different behavior during Insertion and Removal of an Integer), select the respective header.</p><br><p>We also have URL shortcut to quickly access the AVL Tree mode, which is <a href="./bst?mode=AVL"><u>en/avl</u></a> (you can change the &#39;en&#39; to your two characters preferred language - if available).</p>
<hr>
<p>Pro-tip: Since you are not <a href="login"><u>logged-in</u></a>, you may be a first time visitor who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b> to advance to the next slide, <b>[PageUp]</b> to go back to the previous slide, <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>BST (and especially balanced BST like AVL Tree) is an efficient data structure to implement <i>a certain kind</i> of <b>Table</b> (or <b>Map</b>) Abstract Data Type (ADT).</p><br><p>A Table ADT must support <b>at least</b> the following three operations as efficient as possible:</p><ol><li>Search(v) — determine if <b>v</b> exists in the ADT or not,</li><li>Insert(v) — insert <b>v</b> into the ADT,</li><li>Remove(v) — remove <b>v</b> from the ADT.</li></ol><hr><p>Reference: See <a href="en/hashtable?slide=2-1" target="_blank"><u>similar slide in Hash Table e-Lecture</u></a>.</p>
<hr>
<p>Another pro-tip: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2017). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
我们指的是表格（Table）ADT，其中需要对键进行排序（与表ADT相反，其中键不需要是无序的）。<br>表格ADT的这一特殊要求将在接下来的几张幻灯片中更加清晰。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
如果我们使用未排序的数组/向量来实现表ADT，它可能效率低下：<br><ol><li>搜索（v）在<span style="white-space: normal;">O(</span><b style="white-space: normal;">N</b><span style="white-space: normal;">)</span>中运行，因为如果v实际上不存在，我们最终可能会探索ADT的所有N个元素，<br></li><li>插入（v）可以在<span style="white-space: normal;">O(</span><b style="white-space: normal;">1</b><span style="white-space: normal;">)</span>中实现，只需将v放在数组的后面，<br></li><li>删除（v）也在<span style="white-space: normal;">O(</span><b style="white-space: normal;">N</b><span style="white-space: normal;">)</span>中运行，因为我们必须首先搜索已经O(<b style="white-space: normal;">N</b><span style="white-space: normal;">)</span>的v，然后在删除后关闭产生的间隙 - 也在<span style="white-space: normal;">O(</span><b style="white-space: normal;">N</b><span style="white-space: normal;">)</span>中。<br></li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
如果我们使用排序的数组/向量来实现表ADT，我们可以提高搜索（v）性能，但会削弱插入（v）性能：<br><ol><li>搜索（v）现在可以在<span style="white-space: normal;">O(log&nbsp;</span><b style="white-space: normal;">N</b><span style="white-space: normal;">),</span>中实现，因为我们现在可以在已排序的数组上使用二进制搜索，<br></li><li>插入（v）现在在<span style="white-space: normal;">O(</span><b style="white-space: normal;">N</b><span style="white-space: normal;">)</span>中运行，因为我们需要实现类似插入的策略以使数组保持排序状态，<br></li><li>删除（v）在<span style="white-space: normal;">O(</span><b style="white-space: normal;">N</b><span style="white-space: normal;">)</span>中运行，因为即使<span style="white-space: normal;">&nbsp;Search(v)&nbsp;</span>在<span style="white-space: normal;">O(log&nbsp;</span><b style="white-space: normal;">N</b><span style="white-space: normal;">)</span>中运行，我们仍然需要在删除后关闭间隙 - 在O（N）中。<br></li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-4">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>此e-Lecture的目标是引入BST然后平衡BST（AVL树）数据结构，以便我们可以实现基本的表ADT操作：搜索（v），插入（v），删除（v）和一些 其他Table ADT操作 - 参见下一张幻灯片 - 在O（log N）时间内 - 远小于N.<br>PS：一些经验丰富的读者可能会注意到<a href="hashtable?slide=11-4"><u>另一种数据结构</u></a> <span style="white-space: normal;">∃&nbsp;</span>可以在更快的时间内实现三种基本的表ADT操作，但请继续阅读......</p><br><table style="width: 100%; border: 1px solid white"><tbody><tr><td><b>N</b></td><td>≈ 1 000</td><td>≈ 1 000 000</td><td>≈ 1 000 000 000</td></tr><tr><td>log <b>N</b></td><td>10</td><td>Only 20 :O</td><td>Only 30 :O:O</td></tr></tbody></table>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-3">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-5">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>On top of the basic three, there are a few other possible Table ADT operations:</p><ol><li>Find the Min()/Max() element,</li><li>Find the Successor(v) &mdash; &#39;next larger&#39;/Predecessor(v) &mdash; &#39;previous smaller&#39; element,</li><li>List elements in sorted order,</li><li>Operation X &amp; Y - hidden for pedagogical purpose in an NUS module,</li><li>There are others possible operations.</li></ol><p>Discussion: What are the best possible implementation for the first three additional operations if we are limited to use [sorted|unsorted] array/vector?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-4">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-6">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-6" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-5">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-7">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-7" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>可用于实现表ADT的更简单的数据结构是<a href="./list"><u>链接列表</u></a>。<br><span style="white-space: normal;"><input class="mcq-answer" id="mcq-answer-16" value="70" hidden><p>Quiz: <b>Can we perform all basic three Table ADT operations: Search(v)/Insert(v)/Remove(v) efficiently (read: faster than O(<b>N</b>)) using Linked List?</b></p><form><input type="radio" name="mcq-16-choice" value="69"> Yes<br><input type="radio" name="mcq-16-choice" value="70"> No<br></form><button class="mcq-submit" id="submit-16">Submit</button> <span id="answer-status-16"></span></span><br>讨论：为什么？<br></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-6">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-8">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-8" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-7">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-9">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-9" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>可用于实现表ADT的另一种数据结构是哈希表。 它具有非常快的搜索（v），插入（v）和删除（v）性能（所有都在预期的<span style="white-space: normal;">O(</span><b style="white-space: normal;">1</b><span style="white-space: normal;">)&nbsp;</span>时间内）。<br><span style="white-space: normal;"><input class="mcq-answer" id="mcq-answer-17" value="72" hidden><p>Quiz: <b>So what is the point of learning this BST module if Hash Table can do the crucial Table ADT operations in unlikely-to-be-beaten expected O(<b>1</b>) time?</b></p><form><input type="radio" name="mcq-17-choice" value="72"> There are valid reasons, which are ____<br><input type="radio" name="mcq-17-choice" value="71"> There is no point, so this BST module can be ignored<br></form><button class="mcq-submit" id="submit-17">Submit</button> <span id="answer-status-17"></span></span><br>讨论上面的答案！ 提示：回到之前的4张幻灯片。<br></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-8">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-10">下一个 <u>PgDn</u></div>
</div>
<div id="electure-3-10" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-9">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="4">下一个 <u>PgDn</u></div>
</div>
<div id="electure-4" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>We will now introduce BST data structure. See the visualization of an example BST above!</p><br><p>Root vertex does not have a parent. There can only be one root vertex in a BST. Leaf vertex does not have any child. There can be more than one leaf vertex in a BST. Vertices that are not leaf are called the internal vertices. Sometimes root vertex is not included as part of the definition of internal vertex as the root of a BST with only one vertex can actually fit into the definition of a leaf too.</p><br><p>In the example above, vertex 15 is the root vertex, vertex {5, 7, 50} are the leaves, vertex {4, 6, 15 (also the root), 23, 71} are the internal vertices.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-10">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-4-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
每个顶点<b>至少</b>有4个属性：父，左，右，键/值/数据（还有其他潜在的属性）。 并非所有属性都将用于所有顶点，例如 根顶点的父属性为NULL。 一些其他实现将键（用于BST中的顶点的排序）和与键相关联的实际卫星数据分开。<br>顶点（叶子除外）的左/右子节点分别绘制在该顶点的左/右下方。 顶点的父节点（根除外）绘制在该顶点上方。 每个顶点的（整数）键在表示该顶点的圆内绘制。 在上面的例子中，（键）15的左子为6，右子为23。 因此，6（和23）的父母是15。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-4-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
由于我们在此可视化中不允许重复整数，因此BST属性如下所示：对于每个顶点X，X的左子树上的所有顶点都严格小于X，并且右子树X上的所有顶点都严格大于X。<br>在上面的示例中，根15的左子树上的顶点：{4,5,6,7}都小于15，根15的右子树上的顶点：{23,50,71}是 全部大于15.您也可以递归检查其他顶点上的BST属性。<br>为了更完整的实现，我们也应该考虑重复的整数，并且我们必须始终将等于X的整数放在一个子树上（不是任意的）。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="5">下一个 <u>PgDn</u></div>
</div>
<div id="electure-5" class="electure-dialog" style="bottom:240px;left:60px;width:500px;">
我们为以下常见的BST / AVL树操作提供可视化：<br><ol><li>.查询操作（BST结构保持不变）：</li></ol> 1. 搜索（v）<br> 2. 前身（v）（和类似的继承人（v）），和<br> 3. Inorder Traversal（我们将很快添加Preorder和Postorder Traversal），<div> 2. 更新操作（BST结构可能会改变）：</div><div> 1.插入（v）</div><div> 2.删除（v），</div><div> 3.创建BST（几个标准）。</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-5-1" class="electure-dialog" style="bottom:240px;left:60px;width:500px;">
<p>There are a few other BST (Query) operations that have not been visualized in VisuAlgo:</p><ol><li>Rank(v): Given a key <b>v</b>, determine what is its rank (1-based index) in the sorted order of the BST elements. That is, Rank(FindMin()) = 1 and Rank(FindMax()) = <b>N</b>. If <b>v</b> does not exist, we can report -1.</li><li>Select(k): Given a rank <b>k</b>, 1 ≤ <b>k</b> ≤ <b>N</b>, determine the key <b>v</b> that has that rank <b>k</b> in the BST. Or in another word, find the <b>k</b>-th smallest element in the BST. That is, Select(1) = FindMin() and Select(<b>N</b>) = FindMax().</li></ol><p>The details of these two operations are currently hidden for pedagogical purpose in a certain NUS module.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-5-2" class="electure-dialog" style="bottom:240px;left:60px;width:500px;">
只有在没有（或罕见）更新时才有效的数据结构，尤其是插入和/或删除操作，称为静态数据结构。<br>即使存在许多更新操作，高效的数据结构也称为动态数据结构。 BST，尤其是平衡的BST（例如AVL树）就属于这一类。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="6">下一个 <u>PgDn</u></div>
</div>
<div id="electure-6" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Because of the way data (distinct integers for this visualization) is organised inside a BST, we can <b>binary</b> search for an integer <b>v</b> efficiently (hence the name of <b>Binary Search</b> Tree).</p><br><p>First, we set the current vertex = root and then check if the current vertex is smaller/equal/larger than integer <b>v</b> that we are searching for. We then go to the right subtree/stop/go the left subtree, respectively. We keep doing this until we either find the required vertex or we don&#39;t.</p><br><p>On the example BST above, try clicking <span class="slide-actions" onclick="doButtonAction2()">Search(15)</span> (found after just 1 comparison), <span class="slide-actions" onclick="doButtonAction1()">Search(7)</span> (found after 3 comparisons), <span class="slide-actions" onclick="doButtonAction3()">Search(21)</span> (not found after 3 comparisons).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="6-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-6-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
类似地，由于数据在BST内的组织方式，我们可以从root开始找到最小/最大元素（此可视化中的整数），并分别继续向左/右子树寻找。<br>尝试点击上面显示的示例BST上的<span class="slide-actions" onclick="doButtonAction52()">FindMin()</span>和<span class="slide-actions" onclick="doButtonAction53()">FindMax()</span>。 答案应该是4和71（均在4次比较后）。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="6-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-6-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
Search（v）/ FindMin（）/ FindMax（）操作在O（h）中运行，其中h是BST的高度。<br>但请注意，这个h可以和普通BST中的O（N）一样高，如上面随机的“向右倾斜”示例所示。 尝试<span class="slide-actions" onclick="doButtonAction5()">Search(100)</span>（这个值不应该存在，因为我们只使用[1..99]之间的随机整数生成这个随机BST，因此搜索例程应该检查从根到O（N）时间内唯一的叶子 - 没有效率。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="7">下一个 <u>PgDn</u></div>
</div>
<div id="electure-7" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
由于BST属性，我们可以找到整数 <b>v </b>的后继（假设我们已经知道整数 <b>v </b>在早期的 Search(<b>v</b>)调用中的位置），如下所示：<br><ol><li>如果 <b>v </b>具有右子树，则 <b>v</b> 的右子树中的最小整数必须是 <b>v </b>的后继。尝试<span class="slide-actions" onclick="doButtonAction6()">Successor(23)</span>（应为50）。<br></li><li>如果 <b>v </b>没有右子树，我们需要遍历 <b>v </b>的祖先，直到我们找到&#39;右转&#39;到顶点 <b>w</b>（或者，直到我们发现第一个顶点 <b>w </b>大于顶点 <b>v</b>）。 一旦我们找到顶点 <b>w</b>，我们将看到顶点 <b>v </b>是 <b>w </b>的左子树中的最大元素。 试试<span class="slide-actions" onclick="doButtonAction54()">Successor(7)</span>（应该是15）。<br></li><li>如果 <b>v </b>是BST中的最大整数，则 <b>v </b>没有后继。 试试<span class="slide-actions" onclick="doButtonAction55()">Successor(71)</span>（应该没有）。<br></li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-7-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
整数v的前驱的操作类似地定义（只是后继操作的镜像）。<br>尝试相同的三个角落（但镜像）：<span class="slide-actions" onclick="doButtonAction56()">Predecessor(6)</span>（应为5），<span class="slide-actions" onclick="doButtonAction57()">Predecessor(50)</span>（应为23），<span class="slide-actions" onclick="doButtonAction58()">Predecessor(4)</span>（应为无）。<br>此时，请暂停一会并思考这三个后继（v）/ 前驱（v）案例，以确保您理解这些概念。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-7-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
前驱（v）和后继（v）操作在O（h）中运行，其中h是BST的高度。<br>但请记住，这个h可以和正常BST中的O（N）一样高，如上面的随机“倾斜右侧”示例所示。 如果我们调用<span class="slide-actions" onclick="doButtonAction64()">Successor(FindMax())</span>，我们将在O（N）时间从最后一个叶子回到根目录 - 效率不高。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="8">下一个 <u>PgDn</u></div>
</div>
<div id="electure-8" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>We can perform an <b>Inorder Traversal</b> of this BST to obtain a list of sorted integers inside this BST (in fact, if we &#39;flatten&#39; the BST into one line, we will see that the vertices are ordered from smallest/leftmost to largest/rightmost).</p><br><p>Inorder Traversal is a recursive method whereby we visit the left subtree first, exhausts all items in the left subtree, visit the current root, before exploring the right subtree and all items in the right subtree. Without further ado, let&#39;s try <span class="slide-actions" onclick="doButtonAction59()">Inorder Traversal</span> to see it in action on the example BST above.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="8-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-8-1" class="electure-dialog" style="top:300px;left:50%;margin-left:-250px;width:500px;">
<p>无论BST的高度如何，Inorder Traversal都以O（N）运行。<br>讨论：为什么？<br>PS：有些人调用N个无序整数插入O（N log N）中的BST，然后执行O（N）Inorder Traversal作为&#39;BST sort&#39;。 它很少使用，因为有几种比这更容易使用（基于比较）的<a href="./sorting"><u>排序算法</u></a>。<br></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="8">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="8-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-8-2" class="electure-dialog" style="top:300px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="8-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="8-3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-8-3" class="electure-dialog" style="top:300px;left:50%;margin-left:-250px;width:500px;">
我们还没有包含这两种其他经典树遍历方法的动画，但我们很快就会这样做。<br>但基本上，在Preorder Traversal中，我们在转到左子树然后右子树之前访问当前根。 对于后台显示的示例BST，我们有：{{15}，{6,4,5,7}，{23,71,50}}。 PS：你注意到了递归模式吗？ root，root的左子树成员，root的右子树成员。<br>在Postorder Traversal中，我们在访问当前根之前首先访问左子树和右子树。 对于后台显示的示例BST，我们有：{{5,4,7,6}，{50,71,23}，{15}}。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="8-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="9">下一个 <u>PgDn</u></div>
</div>
<div id="electure-9" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>We can insert a new integer into BST by doing similar operation as <b>Search(v)</b>. But this time, instead of reporting that the new integer is not found, we create a new vertex in the insertion point and put the new integer there. Try <span class="slide-actions" onclick="doButtonAction60()">Insert(60)</span> on the example above.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="8-3">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-9-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<b>插入（v）</b>在O（h）中运行，其中h是BST的高度。<br>到目前为止你应该知道这个h可以和正常BST中的<span style="white-space: normal;">O(</span><b style="white-space: normal;">N</b><span style="white-space: normal;">)</span>一样高，如上面随机的“向右倾斜”示例所示。 如果我们调用<span class="slide-actions" onclick="doButtonAction65()">Insert(FindMax()+1)</span>，即我们插入一个大于当前最大值的新整数，我们将从根向下移动到最后一个叶子，然后在<span style="white-space: normal;">O(</span><b style="white-space: normal;">N</b><span style="white-space: normal;">)</span>时间内插入新整数作为最后一个叶子的右子节点 - 效率不高（请注意，在此可视化中我们只允许h = 9）。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-9-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<span style="white-space: normal;"><input class="mcq-answer" id="mcq-answer-20" value="88" hidden><p>Quiz: <b>Inserting integers [1,10,2,9,3,8,4,7,5,6] one by one in that order into an initially empty BST will result in a BST of height:</b></p><form><input type="radio" name="mcq-20-choice" value="88"> 9<br><input type="radio" name="mcq-20-choice" value="89"> 8<br><input type="radio" name="mcq-20-choice" value="87"> 10<br><input type="radio" name="mcq-20-choice" value="90"> The height cannot be determined<br></form><button class="mcq-submit" id="submit-20">Submit</button> <span id="answer-status-20"></span></span><br>专业提示：您可以使用“探索模式”来验证答案。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="10">下一个 <u>PgDn</u></div>
</div>
<div id="electure-10" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
我们可以通过执行与 <b>Search(v) </b>类似的操作来删除BST中的整数。<br>如果在BST中找不到 <b>v</b>，我们什么都不做。<br>如果在BST中找到 <b>v</b>，我们不会报告找到现有的整数<b>v</b>，而是执行三个可能的删除案例中的一个，这些案例将在三个单独的幻灯片中详细说明（我们建议您一个一个的尝试每个幻灯片）。<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="10-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-10-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>The first case is the easiest: Vertex <b>v</b> is currently one of the leaf vertex of the BST.</p><br><p>Deletion of a leaf vertex is very easy: We just remove that leaf vertex &mdash; try <span class="slide-actions" onclick="doButtonAction61()">Remove(5)</span> on the example BST above (second click onwards after the first removal will do nothing &mdash; please refresh this page or go to another slide and return to this slide instead).</p><br><p>This part is clearly O(<b>1</b>) &mdash; on top of the earlier O(<b>h</b>) search-like effort.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="10-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-10-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>The second case is also not that hard: Vertex <b>v</b> is an (internal/root) vertex of the BST and it has <b>exactly one child</b>. Removing <b>v</b> without doing anything else will disconnect the BST.</p><br><p>Deletion of a vertex with one child is not that hard: We connect that vertex&#39;s only child with that vertex&#39;s parent &mdash; try <span class="slide-actions" onclick="doButtonAction62()">Remove(23)</span> on the example BST above (second click onwards after the first removal will do nothing &mdash; please refresh this page or go to another slide and return to this slide instead).</p><br><p>This part is also clearly O(<b>1</b>) &mdash; on top of the earlier O(<b>h</b>) search-like effort.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="10-3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-10-3" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>The third case is the most complex among the three: Vertex <b>v</b> is an (internal/root) vertex of the BST and it has <b>exactly two children</b>. Removing <b>v</b> without doing anything else will disconnect the BST.</p><br><p>Deletion of a vertex with two children is as follow: We replace that vertex with its successor, and then delete its duplicated successor in its right subtree &mdash; try <span class="slide-actions" onclick="doButtonAction63()">Remove(6)</span> on the example BST above (second click onwards after the first removal will do nothing &mdash; please refresh this page or go to another slide and return to this slide instead).</p><br><p>This part requires O(<b>h</b>) due to the need to find the successor vertex &mdash; on top of the earlier O(<b>h</b>) search-like effort.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="10-4">下一个 <u>PgDn</u></div>
</div>
<div id="electure-10-4" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>本案例3值得进一步讨论：</p><ol><li>为什么用后继C替换有两个子节点的顶点B总是一个有效的策略？<br></li><li>我们可以用它的前身A替换有两个子节点的顶点B吗？ 为什么或者为什么不？<br></li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10-3">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="10-5">下一个 <u>PgDn</u></div>
</div>
<div id="electure-10-5" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10-4">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="10-6">下一个 <u>PgDn</u></div>
</div>
<div id="electure-10-6" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p><b>Remove(v)</b> runs in O(<b>h</b>) where <b>h</b> is the height of the BST. Removal case 3 (deletion of a vertex with two children is the &#39;heaviest&#39; but it is not more than O(<b>h</b>)).</p><br><p>As you should have fully understand by now, <b>h</b> can be as tall as O(<b>N</b>) in a normal BST as shown in the random &#39;skewed right&#39; example above. If we call <span class="slide-actions" onclick="doButtonAction66()">Remove(FindMax())</span>, i.e. we remove the current max integer, we will go from root down to the last leaf in O(<b>N</b>) time before removing it &mdash; not efficient.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10-5">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="11">下一个 <u>PgDn</u></div>
</div>
<div id="electure-11" class="electure-dialog" style="bottom:260px;left:60px;width:500px;">
<div>为了在“探索模式”中使生活更轻松，您可以使用以下选项创建新的BST：<b><br></b><br><ol style=""><li style=""><b>空</b>BST（然后你可以逐个插入几个整数），<br></li><li style="">你可能已经看过几次的<b>两个电子讲座例子</b>，<br></li><li style=""><b>随机</b>BST（不太可能非常高），<br></li><li style=""><b>向左/向右倾斜</b>BST（具有N个顶点的高BST和具有N-1个链接列表的边缘，以展示BST操作的最坏情况行为;在AVL树模式中禁用）。<b><br></b></li></ol></div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10-6">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="12">下一个 <u>PgDn</u></div>
</div>
<div id="electure-12" class="electure-dialog" style="top:100px;right:60px;width:500px;">
<p>我们正在解释这个BST模块。 到目前为止，我们注意到许多基本的表格ADT操作在O（h）中运行，而h可以像N-1边缘一样高，就像所示的“向左倾斜”一样 - 效率低下:( ...<br>那么，有没有办法让我们的BST“不那么高”？<br></p><hr><p>PS：如果你想研究如何在真实程序中实现这些基本的BST操作，你可以下载这个<a href="http://www.comp.nus.edu.sg/~stevenha/cs2040c/demos/BSTDemo.cpp" target="_blank"><u>BSTDemo.cpp</u></a>。<br></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="11">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="12-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-12-1" class="electure-dialog" style="top:100px;right:60px;width:500px;">
<p>此时，我们建议您按[Esc]或单击此e-Lecture幻灯片右下角的X按钮进入“探索模式”并自行尝试各种BST操作，以加强您对这种多功能数据结构的理解。<br>当您准备继续解释平衡BST（我们使用AVL树作为示例）时，再次按[Esc]或从右上角的下拉菜单中将模式切换回“电子演讲模式”。 然后，使用幻灯片选择器下拉列表<a href="./bst?slide=12-1"><u>this slide 12-1</u></a>恢复。<br></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="12">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="13">下一个 <u>PgDn</u></div>
</div>
<div id="electure-13" class="electure-dialog" style="top:60px;left:60px;width:500px;">
我们从早期幻灯片中看到，除了中序遍历之外，我们的大部分BST操作都在O（h）中运行，其中h是BST的高度，可以与<b>N-1</b>一样高。<br>我们将继续讨论<b>平衡BST</b>的概念，以便h = O（log <b>N</b>）。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="12-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-13-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
有几种已知的平衡BST的实现，但是太多了不能在VisuAlgo中逐一可视化和解释。<br>我们专注于AVL Tree（Adelson-Velskii＆Landis，1962），以其发明者Adelson-Velskii和Landis命名。<br>其他平衡的BST实现（在恒定因子性能方面或多或少好或略好）是：红黑树，B树/ 2-3-4树（Bayer＆McCreight，1972），Splay树（Sleator 和Tarjan，1985），Skip Lists（Pugh，1989），Treaps（ Seidel和Aragon，1996）等。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-13-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
为了促进AVL Tree的实现，我们需要<b>增加</b> - 为每个BST顶点添加更多信息/属性。<br>对于每个顶点v，我们定义<b>height（v）</b>：从顶点v到其最深叶子的路径上的边数。 此属性保存在每个顶点中，因此我们可以在O（1）中访问顶点的高度，而无需每次都重新计算它。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-13-3" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>先前是:</p><pre>v.height = -1 (if v is an empty tree)<br>v.height = max(v.left.height, v.right.height) + 1 (otherwise)</pre>因此，BST的高度是: <samp>root.height</samp>.<br><p>在上面的例子BST上, height(11) = height(32) = height(50) = height(72) = height(99) = 0 (所有都是叶子). height(29) = 1因为有1个边缘将它连接到它唯一的叶子32上。</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-4">下一个 <u>PgDn</u></div>
</div>
<div id="electure-13-4" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<input class="msq-answer" id="msq-answer-18" value="73,75,77" hidden><p>Quiz: <b>What are the values of height(20), height(65), and height(41) on the BST above?</b></p><input type="checkbox" class="msq-choice" id="msq-18-choice-73"> height(41) = 3<br><input type="checkbox" class="msq-choice" id="msq-18-choice-76"> height(65) = 3<br><input type="checkbox" class="msq-choice" id="msq-18-choice-78"> height(20) = 3<br><input type="checkbox" class="msq-choice" id="msq-18-choice-74"> height(41) = 4<br><input type="checkbox" class="msq-choice" id="msq-18-choice-75"> height(65) = 2<br><input type="checkbox" class="msq-choice" id="msq-18-choice-77"> height(20) = 2<br><button class="msq-submit" id="submit-18">Submit</button> <span id="answer-status-18"></span>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-3">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-5">下一个 <u>PgDn</u></div>
</div>
<div id="electure-13-5" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>If we have <b>N</b> elements/items/keys in our BST, the lower bound height <b>h</b> &gt; log<sub>2</sub> <b>N</b> if we can somehow insert the <b>N</b> elements in perfect order so that the BST is perfectly balanced.</p><br><p>See the example shown above for <b>N = 15</b> (a perfect BST which is rarely achievable in real life &mdash; try inserting any other integer and it will not be perfect anymore).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-4">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-6">下一个 <u>PgDn</u></div>
</div>
<div id="electure-13-6" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<pre>N ≤ 1 + 2 + 4 + ... + 2<sup>h</sup><br>N ≤ 2<sup>0</sup> + 2<sup>1</sup> + 2<sup>2</sup> + … + 2<sup>h</sup><br>N &lt; 2<sup>h+1</sup> (几何级数之和)<br>log<sub>2</sub> N &lt; log<sub>2</sub> 2<sup>h+1</sup><br>log<sub>2</sub> N &lt; (h+1) * log<sub>2</sub> 2 (log<sub>2</sub> 2 is 1)<br>h &gt; (log<sub>2</sub> N)-1 (代数操作)<br>h &gt; log<sub>2</sub> N</pre>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-5">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-7">下一个 <u>PgDn</u></div>
</div>
<div id="electure-13-7" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>If we have <b>N</b> elements/items/keys in our BST, the upper bound height <b>h</b> &lt; <b>N</b> if we insert the elements in ascending order (to get skewed right BST as shown above).</p><br><p>The height of such BST is <samp>h = N-1</samp>, so we have <samp>h &lt; N</samp>.</p><br><p>Discussion: Do you know how to get skewed left BST instead?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-6">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-8">下一个 <u>PgDn</u></div>
</div>
<div id="electure-13-8" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-7">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-9">下一个 <u>PgDn</u></div>
</div>
<div id="electure-13-9" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>We have seen that most BST operations are in O(<b>h</b>) and combining the lower and upper bounds of <b>h</b>, we have log<sub>2</sub> <b>N</b> &lt; <b>h</b> &lt; <b>N</b>.</p><br><p>There is a dramatic difference between log<sub>2</sub> <b>N</b> and <b>N</b> and we have seen from the discussion of the lower bound that getting perfect BST (at all times) is near impossible...</p><br><p>So can we have BST that has height closer to log<sub>2</sub> <b>N</b>, i.e. <b>c</b> * log<sub>2</sub> <b>N</b>, for a small constant factor <b>c</b>? If we can, then BST operations that run in O(<b>h</b>) actually run in O(log <b>N</b>)...</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-8">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<p>Introducing AVL Tree, invented by two Russian (Soviet) inventors: Georgy Adelson-Velskii and Evgenii Landis, back in 1962.</p><br><p>In AVL Tree, we will later see that its height <b>h</b> &lt; 2 * log <b>N</b> (tighter analysis exist, but we will use easier analysis in VisuAlgo where <b>c = 2</b>). Therefore, most AVL Tree operations run in O(log <b>N</b>) time &mdash; efficient.</p><br><p>Insert(v) and Remove(v) update operations may change the height <b>h</b> of the AVL Tree, but we will see <b>rotation</b> operation(s) to maintain the AVL Tree height to be low.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-9">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-1" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<p>To have efficient performance, we shall not maintain <b>height(v)</b> attribute via the O(<b>N</b>) recursive method every time there is an update (Insert(v)/Remove(v)) operation.</p><br><p>Instead, we compute O(<b>1</b>): <samp>x.height = max(x.left.height, x.right.height) + 1</samp> at the back of our Insert(v)/Remove(v) operation as only the height of vertices along the insertion/removal path may be affected. Thus, only O(<b>h</b>) vertices may change its <b>height(v)</b> attribute and in AVL Tree, <b>h</b> &lt; 2 * log <b>N</b>.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction69()">Insert(37)</span> on the example AVL Tree (ignore the resulting rotation for now, we will come back to it in the next few slides). Notice that only a few vertices along the insertion path: {41,20,29,32} increases their height by +1 and all other vertices will have their heights unchanged.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-2" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
让我们定义以下重要的AVL树不变量（永不改变的属性）：如果| v.left.height - v.right.height |，则顶点<b>v</b>被称为<b>高度平衡</b>。 ≤1。<br>如果BST中的每个顶点都是高度平衡的，则根据上面的不变量将BST称为高度平衡。 这样的BST称为AVL Tree，就像上面的例子一样。<br>花点时间在这里暂停一会，并尝试插入一些新的随机顶点或删除一些随机存在的顶点。 生成的BST是否仍然被认为是高度平衡的？
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-3" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<p>Adelson-Velskii and Landis claim that an AVL Tree (a height-balanced BST that satisfies AVL Tree invariant) with <b>N</b> vertices has height <b>h</b> &lt; 2 * log<sub>2</sub> <b>N</b>.</p><br><p>The proof relies on the concept of minimum-size AVL Tree of a certain height <b>h</b>.</p><br><p>Let <b>N<sub>h</sub></b> be the minimum number of vertices in a height-balanced AVL Tree of height <b>h</b>.</p><br><p>The first few values of <b>N<sub>h</sub></b> are <b>N<sub>0</sub> = 1</b> (a single root vertex), <b>N<sub>1</sub> = 2</b> (a root vertex with either one left child or one right child only), <b>N<sub>2</sub> = 4</b>, <b>N<sub>3</sub> = 7</b>, <b>N<sub>4</sub> = 12</b>, <b>N<sub>5</sub> = 20</b> (see the background picture), and so on (see the next two slides).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-4">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-4" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<p>我们知道，对于 <b>N </b>个顶点的任何其他AVL树（不一定是最小尺寸的顶点），<b>N ≥ N<sub>h</sub></b>。</p><img src="../img/bst_min_avl1.png" alt="Proof-2"><p>在背景图片中，我们有<b>N<sub>5</sub> = 20</b>个顶点，但我们知道在我们有一个高度为<b>h = 5</b>的完美二叉树之前，我们可以再挤压43个顶点（最多<b>N = 63</b>）。<br></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-3">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-5">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-5" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<pre>N<sub>h</sub> = 1 + N<sub>h-1</sub> + N<sub>h-2</sub> (高度为h的最小尺寸AVL树的公式)<br>N<sub>h</sub> &gt; 1 + 2*N<sub>h-2</sub> (as N<sub>h-1</sub> &gt; N<sub>h-2</sub>)<br>N<sub>h</sub> &gt; 2*N<sub>h-2</sub> (obviously)<br>N<sub>h</sub> &gt; 4*N<sub>h-4</sub> (递归)<br>N<sub>h</sub> &gt; 8*N<sub>h-6</sub> (另一个递归步骤)<br>... (假设初始h是偶数，我们只能这样做h/2次)<br>N<sub>h</sub> &gt; 2<sup>h/2</sup>*N<sub>0</sub> (我们到了base case)<br>N<sub>h</sub> &gt; 2<sup>h/2</sup> (as N<sub>0</sub> = 1)</pre><img style="width: 100%" src="img/bst_min_avl2.png" alt="Proof-3">
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-4">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-6">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-6" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<pre>N ≥ N<sub>h</sub> &gt; 2<sup>h/2</sup> (结合前两张幻灯片)<br>N &gt; 2<sup>h/2</sup><br>log<sub>2</sub>(N) &gt; log<sub>2</sub>(2<sup>h/2</sup>) (两张幻灯片都是log<sub>2</sub> )<br>log<sub>2</sub>(N) &gt; h/2 (等式化简)<br>2 * log<sub>2</sub>(N) &gt; h or h &lt; 2 * log<sub>2</sub>(N)<br>h = O(log(N)) (最后结论)</pre><img src="../img/bst_min_avl3.png" alt="Proof-4">
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-5">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-7">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-7" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<p>Look at the example BST again. See that all vertices are height-balanced, an AVL Tree.</p><br><p>To quickly detect if a vertex <b>v</b> is height balanced or not, we modify the AVL Tree invariant (that has absolute function inside) into: <samp>bf(v) = v.left.height - v.right.height</samp>.</p><br><p>Now try <span class="slide-actions" onclick="doButtonAction69()">Insert(37)</span> on the example AVL Tree again. A few vertices along the insertion path: {41,20,29,32} increases their height by +1. Vertices {29,20} will no longer be height-balanced after this insertion (and will be rotated later &mdash; discussed in the next few slides), i.e. bf(29) = -2 and bf(20) = -2 too. We need to restore the balance.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-6">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-8">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-8" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<img src="../img/tree_rotation.png" alt="Tree Rotation" width="500"><p>见上图。 在左侧图片上调用<b style="white-space: normal;">rotateRight(Q)</b><span style="white-space: normal;">&nbsp;</span>将生成正确的图片。 在右图上调用<b style="white-space: normal;">rotateLeft(P)</b>将再次产生左图。<br>只有当T有一个左/右子时，才能调用<b style="white-space: normal;">rotateRight(T)</b><span style="white-space: normal;">/</span><b style="white-space: normal;">rotateLeft(T)</b><span style="white-space: normal;">&nbsp;</span>。<br>Tree Rotation保留BST属性。 在旋转之前，P≤B≤Q。旋转之后，请注意以B为根的子树（如果存在）更改父级，但P≤B≤Q不会更改。<br></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-7">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-9">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-9" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<pre>BSTVertex rotateLeft(BSTVertex T) // pre-req: T.right != null<br>  BSTVertex w = T.right // rotateRight is the mirror copy of this<br>  w.parent = T.parent // this method is hard to get right for newbie<br>  T.parent = w<br>  T.right = w.left<br>  if (w.left != null) w.left.parent = T<br>  w.left = T<br>  // update the height of T and then w here<br>  return w</pre>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-8">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-10">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-10" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<img src="../img/four_cases.png" alt="Four Cases" width="500"><p>基本上，只有这四个不平衡的情况。 我们使用Tree Rotation(旋转树)来处理它们中的每一个。</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-9">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-11">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-11" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<ol><li>Just insert <b>v</b> as in normal BST,</li><li>Walk up the AVL Tree from the insertion point back to the root and at every step, we update the height and balance factor of the affected vertices:<ol type="a"><li>Stop at the <b>first</b> vertex that is out-of-balance (+2 or -2), if any,</li><li>Use <b>one</b> of the four tree rotation cases to rebalance it again, e.g. try <span class="slide-actions" onclick="doButtonAction69()">Insert(37)</span> on the example above and notice by calling <b>rotateLeft(29)</b> once, we fix the imbalance issue.</li></ol></li></ol><p>Discussion: Is there other tree rotation cases for Insert(v) operation of AVL Tree?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-10">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-12">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-12" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-11">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-13">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-13" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<ol><li>只需删除正常BST中的v（三个删除案例中的一个），<br></li><li>将AVL树从删除点向上移回根，每一步，我们都会更新受影响顶点的高度和平衡因子：<ol><li>现在，对于每个不平衡的顶点（+2或-2），我们使用四个树旋转情况中的一个来重新平衡它们（可能多于一个）。<br></li></ol></li></ol><p>与AVL树中的Insert（v）相比的主要区别在于，我们可能会多次触发四种可能的重新平衡情况中的一种，但不会超过<b>h</b> = O（log <b>N</b>）次：O，在上面的示例中尝试<span class="slide-actions" onclick="doButtonAction68()">Remove(7)</span> 看到两个连锁反应<b>rotateRight（6）</b>然后<b>rotateRight（16）+ rotateLeft（8）</b>组合。<br></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-12">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-14">下一个 <u>PgDn</u></div>
</div>
<div id="electure-14-14" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-13">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="15">下一个 <u>PgDn</u></div>
</div>
<div id="electure-15" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>We will end this module with a few more interesting things about BST and balanced BST (especially AVL Tree).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-14">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="15-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-15-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="15">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="15-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-15-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="15-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="15-3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-15-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>有关此数据结构的一些有趣的问题，请在<a href="training?diff=Medium&amp;n=7&amp;tl=0&amp;module=bst,avl"><u>BST/AVL</u></a>培训模块上练习（无需登录）。<br>但是，对于注册用户，您应该登录然后转到<a href="training"><u>主培训页面</u></a>以正式清除此模块，此类成就将记录在您的用户帐户中。<br></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="15-2">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="15-4">下一个 <u>PgDn</u></div>
</div>
<div id="electure-15-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>We also have a few programming problems that somewhat requires the usage of this <b>balanced</b> BST (like AVL Tree) data structure: <a href="https://open.kattis.com/problems/compoundwords" title="" target="_blank"><u>Kattis - compoundwords</u></a> and <a href="https://open.kattis.com/problems/baconeggsandspam" title="" target="_blank"><u>Kattis - baconeggsandspam</u></a>.</p><br><p>Try them to consolidate and improve your understanding about this data structure. You are allowed to use C++ STL map/set, Java TreeMap/TreeSet, or OCaml <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Map.html" target="_blank"><u>Map</u></a>/<a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Set.html" target="_blank"><u>Set</u></a> if that simplifies your implementation (Note that Python doesn&#39;t have built-in bBST implementation).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="15-3">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="15-5">下一个 <u>PgDn</u></div>
</div>
<div id="electure-15-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="15-4">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="99">下一个 <u>PgDn</u></div>
</div>
<div id="electure-99" class="electure-dialog" style="right:150px;bottom:335px;width:500px;">
当操作进行时，状态面板将会有每个步骤的描述。
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="15-5">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-1">下一个 <u>PgDn</u></div>
</div>
<div id="electure-99-1" class="electure-dialog" style="right:170px;bottom:275px;width:180px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-2">下一个 <u>PgDn</u></div>
</div>
<div id="electure-99-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-120px;width:260px;">
使用用户控件控制动画！可用的快捷键有：<div>空格键：绘制／停止／重绘</div><div>左／右箭头：上一步／下一步</div><div>-／+：减缓／增加速度</div><div><br></div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-1">上一个 <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-3">下一个 <u>PgDn</u></div>
</div>
<div id="electure-99-3" class="electure-dialog" style="top:70px;right:60px;width:300px;">
<p>Return to &#39;Exploration Mode&#39; to start exploring!</p><br><p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-2">上一个 <u>PgUp</u></div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>关闭</u></span>
</div>
<div id="actions" class="panel">
<p id="create">创建</p>
<p id="search">搜索(v)</p>
<p id="insert">插入(v)</p>
<p id="remove">移除(v)</p>
<p id="predsucc">前驱/后继(v)</p>
<p id="inorder" onclick="inorderTraversal()">中序遍历</p>
</div>
<div id="actions-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide actions panel" /></div>
<div id="actions-extras">
<div class="create action-menu-pullout">
<div id="create-empty" class="execAction new-menu-option coloured-menu-option" onClick="empty()"><p>清空</p></div>
<div id="create-example1" class="execAction new-menu-option coloured-menu-option" onClick="example(1)"><p>Unbalanced Example</p></div>
<div id="create-example2" class="execAction new-menu-option coloured-menu-option" onClick="example(2)"><p>Balanced Example</p></div>
<div id="create-random" class="execAction new-menu-option coloured-menu-option" onClick="random()"><p>随机</p></div>
<div id="create-skewed-left" class="execAction new-menu-option coloured-menu-option" onClick="skewed('left')"><p>向左偏斜</p></div>
<div id="create-skewed-right" class="execAction new-menu-option coloured-menu-option" onClick="skewed('right')"><p>向右偏斜</p></div>
<div id="create-err" class="err"></div>
</div>
<div class="search action-menu-pullout">
<div id="find-min" class="execAction new-menu-option coloured-menu-option" onClick="findMinMax(true)"><p>找到最小值</p></div>
<div id="find-max" class="execAction new-menu-option coloured-menu-option" onClick="findMinMax(false)"><p>找到最大值</p></div>
<div id="search-input" class="new-menu-option">v = <input type="number" id="v-search" title="Enter an Integer" autocomplete="off" min=0 max=99 value=7></div>
<div id="search-go" class="execAction coloured-menu-option" onclick="searchVertex()"><p>执行</p></div>
<div id="search-err" class="err"></div>
</div>
<div class="insert action-menu-pullout">
<div id="insert-input" class="new-menu-option">v = <input type="text" id="v-insert" title="Enter an Integer or comma-separated array of Integers" autocomplete="off" value="1,77"></div>
<div id="insert-go" class="execAction coloured-menu-option" onclick="insertVertex()"><p>执行</p></div>
<div id="insert-err" class="err"></div>
</div>
<div class="remove action-menu-pullout">
<div id="remove-input" class="new-menu-option">v = <input type="text" id="v-remove" title="Enter an Integer or comma-separated array of Integers" autocomplete="off" value="1,77"></div>
<div id="remove-go" class="execAction coloured-menu-option" onclick="removeVertex()"><p>执行</p></div>
<div id="remove-err" class="err"></div>
</div>
<div class="predsucc action-menu-pullout">
<div id="predsucc-input" class="new-menu-option">v = <input type="number" id="v-predsucc" title="Enter an Integer" autocomplete="off" min=0 max=99 value=15></div>
<div id="predsucc-pred-go" class="execAction coloured-menu-option" onclick="predsucc(true)"><p>找前驱</p></div>
<div id="predsucc-succ-go" class="execAction coloured-menu-option" onclick="predsucc(false)"><p>找后继</p></div>
<div id="predsucc-err" class="err"></div>
</div>
<div class="inorder action-menu-pullout"></div>
</div>
<div id="bottom-bar">
<a id="trigger-about">关于</a>
</div>
<div id="about" class="overlays">
<h4>关于</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo在2011年由Steven Halim博士概念化，作为一个工具，帮助他的学生更好地理解数据结构和算法，让他们自己和自己的步伐学习基础。<br>VisuAlgo包含许多高级算法，这些算法在Steven Halim博士的书（“竞争规划”，与他的兄弟Felix Halim博士合作）和其他书中讨论。今天，一些高级算法的可视化/动画只能在VisuAlgo中找到。<br>虽然专门为新加坡国立大学（NUS）学生采取各种数据结构和算法类（例如CS1010，CS1020，CS2010，CS2020，CS3230和CS3230），作为在线学习的倡导者，我们希望世界各地的好奇心发现这些可视化也很有用。<br>VisuAlgo不是从一开始就设计为在小触摸屏（例如智能手机）上工作良好，因为需要满足许多复杂的算法可视化，需要大量的像素和点击并拖动手势进行交互。一个令人尊敬的用户体验的最低屏幕分辨率为1024x768，并且只有着陆页相对适合移动设备。<br>VisuAlgo是一个正在进行的项目，更复杂的可视化仍在开发中。<br>最令人兴奋的发展是自动问题生成器和验证器（在线测验系统），允许学生测试他们的基本数据结构和算法的知识。这些问题是通过一些规则随机生成的，学生的答案会在提交给我们的评分服务器后立即自动分级。这个在线测验系统，当它被更多的世界各地的CS教师采用，应该技术上消除许多大学的典型计算机科学考试手动基本数据结构和算法问题。通过在通过在线测验时设置小（但非零）的重量，CS教练可以（显着地）增加他/她的学生掌握这些基本问题，因为学生具有几乎无限数量的可以立即被验证的训练问题他们参加在线测验。培训模式目前包含12个可视化模块的问题。我们将很快添加剩余的8个可视化模块，以便VisuAlgo中的每个可视化模块都有在线测验组件。<br>另一个积极的发展分支是VisuAlgo的国际化子项目。我们要为VisuAlgo系统中出现的所有英语文本准备一个CS术语的数据库。这是一个很大的任务，需要众包。一旦系统准备就绪，我们将邀请VisuAlgo游客贡献，特别是如果你不是英语母语者。目前，我们还以各种语言写了有关VisuAlgo的公共注释：<br>
<a href="https://weibo.com/p/230418436e9ee80102v4rk" target='_blank'><u>zh</u></a>, <a href='https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689' target='_blank'><u>id</u></a>, <a href="https://blog.naver.com/visualgo_nus" target='_blank'><u>kr</u></a>, <a href='https://www.facebook.com/groups/163215593699283/permalink/824003417620494/' target='_blank'><u>vn</u></a>, <a href='http://pantip.com/topic/32736343' target='_blank'><u>th</u></a>.</p>
</div>
</div>

<script src="../js/jquery-3.3.1.min.js"></script>
<script>
      var PHP_DOMAIN = "";

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        //setTimeout(function() {
          if (retval) { // mode == "exploration" && // now not only for exploration mode, but check if this opens other problems
            $('#current-action').show();
            $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
            $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
            triggerRightPanels();
            isPlaying = true;
          }
        //}, 500);
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.right-links').css('background', surpriseColour);
        $('#login-go').css('background', surpriseColour);

        $('.colour').css("color", surpriseColour); // name
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
          // temporary quick fix for Google Chrome Aug 2016 issue...
          setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 100); // force resize/redraw...
          setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        });

        // overlays stuffs
        $('#trigger-about').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#about').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('.close-overlay').click(function() {
          $('.overlays').fadeOut(function() {
            $('#dark-overlay').fadeOut();
          });
        });

        $('#dark-overlay').click(function() {
          $('.overlays').fadeOut();
          $('#dark-overlay').fadeOut();
        });
      });
    </script>

<script src="../js/jquery-ui.min.js"></script>
<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.3.js"></script>
<script src="../js/visualgo_print.js"></script>
<script src="../js/graph_library.js"></script>
<script>
      function runSlide(slide) {
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 1 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 2 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 3 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-1') {
          $("#e-lecture").html("slide " + slide + " (" + 5 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-2') {
          $("#e-lecture").html("slide " + slide + " (" + 6 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-3') {
          $("#e-lecture").html("slide " + slide + " (" + 7 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-4') {
          $("#e-lecture").html("slide " + slide + " (" + 9 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-5') {
          $("#e-lecture").html("slide " + slide + " (" + 10 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-6') {
          $("#e-lecture").html("slide " + slide + " (" + 11 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-7') {
          $("#e-lecture").html("slide " + slide + " (" + 12 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-8') {
          $("#e-lecture").html("slide " + slide + " (" + 14 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-9') {
          $("#e-lecture").html("slide " + slide + " (" + 15 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-10') {
          $("#e-lecture").html("slide " + slide + " (" + 16 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 18 + "%)");
          example(1);
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 19 + "%)");
          example(1);
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-2') {
          $("#e-lecture").html("slide " + slide + " (" + 20 + "%)");
          example(1);
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 22 + "%)");
          $("#search").addClass("menu-highlighted");
$("#predsucc").addClass("menu-highlighted");
$("#inorder").addClass("menu-highlighted");
$("#insert").addClass("menu-highlighted");
$("#remove").addClass("menu-highlighted");
$("#create").addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-1') {
          $("#e-lecture").html("slide " + slide + " (" + 23 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-2') {
          $("#e-lecture").html("slide " + slide + " (" + 24 + "%)");
          $("#insert").addClass("menu-highlighted");
$("#remove").addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 25 + "%)");
          $("#search").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 27 + "%)");
          $("#search").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6-2') {
          $("#e-lecture").html("slide " + slide + " (" + 28 + "%)");
          $("#search").click().addClass("menu-highlighted");
skewed('right');
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 29 + "%)");
          $("#predsucc").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-1') {
          $("#e-lecture").html("slide " + slide + " (" + 31 + "%)");
          $("#predsucc").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-2') {
          $("#e-lecture").html("slide " + slide + " (" + 32 + "%)");
          $("#predsucc").click().addClass("menu-highlighted");
skewed('right');
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '8') {
          $("#e-lecture").html("slide " + slide + " (" + 33 + "%)");
          $("#inorder").addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '8-1') {
          $("#e-lecture").html("slide " + slide + " (" + 35 + "%)");
          $("#inorder").addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '8-2') {
          $("#e-lecture").html("slide " + slide + " (" + 36 + "%)");
          $("#inorder").addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '8-3') {
          $("#e-lecture").html("slide " + slide + " (" + 37 + "%)");
          $("#inorder").addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9') {
          $("#e-lecture").html("slide " + slide + " (" + 38 + "%)");
          $("#insert").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-1') {
          $("#e-lecture").html("slide " + slide + " (" + 40 + "%)");
          $("#insert").click().addClass("menu-highlighted");
skewed('right');
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-2') {
          $("#e-lecture").html("slide " + slide + " (" + 41 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10') {
          $("#e-lecture").html("slide " + slide + " (" + 42 + "%)");
          $("#remove").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10-1') {
          $("#e-lecture").html("slide " + slide + " (" + 44 + "%)");
          $("#remove").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10-2') {
          $("#e-lecture").html("slide " + slide + " (" + 45 + "%)");
          $("#remove").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10-3') {
          $("#e-lecture").html("slide " + slide + " (" + 46 + "%)");
          $("#remove").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10-4') {
          $("#e-lecture").html("slide " + slide + " (" + 48 + "%)");
          $("#remove").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10-5') {
          $("#e-lecture").html("slide " + slide + " (" + 49 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10-6') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $("#remove").click().addClass("menu-highlighted");
skewed('right');
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '11') {
          $("#e-lecture").html("slide " + slide + " (" + 51 + "%)");
          $("#create").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '12') {
          $("#e-lecture").html("slide " + slide + " (" + 53 + "%)");
          skewed('left');
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '12-1') {
          $("#e-lecture").html("slide " + slide + " (" + 54 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13') {
          $("#e-lecture").html("slide " + slide + " (" + 55 + "%)");
          $("#title-BST").click();
skewed('right');
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-1') {
          $("#e-lecture").html("slide " + slide + " (" + 57 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-2') {
          $("#e-lecture").html("slide " + slide + " (" + 58 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-3') {
          $("#e-lecture").html("slide " + slide + " (" + 59 + "%)");
          example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-4') {
          $("#e-lecture").html("slide " + slide + " (" + 61 + "%)");
          example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-5') {
          $("#e-lecture").html("slide " + slide + " (" + 62 + "%)");
          example(3);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-6') {
          $("#e-lecture").html("slide " + slide + " (" + 63 + "%)");
          example(3);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-7') {
          $("#e-lecture").html("slide " + slide + " (" + 64 + "%)");
          $("#title-BST").click();
skewed('right');
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-8') {
          $("#e-lecture").html("slide " + slide + " (" + 66 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-9') {
          $("#e-lecture").html("slide " + slide + " (" + 67 + "%)");
          $("#title-AVL").click();
example(3);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14') {
          $("#e-lecture").html("slide " + slide + " (" + 68 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-1') {
          $("#e-lecture").html("slide " + slide + " (" + 70 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-2') {
          $("#e-lecture").html("slide " + slide + " (" + 71 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-3') {
          $("#e-lecture").html("slide " + slide + " (" + 72 + "%)");
          $("#title-AVL").click();
example(5);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-4') {
          $("#e-lecture").html("slide " + slide + " (" + 74 + "%)");
          $("#title-AVL").click();
example(5);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-5') {
          $("#e-lecture").html("slide " + slide + " (" + 75 + "%)");
          $("#title-AVL").click();
example(5);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-6') {
          $("#e-lecture").html("slide " + slide + " (" + 76 + "%)");
          $("#title-AVL").click();
example(5);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-7') {
          $("#e-lecture").html("slide " + slide + " (" + 77 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-8') {
          $("#e-lecture").html("slide " + slide + " (" + 79 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-9') {
          $("#e-lecture").html("slide " + slide + " (" + 80 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-10') {
          $("#e-lecture").html("slide " + slide + " (" + 81 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-11') {
          $("#e-lecture").html("slide " + slide + " (" + 83 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-12') {
          $("#e-lecture").html("slide " + slide + " (" + 84 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-13') {
          $("#e-lecture").html("slide " + slide + " (" + 85 + "%)");
          $("#title-AVL").click();
example(4);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-14') {
          $("#e-lecture").html("slide " + slide + " (" + 87 + "%)");
          $("#title-AVL").click();
example(5);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '15') {
          $("#e-lecture").html("slide " + slide + " (" + 88 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '15-1') {
          $("#e-lecture").html("slide " + slide + " (" + 89 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '15-2') {
          $("#e-lecture").html("slide " + slide + " (" + 90 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '15-3') {
          $("#e-lecture").html("slide " + slide + " (" + 92 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '15-4') {
          $("#e-lecture").html("slide " + slide + " (" + 93 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '15-5') {
          $("#e-lecture").html("slide " + slide + " (" + 94 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99') {
          $("#e-lecture").html("slide " + slide + " (" + 96 + "%)");
          
          hideEntireActionsPanel();
 
          showStatusPanel();
          showCodetracePanel();
      
        }
        if (slide == '99-1') {
          $("#e-lecture").html("slide " + slide + " (" + 97 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-2') {
          $("#e-lecture").html("slide " + slide + " (" + 98 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-3') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };

      function pushState(slideValue) {
        var url = '/zh/bst';
        if (typeof slideValue != 'undefined' && slideValue != null) url += '?slide=' + slideValue;
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5); 
        $('#overlay').show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      $(function() {
        var slide = getUrlParameter('slide');
        
        $.get('/hasvisited' + '/bst', function(data) {
          var hasVisited = data['hasvisited'] == '1';
          if (!hasVisited) {
            var postData = {
              '_token': 'kaTPcaTtnnJPvGspW7LRTya6UONjjAL7yXZSCSBh',
              'page': '/bst'.substring(1),
            };

            $.post("/visitpage", postData, function(data) {
              // non critical request...
            });

            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
            }

            $("#mode-menu a").trigger("click");
          }
          else {
            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
              $('#mode-menu a').click();
            }    
          }
        }).fail(function() {
          if (typeof slide != undefined && slide != null) {
            cur_slide = slide;
            $('#mode-menu a').click();
          }
        });

        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
      
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
      
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
      
        $('#electure-3-1 .electure-next').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
        $('#electure-3-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
      
        $('#electure-3-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
        $('#electure-3-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
      
        $('#electure-3-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
        $('#electure-3-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
      
        $('#electure-3-4 .electure-next').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
        $('#electure-3-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
      
        $('#electure-3-5 .electure-next').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
        $('#electure-3-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
      
        $('#electure-3-6 .electure-next').click(function() {
          hidePopup();
          runSlide('3-7');
          pushState('3-7');
        });
        $('#electure-3-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
      
        $('#electure-3-7 .electure-next').click(function() {
          hidePopup();
          runSlide('3-8');
          pushState('3-8');
        });
        $('#electure-3-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
      
        $('#electure-3-8 .electure-next').click(function() {
          hidePopup();
          runSlide('3-9');
          pushState('3-9');
        });
        $('#electure-3-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-7');
          pushState('3-7');
        });
      
        $('#electure-3-9 .electure-next').click(function() {
          hidePopup();
          runSlide('3-10');
          pushState('3-10');
        });
        $('#electure-3-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-8');
          pushState('3-8');
        });
      
        $('#electure-3-10 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-9');
          pushState('3-9');
        });
      
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-10');
          pushState('3-10');
        });
      
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
      
        $('#electure-4-2 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
      
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
      
        $('#electure-5-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
      
        $('#electure-5-2 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
      
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
      
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
      
        $('#electure-6-2 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
      
        $('#electure-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
      
        $('#electure-7-1 .electure-next').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-7-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
      
        $('#electure-7-2 .electure-next').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-7-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
      
        $('#electure-8 .electure-next').click(function() {
          hidePopup();
          runSlide('8-1');
          pushState('8-1');
        });
        $('#electure-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
      
        $('#electure-8-1 .electure-next').click(function() {
          hidePopup();
          runSlide('8-2');
          pushState('8-2');
        });
        $('#electure-8-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
      
        $('#electure-8-2 .electure-next').click(function() {
          hidePopup();
          runSlide('8-3');
          pushState('8-3');
        });
        $('#electure-8-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-1');
          pushState('8-1');
        });
      
        $('#electure-8-3 .electure-next').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-8-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-2');
          pushState('8-2');
        });
      
        $('#electure-9 .electure-next').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
        $('#electure-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-3');
          pushState('8-3');
        });
      
        $('#electure-9-1 .electure-next').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
        $('#electure-9-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
      
        $('#electure-9-2 .electure-next').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
        $('#electure-9-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
      
        $('#electure-10 .electure-next').click(function() {
          hidePopup();
          runSlide('10-1');
          pushState('10-1');
        });
        $('#electure-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
      
        $('#electure-10-1 .electure-next').click(function() {
          hidePopup();
          runSlide('10-2');
          pushState('10-2');
        });
        $('#electure-10-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
      
        $('#electure-10-2 .electure-next').click(function() {
          hidePopup();
          runSlide('10-3');
          pushState('10-3');
        });
        $('#electure-10-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-1');
          pushState('10-1');
        });
      
        $('#electure-10-3 .electure-next').click(function() {
          hidePopup();
          runSlide('10-4');
          pushState('10-4');
        });
        $('#electure-10-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-2');
          pushState('10-2');
        });
      
        $('#electure-10-4 .electure-next').click(function() {
          hidePopup();
          runSlide('10-5');
          pushState('10-5');
        });
        $('#electure-10-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-3');
          pushState('10-3');
        });
      
        $('#electure-10-5 .electure-next').click(function() {
          hidePopup();
          runSlide('10-6');
          pushState('10-6');
        });
        $('#electure-10-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-4');
          pushState('10-4');
        });
      
        $('#electure-10-6 .electure-next').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
        $('#electure-10-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-5');
          pushState('10-5');
        });
      
        $('#electure-11 .electure-next').click(function() {
          hidePopup();
          runSlide('12');
          pushState('12');
        });
        $('#electure-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-6');
          pushState('10-6');
        });
      
        $('#electure-12 .electure-next').click(function() {
          hidePopup();
          runSlide('12-1');
          pushState('12-1');
        });
        $('#electure-12 .electure-prev').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
      
        $('#electure-12-1 .electure-next').click(function() {
          hidePopup();
          runSlide('13');
          pushState('13');
        });
        $('#electure-12-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('12');
          pushState('12');
        });
      
        $('#electure-13 .electure-next').click(function() {
          hidePopup();
          runSlide('13-1');
          pushState('13-1');
        });
        $('#electure-13 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-1');
          pushState('12-1');
        });
      
        $('#electure-13-1 .electure-next').click(function() {
          hidePopup();
          runSlide('13-2');
          pushState('13-2');
        });
        $('#electure-13-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('13');
          pushState('13');
        });
      
        $('#electure-13-2 .electure-next').click(function() {
          hidePopup();
          runSlide('13-3');
          pushState('13-3');
        });
        $('#electure-13-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-1');
          pushState('13-1');
        });
      
        $('#electure-13-3 .electure-next').click(function() {
          hidePopup();
          runSlide('13-4');
          pushState('13-4');
        });
        $('#electure-13-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-2');
          pushState('13-2');
        });
      
        $('#electure-13-4 .electure-next').click(function() {
          hidePopup();
          runSlide('13-5');
          pushState('13-5');
        });
        $('#electure-13-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-3');
          pushState('13-3');
        });
      
        $('#electure-13-5 .electure-next').click(function() {
          hidePopup();
          runSlide('13-6');
          pushState('13-6');
        });
        $('#electure-13-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-4');
          pushState('13-4');
        });
      
        $('#electure-13-6 .electure-next').click(function() {
          hidePopup();
          runSlide('13-7');
          pushState('13-7');
        });
        $('#electure-13-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-5');
          pushState('13-5');
        });
      
        $('#electure-13-7 .electure-next').click(function() {
          hidePopup();
          runSlide('13-8');
          pushState('13-8');
        });
        $('#electure-13-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-6');
          pushState('13-6');
        });
      
        $('#electure-13-8 .electure-next').click(function() {
          hidePopup();
          runSlide('13-9');
          pushState('13-9');
        });
        $('#electure-13-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-7');
          pushState('13-7');
        });
      
        $('#electure-13-9 .electure-next').click(function() {
          hidePopup();
          runSlide('14');
          pushState('14');
        });
        $('#electure-13-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-8');
          pushState('13-8');
        });
      
        $('#electure-14 .electure-next').click(function() {
          hidePopup();
          runSlide('14-1');
          pushState('14-1');
        });
        $('#electure-14 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-9');
          pushState('13-9');
        });
      
        $('#electure-14-1 .electure-next').click(function() {
          hidePopup();
          runSlide('14-2');
          pushState('14-2');
        });
        $('#electure-14-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('14');
          pushState('14');
        });
      
        $('#electure-14-2 .electure-next').click(function() {
          hidePopup();
          runSlide('14-3');
          pushState('14-3');
        });
        $('#electure-14-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-1');
          pushState('14-1');
        });
      
        $('#electure-14-3 .electure-next').click(function() {
          hidePopup();
          runSlide('14-4');
          pushState('14-4');
        });
        $('#electure-14-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-2');
          pushState('14-2');
        });
      
        $('#electure-14-4 .electure-next').click(function() {
          hidePopup();
          runSlide('14-5');
          pushState('14-5');
        });
        $('#electure-14-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-3');
          pushState('14-3');
        });
      
        $('#electure-14-5 .electure-next').click(function() {
          hidePopup();
          runSlide('14-6');
          pushState('14-6');
        });
        $('#electure-14-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-4');
          pushState('14-4');
        });
      
        $('#electure-14-6 .electure-next').click(function() {
          hidePopup();
          runSlide('14-7');
          pushState('14-7');
        });
        $('#electure-14-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-5');
          pushState('14-5');
        });
      
        $('#electure-14-7 .electure-next').click(function() {
          hidePopup();
          runSlide('14-8');
          pushState('14-8');
        });
        $('#electure-14-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-6');
          pushState('14-6');
        });
      
        $('#electure-14-8 .electure-next').click(function() {
          hidePopup();
          runSlide('14-9');
          pushState('14-9');
        });
        $('#electure-14-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-7');
          pushState('14-7');
        });
      
        $('#electure-14-9 .electure-next').click(function() {
          hidePopup();
          runSlide('14-10');
          pushState('14-10');
        });
        $('#electure-14-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-8');
          pushState('14-8');
        });
      
        $('#electure-14-10 .electure-next').click(function() {
          hidePopup();
          runSlide('14-11');
          pushState('14-11');
        });
        $('#electure-14-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-9');
          pushState('14-9');
        });
      
        $('#electure-14-11 .electure-next').click(function() {
          hidePopup();
          runSlide('14-12');
          pushState('14-12');
        });
        $('#electure-14-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-10');
          pushState('14-10');
        });
      
        $('#electure-14-12 .electure-next').click(function() {
          hidePopup();
          runSlide('14-13');
          pushState('14-13');
        });
        $('#electure-14-12 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-11');
          pushState('14-11');
        });
      
        $('#electure-14-13 .electure-next').click(function() {
          hidePopup();
          runSlide('14-14');
          pushState('14-14');
        });
        $('#electure-14-13 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-12');
          pushState('14-12');
        });
      
        $('#electure-14-14 .electure-next').click(function() {
          hidePopup();
          runSlide('15');
          pushState('15');
        });
        $('#electure-14-14 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-13');
          pushState('14-13');
        });
      
        $('#electure-15 .electure-next').click(function() {
          hidePopup();
          runSlide('15-1');
          pushState('15-1');
        });
        $('#electure-15 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-14');
          pushState('14-14');
        });
      
        $('#electure-15-1 .electure-next').click(function() {
          hidePopup();
          runSlide('15-2');
          pushState('15-2');
        });
        $('#electure-15-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('15');
          pushState('15');
        });
      
        $('#electure-15-2 .electure-next').click(function() {
          hidePopup();
          runSlide('15-3');
          pushState('15-3');
        });
        $('#electure-15-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('15-1');
          pushState('15-1');
        });
      
        $('#electure-15-3 .electure-next').click(function() {
          hidePopup();
          runSlide('15-4');
          pushState('15-4');
        });
        $('#electure-15-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('15-2');
          pushState('15-2');
        });
      
        $('#electure-15-4 .electure-next').click(function() {
          hidePopup();
          runSlide('15-5');
          pushState('15-5');
        });
        $('#electure-15-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('15-3');
          pushState('15-3');
        });
      
        $('#electure-15-5 .electure-next').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
        $('#electure-15-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('15-4');
          pushState('15-4');
        });
      
        $('#electure-99 .electure-next').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
        $('#electure-99 .electure-prev').click(function() {
          hidePopup();
          runSlide('15-5');
          pushState('15-5');
        });
      
        $('#electure-99-1 .electure-next').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
        $('#electure-99-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
      
        $('#electure-99-2 .electure-next').click(function() {
          hidePopup();
          runSlide('99-3');
          pushState('99-3');
        });
        $('#electure-99-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
      
        $('#electure-99-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
      
 

        // temporary quick fix for Google Chrome Aug 2016 issue..., put at last part so that everything else has been loaded
        // setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 500);
        // setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        // I turn it off on 14 June 2018, seems 'ok'?
      });

      function doButtonAction1() {
        CUSTOM_ACTION('search', 7);
      }
      function doButtonAction2() {
        CUSTOM_ACTION('search', 15);
      }
      function doButtonAction3() {
        CUSTOM_ACTION('search', 21);
      }
      function doButtonAction4() {
        $("#v-search").val(64);
mode = "exploration"; 
cur_slide = 1;
$(".tutorial-dialog#tutorial-4").fadeOut(100);
searchVertex(function() {
  mode = "tutorial"; 
  $(".tutorial-dialog#tutorial-4").fadeIn(100);
});
      }
      function doButtonAction5() {
        CUSTOM_ACTION('search', 100);
      }
      function doButtonAction6() {
        CUSTOM_ACTION('successor', 23);
      }
      function doButtonAction52() {
        CUSTOM_ACTION('findmin');
      }
      function doButtonAction53() {
        CUSTOM_ACTION('findmax');
      }
      function doButtonAction54() {
        CUSTOM_ACTION('successor', 7);
      }
      function doButtonAction55() {
        CUSTOM_ACTION('successor', 71);
      }
      function doButtonAction56() {
        CUSTOM_ACTION('predecessor', 6);
      }
      function doButtonAction57() {
        CUSTOM_ACTION('predecessor', 50);
      }
      function doButtonAction58() {
        CUSTOM_ACTION('predecessor', 4);
      }
      function doButtonAction59() {
        CUSTOM_ACTION('inorder');
      }
      function doButtonAction60() {
        CUSTOM_ACTION('insert', 60);
      }
      function doButtonAction61() {
        CUSTOM_ACTION('remove', 5);
      }
      function doButtonAction62() {
        CUSTOM_ACTION('remove', 23);
      }
      function doButtonAction63() {
        CUSTOM_ACTION('remove', 6);
      }
      function doButtonAction64() {
        CUSTOM_ACTION('successor_max');
      }
      function doButtonAction65() {
        CUSTOM_ACTION('insert_max_plus_1');
      }
      function doButtonAction66() {
        CUSTOM_ACTION('remove_max');
      }
      function doButtonAction68() {
        CUSTOM_ACTION('remove', 7);
      }
      function doButtonAction69() {
        CUSTOM_ACTION('insert', 37);
$(this).hide();
      }

      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();  
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}
    </script>
<script type="text/javascript">
// BST Widget, also includes AVL tree
// original author: Ivan Reinaldo, then maintained by Steven Halim

var BST = function() {
  var self = this;
  var gw = new GraphWidget();
  var isAVL = false;

  var valueRange = [1, 100]; // Range of valid values of BST vertexes allowed
  var maxHeightAllowed = 9; // max 9 edges (10 vertices)

  var initialArray = [15, 6, 23, 4, 7, 71, 5, 50];
  var initialAvlArray = [15, 6, 50, 4, 7, 23, 71, 5];

  /*
   * iBST: Internal representation of BST in this object
   * The keys are the text of the nodes, and the value is the attributes of the corresponding node encapsulated in a JS object, which are:
   * - "parent": text of the parent node. If the node is root node, the value is null.
   * - "leftChild": text of the left child. No child -> null
   * - "rightChild": text of the right child. No child -> null
   * - "cx": X-coordinate of center of the node
   * - "cy": Y-coordinate of center of the node
   * - "height": height of the node. Height of root is 0
   * - "vertexClassNumber": Vertex class number of the corresponding node
   *
   * In addition, there is a key called "root" in iBST, containing the text of the root node.
   * If BST is empty, root is null.
   */

  var iBST = {};
  var amountVertex = 0;
  iBST["root"] = null;

  if (isAVL) init(initialAvlArray);
  else       init(initialArray);

  this.getGraphWidget = function() { return gw; };

  function dummyInit() {
    iBST["root"] = 15;
    iBST[15] = {
      "parent": null,
      "leftChild": 6,
      "rightChild": 23,
      "vertexClassNumber": 0
    };
    iBST[6] = {
      "parent": 15,
      "leftChild": 4,
      "rightChild": 7,
      "vertexClassNumber": 1
    };
    iBST[23] = {
      "parent": 15,
      "leftChild": null,
      "rightChild": 71,
      "vertexClassNumber": 2
    };
    iBST[4] = {
      "parent": 6,
      "leftChild": null,
      "rightChild": 5,
      "vertexClassNumber": 3
    };
    iBST[7] = {
      "parent": 6,
      "leftChild": null,
      "rightChild": null,
      "vertexClassNumber": 4
    };
    iBST[71] = {
      "parent": 23,
      "leftChild": 50,
      "rightChild": null,
      "vertexClassNumber": 5
    };
    iBST[5] = {
      "parent": 4,
      "leftChild": null,
      "rightChild": null,
      "vertexClassNumber": 6
    };
    iBST[50] = {
      "parent": 71,
      "leftChild": null,
      "rightChild": null,
      "vertexClassNumber": 7
    };

    var key;
    recalculatePosition();

    for (key in iBST) {
      if (key == "root")
        continue;

      var cur = iBST[key];
      gw.addVertex(cur["cx"], cur["cy"], key, cur["vertexClassNumber"], true);
    }

    for (key in iBST) {
      if (key == "root")
        continue;

      var cur = iBST[key];
      var parentVertex = iBST[cur["parent"]];
      if (cur["parent"] == null)
        continue;

      gw.addEdge(parentVertex["vertexClassNumber"], cur["vertexClassNumber"], cur["vertexClassNumber"], EDGE_TYPE_UDE, 1, true);
    }

    amountVertex = 8;
  }

  this.generate = function(array) { init(array); };

  this.generateEmpty = function() {
    var vertexAmt = 0;
    var initArr = [];
    init(initArr);
    return true;
  };

  this.generateExample = function(id) {
    if (isAVL && (id == 1)) {
      $('#create-err').html("AVL trees are balanced. This example is not balanced."); 
      return false;
    }
    var vertexAmt = 8; // for id == 1
    var initArr = [15,6,23,4,7,71,5,50];
    if (id == 2) {
      vertexAmt = 10;
      initArr = [41,20,65,11,29,50,91,32,72,99];
    }
    else if (id == 3) {
      vertexAmt = 15;
      initArr = [8,4,12,2,6,10,14,1,3,5,7,9,11,13,15];
    }
    else if (id == 4) {
      vertexAmt = 12;
      initArr = [8,6,16,3,7,13,19,2,11,15,18,10];
    }
    else if (id == 5) {
      vertexAmt = 20;
      initArr = [13,8,18,5,11,16,20,3,7,10,12,15,17,19,2,4,6,9,14,1];
    }
    init(initArr);
    return true;
  }

  this.generateRandom = function() {
    var vertexAmt = Math.floor((Math.random()*7 + 5));
    var initArr = [];

    while (initArr.length < vertexAmt) {
      var random = Math.floor(1 + Math.random()*99);
      if ($.inArray(random, initArr) < 0)
        initArr.push(random);
    }

    if (isAVL) {
      var initArrAvl = [];

      function recursion(startVal, endVal) {
        var total = startVal + endVal + 1;
        if (total < 1)
          return;
        if (startVal > endVal)
          return;
        if (total == 1)
          initArrAvl.push(initArr[startVal]);
        else if (total % 2 != 0) {
          initArrAvl.push(initArr[parseInt(total/2)]);
          recursion(startVal, parseInt(total/2) - 1);
          recursion(parseInt(total/2) + 1, endVal);
        }
        else {
          initArrAvl.push(initArr[parseInt(total/2) - 1]);
          recursion(startVal, parseInt(total/2) - 2);
          recursion(parseInt(total/2), endVal);
        }
      }

      function sortNumber(a, b) { return a-b; }
      initArr.sort(sortNumber);
      recursion(0, initArr.length-1);
      init(initArrAvl);
    }
    else
      init(initArr);

    return true;
  }

  this.generateSkewed = function(side) {
    if (isAVL) {
      $('#create-err').html('AVL trees are not skewed. Select the BST header to use this action.');
      return false;
    }
    else {
      var vertexAmt = Math.floor(5 + Math.random()*5); // [5..9] vertices (allow +1 for one more right/left extreme insertion)
      var initArr = new Array();
      while (initArr.length < vertexAmt) {
        var random = Math.floor(1 + Math.random()*99); // value [1..99]
        if ($.inArray(random, initArr) < 0)
          initArr.push(random);
      }
      if (side == "left") {
        initArr.sort(function(a, b) {
          return b-a;
        });
      }
      else if (side == "right") {
        initArr.sort(function(a, b) {
          return a-b;
        });
      }
      init(initArr);
      return true;
    }
  };

  this.isAVL = function(bool) {
    if (typeof bool != 'boolean') return;

    if (bool != isAVL) {
      clearScreen();
      if (bool)
        init(initialAvlArray);
      else
        init(initialArray);
      isAVL = bool;
    }
  };

  this.getIsAVL = function() {
    return isAVL;
  };

  this.getRandomInBST = function() {
    var arr = new Array();
    for (var key in iBST) {
      if (key == "root") continue;
      arr.push(key);
    }
    return parseInt(arr[Math.floor(Math.random()*arr.length)]);
  }

  this.getRandomNotInBST = function() {
    var arr = new Array();
    for (var key in iBST) {
      if (key == "root") continue;
      arr.push(parseInt(key));
    }
    var candidate = 1 + Math.floor(Math.random()*99); // [1..99]
    while ($.inArray(candidate, arr) > 0)
      candidate = 1 + Math.floor(Math.random()*99);
    return candidate;
  }

  this.search = function(val, callback) {
    var sl = [], vertexTraversed = {}, edgeTraversed = {}, cur = iBST["root"], cs, currentVertexClass, key, ans;

    cs = createState(iBST);
    //cs["status"] = "The current BST";  //status_search_0
    cs["status"] = '现在的BST';
    cs["lineNo"] = 0;
    sl.push(cs);

    while (cur != val && cur != null) {
      cs = createState(iBST, vertexTraversed, edgeTraversed);
      currentVertexClass = iBST[cur]["vertexClassNumber"];
      cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
      vertexTraversed[cur] = true;
      //cs["status"] = "Comparing " + cur + " with " + val + "."; //status_search_1
      cs["status"] = '比较变量{cur}和变量{val}'.replace("{cur}", cur).replace("{val}", val);
      cs["lineNo"] = 3;
      sl.push(cs);

      if (parseInt(val) > parseInt(cur)) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        //cs["status"] = cur + " is smaller than " + val + "."; //status_search_2
        cs["status"] = '{cur}小于{val}'.replace("{cur}", cur).replace("{val}", val);
        cs["lineNo"] = 5;
        sl.push(cs);

        cur = iBST[cur]["rightChild"];
        if (cur == null) {
          cs = createState(iBST, vertexTraversed, edgeTraversed);
          //cs["status"] = "Value " + val + " is not in the BST."; //status_search_3
          cs["status"] = '变量 {val} 不在BST'.replace("{val}", val);
          cs["lineNo"] = [1, 2];
          sl.push(cs);
          break;
        }

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        var edgeHighlighted = iBST[cur]["vertexClassNumber"];
        edgeTraversed[edgeHighlighted] = true;
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
        //cs["status"] = "So search on the right."; //status_search_4
        cs["status"] = '向右查找';
        cs["lineNo"] = 6;
        sl.push(cs);
      }
      else {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        //cs["status"] = cur + " is greater than " + val + "."; //status_search_5
        cs["status"] = '{cur}大于{val}'.replace("{cur}", cur).replace("{val}", val);
        cs["lineNo"] = 7;
        sl.push(cs);

        cur = iBST[cur]["leftChild"];
        if (cur == null) {
          cs = createState(iBST, vertexTraversed, edgeTraversed);
          //cs["status"] = "Value " + val + " is not in the BST.";  //status_search_6
          cs["status"] = '变量 {val} 不在BST<br>'.replace("{val}", val);
          cs["lineNo"] = [1, 2];
          sl.push(cs);
          break;
        }

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        var edgeHighlighted = iBST[cur]["vertexClassNumber"];
        edgeTraversed[edgeHighlighted] = true;
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
        //cs["status"] = "So search on the left.";  //status_search_7
        cs["status"] = '向左查找';
        cs["lineNo"] = 7;
        sl.push(cs);
      }
    }

    if (cur != null) {
      cs = createState(iBST, vertexTraversed, edgeTraversed);
      currentVertexClass = iBST[cur]["vertexClassNumber"];
      cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
      //cs["status"] = "Found value " + val + ".";  //status_search_8
      cs["status"] = '找到值{val}'.replace("{val}", val);
      cs["lineNo"] = 4;
      sl.push(cs);
    }

    gw.startAnimation(sl, callback);
    populatePseudocode(4);
    return true;
  }

  this.findMax = function() {
    var ans = -1;
    for (key in iBST) {
      if (key == "root") continue;
      ans = Math.max(ans, key);
    }
    return ans;
  }

  this.findMinMax = function(isMin, callback) {
    var sl = [], vertexTraversed = {}, edgeTraversed = {}, cur = iBST["root"], cs, key, ans;

    cs = createState(iBST);
    //cs["status"] = "The current BST"; //status_minmax_0
    cs["status"] = '现在的BST';
    cs["lineNo"] = 0;
    sl.push(cs);

    if (cur == null) {
      cs = createState(iBST);
      if (isMin) {
        //cs["status"] = "Tree is empty, there is no minimum value."; //status_minmax_1
        cs["status"] = '树是空的，找不到最小值';
      }
      else {
        //cs["status"] = "Tree is empty, there is no maximum value."; //status_minmax_2
        cs["status"] = '树是空的，没有最大值';
      }
      cs["lineNo"] = 1;
      sl.push(cs);
      gw.startAnimation(sl, callback);
      return true;
    }

    while (cur != null) {
      cs = createState(iBST, vertexTraversed, edgeTraversed);
      key = iBST[cur]["vertexClassNumber"];
      cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
      vertexTraversed[cur] = true;
      if (( isMin && (iBST[cur]["leftChild"] != null)) ||
          (!isMin && (iBST[cur]["rightChild"] != null))) {
        if (isMin) {
          //cs["status"] = cur + " is not the minimum value as it has a left child.";  //status_minmax_3
          cs["status"] = '变量{cur}不是最小值，因为它有左子树。'.replace("{cur}", cur);
        }
        else {
          //cs["status"] = cur + " is not the maximum value as it has a right child.";  //status_minmax_4
          cs["status"] = '当前变量{cur}不是最大值，因为它有右子树。'.replace("{cur}", cur);
        }
        cs["lineNo"] = 2;
      }
      else {
        ans = cur;
        if (isMin) {
          //cs["status"] = "Minimum value found!";  //status_minmax_5
          cs["status"] = 'Minimum value found!';
        }
        else {
          //cs["status"] = "Maximum value found!";  //status_minmax_6
          cs["status"] = '最大值找到！';
        }

        cs["lineNo"] = 4;
      }
      cur = (isMin ? iBST[cur]["leftChild"] : iBST[cur]["rightChild"]);
      sl.push(cs);

      if (cur == null) break;

      cs = createState(iBST, vertexTraversed, edgeTraversed);
      var edgeHighlighted = iBST[cur]["vertexClassNumber"];
      edgeTraversed[edgeHighlighted] = true;
      cs["el"][edgeHighlighted]["animateHighlighted"] = true;
      cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
      if (isMin) {
        //cs["status"] = "Go left to check for smaller value..."; //status_minmax_7
        cs["status"] = '向左搜索更小的值...';
      }
      else {
        //cs["status"] = "Go right to check for larger value..."; //status_minmax_8
        cs["status"] = '向右搜索更大的值';
      }

      cs["lineNo"] = 3;
      sl.push(cs);
    }

    cs = createState(iBST);
    if (isMin) {
      //cs["status"] = "Find Min has ended.<br>The minimum value is " + ans + ".";  //status_minmax_9
      cs["status"] = '查找最小值的过程已经结束了。<div>最小值是{ans}</div>'.replace("{ans}", ans);
    }
    else {
      //cs["status"] = "Find Max has ended.<br>The maximum value is " + ans + ".";  //status_minmax_10
      cs["status"] = '查找最大值的过程已经结束了。<div>最小值是{ans}</div>'.replace("{ans}", ans);
    }

    cs["lineNo"] = 0;
    sl.push(cs);

    populatePseudocode(isMin ? 2 : 1);
    gw.startAnimation(sl, callback);
    return true;
  }

  this.findPredSucc = function(val, isPred, callback) {
    var sl = [], vertexTraversed = {}, edgeTraversed = {}, cur = iBST["root"], cs, key, currentVertexClass;
    cur = val = parseInt(val);

    if (val == null || val == undefined || isNaN(val)) {
      $('#predsucc-err').html('请输入一个有效的数值！');
      return false;invalidval
    }

    if (iBST[val] == null) {
      $('#predsucc-err').html('请在二叉搜索树展示区输入一个值');
      return false;
    }

    key = iBST[val]["vertexClassNumber"];
    cs = createState(iBST);
    //cs["status"] = "The current BST.";  //status_predsucc_0
    cs["status"] = '现在的BST';
    cs["lineNo"] = 0;
    sl.push(cs);

    if (( isPred && (iBST[val]["leftChild"] != null)) ||
        (!isPred && (iBST[val]["rightChild"] != null))) {
      var subTreeRoot = (isPred ? iBST[val]["leftChild"] : iBST[val]["rightChild"]);
      var subTreeRootKey = iBST[subTreeRoot]["vertexClassNumber"];

      edgeTraversed[subTreeRootKey] = true;

      cs = createState(iBST, vertexTraversed, edgeTraversed);
      cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
      cs["el"][subTreeRootKey]["animateHighlighted"] = true;
      if (isPred) {
        //cs["status"] = "This vertex has a left child, so go left.";  //status_predsucc_1
        cs["status"] = '这个节点有左子树，所以向右';
      } else {
        //cs["status"] = "This vertex has a right child, so go right.";  //status_predsucc_2
        cs["status"] = '这个节点有右子树，所以向左';
      }

      cs["lineNo"] = 1;
      sl.push(cs);

      cs = createState(iBST, vertexTraversed, edgeTraversed);
      cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][subTreeRootKey]["state"] = VERTEX_HIGHLIGHTED;
      if (isPred) {
        //cs["status"] = "Check whether the left child has a right child."; //status_predsucc_3
        cs["status"] = '检查左子树是否有右子树。';
      } else {
        //cs["status"] = "Check whether the right child has a left child."; //status_predsucc_4
        cs["status"] = '检查右子树是否有左子树。';
      }
      cs["lineNo"] = 1;
      sl.push(cs);

      if (( isPred && (iBST[subTreeRoot]["rightChild"] != null)) ||
          (!isPred && (iBST[subTreeRoot]["leftChild"] != null))) {
        cur = subTreeRoot;
        currentVertexClass = iBST[cur]["vertexClassNumber"];

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][subTreeRootKey]["state"] = VERTEX_HIGHLIGHTED;
        if (isPred) {
          //cs["status"] = "Right child found! Go to the right."; //status_predsucc_5
          cs["status"] = '右子树找到！向右。';
        } else {
          //cs["status"] = "Left child found! Go to the left."; //status_predsucc_6
          cs["status"] = '左子树找到！向左';
        }
        cs["lineNo"] = 1;
        sl.push(cs);

        while (( isPred && (iBST[cur]["rightChild"] != null)) ||
               (!isPred && (iBST[cur]["leftChild"] != null))) {
          cs = createState(iBST, vertexTraversed, edgeTraversed);
          cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
          cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
          vertexTraversed[cur] = true;
          if (isPred) {
            //cs["status"] = cur + " is not the predecessor vertex as it has a right child."; //status_predsucc_7
            cs["status"] = '{cur}不是前任节点，因为它有右子树。'.replace("{cur}", cur);
          } else {
            //cs["status"] = cur + " is not the successor vertex as it has a left child.";  //status_predsucc_8
            cs["status"] = '{cur}不是后继节点，因为它有左子树。'.replace("{cur}", cur);
          }
          cs["lineNo"] = 1;
          sl.push(cs);

          cur = (isPred ? iBST[cur]["rightChild"] : iBST[cur]["leftChild"]);
          currentVertexClass = iBST[cur]["vertexClassNumber"];

          cs = createState(iBST, vertexTraversed, edgeTraversed);
          var edgeHighlighted = currentVertexClass;
          edgeTraversed[edgeHighlighted] = true;
          cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
          cs["el"][edgeHighlighted]["animateHighlighted"] = true;
          cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
          if (isPred) {
            //cs["status"] = "Go right to check for larger value."; //status_predsucc_9
            cs["status"] = '向右走，检查是否有较大的值。<br>';
          } else {
            //cs["status"] = "Go left to check for smaller value."; //status_predsucc_10
            cs["status"] = '向左走，检查是否有较小的值。';
          }
          cs["lineNo"] = 1;
          sl.push(cs);
        }

        ans = cur;

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
        if (isPred) {
          //cs["status"] = "Predecessor found!<br>The predecessor of " + val + " is " + ans + ".";  //status_predsucc_11
          cs["status"] = '找到前驱！<div>{val} 的前驱是 {ans}。</div>'.replace("{ans}", ans).replace("{val}", val);
        } else {
          //cs["status"] = "Successor found!<br>The successor of " + val + " is " + ans + ".";  //status_predsucc_12
          cs["status"] = 'Successor found!<br>The successor of {val} is {ans}.'.replace("{ans}", ans).replace("{val}", val);
        }
        cs["vl"][key]["extratext"] = "value";
        cs["vl"][currentVertexClass]["extratext"] = "its " + (isPred ? "predecessor" : "successor");
        cs["lineNo"] = 1;
        sl.push(cs);
      }
      else {
        ans = subTreeRoot;

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][subTreeRootKey]["state"] = VERTEX_HIGHLIGHTED;
        if (isPred) {
          //cs["status"] = "No right child found, so this vertex is the predecessor.<br>The predecessor of " + val + " is " + ans + ".";  //status_predsucc_13
          cs["status"] = '右子树未找到，所以当前节点是前任节点，{val}的前任节点是{ans}'.replace("{ans}", ans).replace("{val}", val);
        } else {
          //cs["status"] = "No left child found, so this vertex is the successor.<br>The successor of " + val + " is " + ans + "."; //status_predsucc_14
          cs["status"] = '左子树未找到，所以当前节点是后继节点，{val}的后继节点是{ans}'.replace("{ans}", ans).replace("{val}", val);
        }
        cs["vl"][key]["extratext"] = "value";
        cs["vl"][subTreeRootKey]["extratext"] = "its " + (isPred ? "predecessor" : "successor");
        cs["lineNo"] = 1;
        sl.push(cs);
      }
    }
    else {
      currentVertexClass = iBST[cur]["vertexClassNumber"];

      edgeTraversed[currentVertexClass] = true;

      cs = createState(iBST, vertexTraversed, edgeTraversed);
      cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
      cs["el"][currentVertexClass]["state"] = EDGE_HIGHLIGHTED;
      if (isPred) {
        //cs["status"] = "No left child found, so check the parent..";  //status_predsucc_15
        cs["status"] = '左子树未找到，检查父节点。';
      } else {
        //cs["status"] = "No right child found, so check the parent.."; //status_predsucc_16
        cs["status"] = '右子树未找到，检查父节点。';
      }
      cs["lineNo"] = [2, 3];
      sl.push(cs);

      cur = iBST[cur]["parent"];
      currentVertexClass = iBST[cur]["vertexClassNumber"];

      while (true) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
        vertexTraversed[cur] = true;
        if (( isPred && (cur > val)) ||
            (!isPred && (cur < val))) {
          if (isPred) {
            //cs["status"] = cur + " is not the predecessor vertex as " + val + " is part of the left sub-tree";  //status_predsucc_17
            cs["status"] = '{cur} is not the predecessor vertex as {val} is part of the left sub-tree'.replace("{cur}", cur).replace("{val}", val);
          } else {
            //cs["status"] = cur + " is not the successor vertex as " + val + " is part of the right sub-tree"; //status_predsucc_18
            cs["status"] = '{cur}不是后继节点，因为{val}是右子树的一部分<br>'.replace("{cur}", cur).replace("{val}", val);
          }
          cs["lineNo"] = 4;
          sl.push(cs);
        }
        else {
          ans = cur;
          if (isPred) {
            //cs["status"] = "Predecessor found!<br>The predecessor of " + val + " is " + ans + ".";  //status_predsucc_19
            cs["status"] = '找到前驱！<div>{val} 的前驱是 {ans}。</div>'.replace("{ans}", ans).replace("{val}", val);
          } else {
            //cs["status"] = "Successor found!<br>The successor of " + val + " is " + ans + ".";  //status_predsucc_20
            cs["status"] = '找到后继！<div>{val} 的后继是 {ans}。</div>'.replace("{ans}", ans).replace("{val}", val);
          }
          cs["vl"][key]["extratext"] = "value";
          cs["vl"][currentVertexClass]["extratext"] = "its " + (isPred ? "predecessor" : "successor");
          cs["lineNo"] = 7;
          sl.push(cs);
          break;
        }

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        var edgeHighlighted = currentVertexClass;
        if (cur != iBST["root"])
          edgeTraversed[edgeHighlighted] = true;
        cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
        if (cur != iBST["root"])
          cs["el"][edgeHighlighted]["state"] = EDGE_HIGHLIGHTED;
        //cs["status"] = "Go up to check for smaller value."; //status_predsucc_21
        cs["status"] = '往上查看较小的值。';
        cs["lineNo"] = 5;
        sl.push(cs);

        cur = iBST[cur]["parent"];
        if (cur == null) break;

        currentVertexClass = iBST[cur]["vertexClassNumber"];
      }

      if (cur == null) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
        if (isPred) {
          //cs["status"] = "Parent is null, so " + val + " has no predecessor.";  //status_predsucc_22
          cs["status"] = '父节点是null，所以 {val} 没有前驱。'.replace("{val}", val);
        } else {
          //cs["status"] = "Parent is null, so " + val + " has no successor.";  //status_predsucc_23
          cs["status"] = '父节点是null，所以 {val} 没有后继。<br>'.replace("{val}", val);
        }
        cs["lineNo"] = 6;
        sl.push(cs);

        ans = null;
      }
    }

    gw.startAnimation(sl, callback);
    populatePseudocode(isPred ? 9 : 8);
    return true;
  }

  this.inorderTraversal = function(callback) {
    var sl = [], vertexTraversed = {}, edgeTraversed = {}, cur = iBST["root"], cs, key;
    var vertexHighlighted = {};

    cs = createState(iBST);
    //cs["status"] = "The current BST.";  //status_inorder_0
    cs["status"] = '现在的BST';
    cs["lineNo"] = 0;
    sl.push(cs);

    if (iBST["root"] == null) {
      cs = createState(iBST);
      //cs["status"] = "The Binary Search Tree is empty.<br>Return empty result.";  //status_inorder_1
      cs["status"] = '二叉搜索树是空的。<div>返回空的结果。</div>';
      cs["lineNo"] = [1, 2];
      sl.push(cs);
      return true;
    }
    else {
      key = iBST[iBST["root"]]["vertexClassNumber"];

      cs = createState(iBST);
      cs["vl"][key]["state"] = VERTEX_TRAVERSED;
      cs["vl"][key]["extratext"] = "root";
      //cs["status"] = "The root " + iBST["root"] + " is not null.";  //status_inorder_2
      cs["status"] = '根，{root} 不是null。'.replace("{root}", iBST["root"]);
      cs["lineNo"] = 1;
      sl.push(cs);

      cs = createState(iBST);
      cs["vl"][key]["state"] = VERTEX_TRAVERSED;
      cs["vl"][key]["extratext"] = "root";
      //cs["status"] = "So recurse and check left child of " + iBST["root"] + ".";  //status_inorder_3
      cs["status"] = '所以递归检查{root}的左子树。'.replace("{root}", iBST["root"]);
      cs["lineNo"] = 3;
      sl.push(cs);

      inorderTraversalRecursion(iBST["root"]);
    }

    cs = createState(iBST, vertexTraversed, edgeTraversed);
    inorderHighlightVertex(key);
    //cs["status"] = "In-order traversal of the whole BST is complete.";  //status_inorder_4
    cs["status"] = '整个BST的中序遍历完成了。';
    cs["vl"][key]["extratext"] = "root";
    cs["lineNo"] = 0;
    sl.push(cs);

    gw.startAnimation(sl, callback);

    function inorderTraversalRecursion(cur) {
      var curLeft = iBST[cur]["leftChild"], curRight = iBST[cur]["rightChild"];
      var key = iBST[cur]["vertexClassNumber"];

      if (curLeft == null) {
        vertexTraversed[cur] = true;
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        inorderHighlightVertex(key);
        //cs["status"] = "The left child of vertex with value " + cur + " is empty.<br>Return empty.";  //status_inorder_5
        cs["status"] = '值为{cur}的节点的左子节点为空。<br>返回空值。'.replace("{cur}", cur);
        cs["lineNo"] = [1, 2];
        sl.push(cs);
      }
      else {
        var curLeftClass = iBST[curLeft]["vertexClassNumber"];

        vertexTraversed[cur] = true;
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        inorderHighlightVertex(key);
        //cs["status"] = "The left child of vertex with value " + cur + " is " + curLeft + " (not null).";  //status_inorder_6
        cs["status"] = '具有值{cur}的节点的左子节点是{curLeft}（非空）。'.replace("{cur}", cur).replace("{curLeft}", curLeft);
        cs["lineNo"] = 1;
        sl.push(cs);
        edgeTraversed[curLeftClass] = true;
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["el"][curLeftClass]["animateHighlighted"] = true;
        inorderHighlightVertex(key);
        //cs["status"] = "So recurse and check left child of vertex with value " + curLeft + ".";//status_inorder_7
        cs["status"] = '因此，使用 {curLeft} 递归并检查节点的左子节点。<br>'.replace("{curLeft}", curLeft);
        cs["lineNo"] = 3;
        sl.push(cs);
        inorderTraversalRecursion(curLeft);
      }

      cs = createState(iBST, vertexTraversed, edgeTraversed);
      vertexHighlighted[key] = true;
      inorderHighlightVertex(key);
      //cs["status"] = "Visit vertex with value " + cur + ".<br>And preparing to visit the right child of this vertex.";  //status_inorder_8
      cs["status"] = 'Visit vertex with value {cur}.<br>And preparing to visit the right child of this vertex.'.replace("{cur}", cur);
      cs["lineNo"] = 4;
      sl.push(cs);

      if (curRight == null) {
        vertexTraversed[cur] = true;
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        inorderHighlightVertex(key);
        //cs["status"] = "The right child of vertex with value " + cur + " is empty.<br>Return empty.<br>"; //status_inorder_9
        cs["status"] = '具有值{cur}的节点的右子节点为空。<br>返回空值。<br>'.replace("{cur}", cur);
        cs["lineNo"] = [1, 2];
        sl.push(cs);
      }
      else {
        var curRightClass = iBST[curRight]["vertexClassNumber"];

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        inorderHighlightVertex(key);
        //cs["status"] = "The right child of vertex with value " + cur + " is " + curRight + " (not null).";  //status_inorder_10
        cs["status"] = '具有值{cur}的节点的右子节点是{curRight}（非空）。<br>'.replace("{cur}", cur).replace("{curRight}", curRight);
        cs["lineNo"] = 1;
        sl.push(cs);
        edgeTraversed[curRightClass] = true;
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["el"][curRightClass]["animateHighlighted"] = true;
        inorderHighlightVertex(key);
        cs["status"] = '因此，使用值{curRight}递归并检查节点的右子节点。'.replace("{curRight}", curRight);
        cs["lineNo"] = 3;
        sl.push(cs);
        inorderTraversalRecursion(curRight);
      }

      cs = createState(iBST, vertexTraversed, edgeTraversed);
      if (cur != iBST["root"])
        cs["el"][key]["state"] = EDGE_HIGHLIGHTED;
      inorderHighlightVertex(key);

      //cs["status"] = "In-order traversal of " + cur + " is complete.";  //status_inorder_12
      cs["status"] = '{cur}的中序遍历已完成。'.replace("{cur}", cur);
      cs["lineNo"] = 0;
      sl.push(cs);
    }

    function inorderHighlightVertex(curkey) {
      for (var key in vertexHighlighted) cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
      for (var key in vertexHighlighted) cs["vl"][key]["extratext"] = "";
      cs["vl"][curkey]["extratext"] = "^";
    }
    populatePseudocode(3);
    return true;
  }

  this.insertArr = function(vertexTextArr, callback) {
    var sl = [], vertexTraversed = {}, edgeTraversed = {}, cur = iBST["root"], cs, key, currentVertexClass, i;

    cs = createState(iBST);
    //cs["status"] = "The current BST.";  //status_insert_0
    cs["status"] = '现在的BST';
    cs["lineNo"] = 0;
    sl.push(cs);

    // Check whether input is array
    if (Object.prototype.toString.call(vertexTextArr) != '[object Array]') {
      $('#insert-err').html('请填写数字或用逗号分隔的数组！');
      return false;
    }

    // Loop through all array values and...
    var tempiBST = deepCopy(iBST); // Use this to simulate internal insertion

    for (i = 0; i < vertexTextArr.length; i++) {
      var vt = parseInt(vertexTextArr[i]);

      // 1. Check whether value is number
      if (isNaN(vt)) {
        $('#insert-err').html('请填写数字或用逗号分隔的数组！');
        return false;
      }

      // 2. No duplicates allowed. Also works if more than one similar value are inserted
      if (tempiBST[vt] != null) {
        $('#insert-err').html('不接受重复节点！');
        if (typeof callback == 'function') callback();
        return false;
      }

      // 3. Check range
      if (parseInt(vt) < valueRange[0] || parseInt(vt) > valueRange[1]) {
        $('#insert-err').html('<span style="white-space: normal;">抱歉，只有在 {range1} 到 {range2} 的值可被插入</span><br>'.replace("{range1}", valueRange[0]).replace("{range2}", valueRange[1]));
        return false;
      }

      // 4. Insert the node into temporary internal structure and check for height
      var parentVertex = tempiBST["root"];
      var heightCounter = 0;

      if (parentVertex == null) {
        tempiBST["root"] = parseInt(vt);
        tempiBST[vt] = {
          "parent": null,
          "leftChild": null,
          "rightChild": null
        };
      }
      else {
        while (true) {
          heightCounter++;
          if (parentVertex < vt) {
            if (tempiBST[parentVertex]["rightChild"] == null)
              break;
            parentVertex = tempiBST[parentVertex]["rightChild"];
          }
          else {
            if (tempiBST[parentVertex]["leftChild"] == null)
              break;
            parentVertex = tempiBST[parentVertex]["leftChild"];
          }
        }

        if (parentVertex < vt)
          tempiBST[parentVertex]["rightChild"] = vt;
        else
          tempiBST[parentVertex]["leftChild"] = vt;

        tempiBST[vt] = {
          "parent": parentVertex,
          "leftChild": null,
          "rightChild": null
        }
      }

      heightCounter++; // New vertex added will add new height

      if (heightCounter > maxHeightAllowed+1) {
        $('#insert-err').html('抱歉，此可视化只能支持最大高度为{maxHeight} 的树'.replace("{maxHeight}", maxHeightAllowed));
        if (typeof callback == 'function') callback();
        return false;
      }
    }

    function checkNewHeight() {
      var parentVertex = tempiBST["root"];
      var heightCounter = 0;

      while (parentVertex != null) {
        if (parentVertex < parseInt(val))
          parentVertex = tempiBST[parentVertex]["rightChild"];
        else
          parentVertex = tempiBST[parentVertex]["leftChild"];
        heightCounter++;
      }

      heightCounter++; // New vertex added will add new height

      if (heightCounter > maxHeightAllowed+1)
        return false;
      return true;
    }

    for (i = 0; i < vertexTextArr.length; i++) {
      var val = parseInt(vertexTextArr[i]);

      // Re-initialization
      vertexTraversed = {};
      edgeTraversed = {};
      cur = iBST["root"];
      cs = createState(iBST);

      // Find parent
      while (cur != val && cur != null) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        currentVertexClass = iBST[cur]["vertexClassNumber"];

        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        vertexTraversed[cur] = true;

        //cs["status"] = "Comparing " + val + " with " + cur; //status_insert_1
        cs["status"] = '将{val}与{cur}进行比较'.replace("{val}", val).replace("{cur}", cur);
        if (!isAVL) cs["lineNo"] = 3;
        else        cs["lineNo"] = 1;

        sl.push(cs);

        var nextVertex;
        if (parseInt(val) > parseInt(cur))
          nextVertex = iBST[cur]["rightChild"];
        else
          nextVertex = iBST[cur]["leftChild"];

        if (nextVertex == null)
          break;
        else
          cur = nextVertex;

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        var edgeHighlighted = iBST[cur]["vertexClassNumber"];
        edgeTraversed[edgeHighlighted] = true;

        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;

        if (parseInt(val) > parseInt(iBST[cur]["parent"])) {
          //cs["status"] = val + " is larger than " + iBST[cur]["parent"] + ", so go right."; //status_insert_2
          cs["status"] = '{val}大于{parent}，所以向右。<br>'.replace("{val}", val).replace("{parent}", iBST[cur]["parent"]);
          if (!isAVL) cs["lineNo"] = 5;
          else        cs["lineNo"] = 1;
        }
        else {
          //cs["status"] = val + " is smaller than " + iBST[cur]["parent"] + ", so go left."; //status_insert_3
          cs["status"] = '{val}小于{parent}，所以向左。<br>'.replace("{val}", val).replace("{parent}", iBST[cur]["parent"]);
          if (!isAVL) cs["lineNo"] = 4;
          else        cs["lineNo"] = 1;
        }

        sl.push(cs);
      }

      // Begin insertion
      // First, update internal representation
      iBST[parseInt(val)] = {
        "leftChild": null,
        "rightChild": null,
        "vertexClassNumber": amountVertex
      };

      if (cur != null) {
        iBST[parseInt(val)]["parent"] = cur;
        if (cur < parseInt(val))
          iBST[cur]["rightChild"] = parseInt(val);
        else
          iBST[cur]["leftChild"] = parseInt(val);
      }

      else {
        iBST[parseInt(val)]["parent"] = null;
        iBST["root"] = parseInt(val);
      }

      amountVertex++;
      recalculatePosition();

      // Then, draw edge
      var newNodeVertexClass = iBST[parseInt(val)]["vertexClassNumber"];

      if (cur != null) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["vl"][newNodeVertexClass]["state"] = OBJ_HIDDEN;

        cs["el"][newNodeVertexClass]["state"] = EDGE_TRAVERSED;
        cs["el"][newNodeVertexClass]["animateHighlighted"] = true;

        //cs["status"] = "Location found!<br>Inserting " + val + "."; //status_insert_4
        cs["status"] = '找到位置！<br>插入{val}。'.replace("{val}", val);
        cs["lineNo"] = 1;

        sl.push(cs);

        edgeTraversed[newNodeVertexClass] = true;
      }

      // Lastly, draw vertex
      cs = createState(iBST, vertexTraversed, edgeTraversed);
      cs["vl"][newNodeVertexClass]["state"] = EDGE_HIGHLIGHTED;

      //cs["status"] = val + " has been inserted!"  //status_insert_5
      cs["status"] = '已插入 {val} ！'.replace("{val}", val);
      if (!isAVL) cs["lineNo"] = 2;
      else        cs["lineNo"] = 1;
      sl.push(cs);

      // End State
      cs = createState(iBST);
      //cs["status"] = "Insert " + val + " has been completed." //status_insert_6
      cs["status"] = '插入{val}的操作已完成'.replace("{val}", val);
      if (isAVL) cs["lineNo"] = 1;
      sl.push(cs);

      if (isAVL) {
        recalculateBalanceFactor();

        var vertexCheckBf = iBST[val]["parent"];
        while (vertexCheckBf != null) {
          var vertexCheckBfClass = iBST[vertexCheckBf]["vertexClassNumber"];
          var bf = iBST[vertexCheckBf]["balanceFactor"];

          cs = createState(iBST);
          cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
          //cs["status"] = "Balance factor of " + vertexCheckBf + " is " + bf + ".";  //status_insert_7
          cs["status"] = '{vertexCheckBf} 的平衡因子是 {bf}.'.replace("{vertexCheckBf}", vertexCheckBf).replace("{bf}", bf);
          cs["lineNo"] = 2;
          sl.push(cs);

          if (bf == 2) {
            var vertexCheckBfLeft = iBST[vertexCheckBf]["leftChild"];
            var vertexCheckBfLeftClass = iBST[vertexCheckBfLeft]["vertexClassNumber"];
            var bfLeft = iBST[vertexCheckBfLeft]["balanceFactor"];

            cs = createState(iBST);
            cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
            cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
            //cs["status"] = "And balance factor of " + vertexCheckBfLeft + " is " + bfLeft + ".";  //status_insert_8
            cs["status"] = '然后 {vertexCheckBf} 的平衡因子是 {bf}.'.replace("{vertexCheckBf}", vertexCheckBfLeft).replace("{bf}", bfLeft);
            cs["lineNo"] = 2;
            sl.push(cs);

            if (bfLeft == 1 || bfLeft == 0) {
              rotateRight(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeft)
                cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate right " + vertexCheckBf + "."; //status_insert_9
              cs["status"] = '向右旋转 {vertexCheckBf}.'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 3;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeft)
                cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_insert_10
              cs["status"] = '重新布局搜索树';
              cs["lineNo"] = 3;
              sl.push(cs);
            }
            else if (bfLeft == -1) {
              var vertexCheckBfLeftRight = iBST[vertexCheckBfLeft]["rightChild"];
              var vertexCheckBfLeftRightClass = iBST[vertexCheckBfLeftRight]["vertexClassNumber"];

              rotateLeft(vertexCheckBfLeft);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate left " + vertexCheckBfLeft + ".";  //status_insert_11
              cs["status"] = '向左旋转{vertexCheckBf}。'.replace("{vertexCheckBf}", vertexCheckBfLeft);
              cs["lineNo"] = 4;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_insert_10
              cs["status"] = '重新布局搜索树';
              cs["lineNo"] = 4;
              sl.push(cs);

              rotateRight(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeftRight)
                cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate right " + vertexCheckBf + "."; //status_insert_9
              cs["status"] = '向右旋转 {vertexCheckBf}.'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 4;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeftRight)
                cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_insert_10
              cs["status"] = '重新布局搜索树';
              cs["lineNo"] = 4;
              sl.push(cs);
            }
          }
          else if (bf == -2) {
            var vertexCheckBfRight = iBST[vertexCheckBf]["rightChild"];
            var vertexCheckBfRightClass = iBST[vertexCheckBfRight]["vertexClassNumber"];
            var bfRight = iBST[vertexCheckBfRight]["balanceFactor"];

            cs = createState(iBST);
            cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
            cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
            //cs["status"] = "And balance factor of " + vertexCheckBfRight + " is " + bfRight + ".";  //status_insert_8
            cs["status"] = '然后 {vertexCheckBf} 的平衡因子是 {bf}.'.replace("{vertexCheckBf}", vertexCheckBfRight).replace("{bf}", bfRight);
            cs["lineNo"] = 2;
            sl.push(cs);

            if (bfRight == 1) {
              var vertexCheckBfRightLeft = iBST[vertexCheckBfRight]["leftChild"];
              var vertexCheckBfRightLeftClass = iBST[vertexCheckBfRightLeft]["vertexClassNumber"];

              rotateRight(vertexCheckBfRight);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate right " + vertexCheckBfRight + ".";  //status_insert_9
              cs["status"] = '向右旋转 {vertexCheckBf}.'.replace("{vertexCheckBf}", vertexCheckBfRight);
              cs["lineNo"] = 6;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_insert_10
              cs["status"] = '重新布局搜索树';
              cs["lineNo"] = 6;
              sl.push(cs);

              rotateLeft(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRightLeft)
                cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate left " + vertexCheckBf + ".";  //status_insert_11
              cs["status"] = '向左旋转{vertexCheckBf}。'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 6;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRightLeft)
                cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_insert_10
              cs["status"] = '重新布局搜索树';
              cs["lineNo"] = 6;
              sl.push(cs);
            }
            else if (bfRight == -1 || bfRight == 0) {
              rotateLeft(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRight)
                cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate left " + vertexCheckBf + ".";  //status_insert_11
              cs["status"] = '向左旋转{vertexCheckBf}。'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 5;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);

              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRight)
                cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              cs["status"] = "Relayout the tree.";  //status_insert_10
              cs["status"] = '重新布局搜索树';
              cs["lineNo"] = 5;
              sl.push(cs);
            }
          }

          if (vertexCheckBf != iBST["root"]) {
            cs = createState(iBST);
            cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
            //cs["status"] = "Check the parent vertex.";  //status_insert_12
            cs["status"] = '检查父节点';
            cs["lineNo"] = 2;
            sl.push(cs);
          }

          vertexCheckBf = iBST[vertexCheckBf]["parent"];
        }

        cs = createState(iBST);
        //cs["status"] = "The tree is now balanced."; //status_insert_13
        cs["status"] = '搜索树现在是平衡的了';
        cs["lineNo"] = 7;
        sl.push(cs);
      }
    }

    gw.startAnimation(sl, callback);
    if (isAVL) populatePseudocode(6);
    else       populatePseudocode(0);
    return true;
  }

  this.removeArr = function(vertexTextArr, callback) {
    var sl = [];
    var vertexTraversed = {};
    var edgeTraversed = {};
    var cur = iBST["root"];
    var cs = createState(iBST);
    var currentVertexClass;
    var key;
    var i;

    //cs["status"] = "The current BST"; //status_remove_0
    cs["status"] = '现在的BST';
    cs["lineNo"] = 0;
    sl.push(cs);

    if (Object.prototype.toString.call(vertexTextArr) != '[object Array]') {
      $('#remove-err').html('请填写数字或用逗号分隔的数组！');
      return false;
    }

    // Loop through all array values and...
    for (i = 0; i < vertexTextArr.length; i++) {
      var vt = parseInt(vertexTextArr[i]);

      // Check whether value is number
      if (isNaN(vt)) {
        $('#remove-err').html('请填写数字或用逗号分隔的数组！');
        return false;
      }
      // Other checks not required
    }

    for (i = 0; i < vertexTextArr.length; i++) {
      var val = parseInt(vertexTextArr[i]);
      var vertexCheckBf;

      // Re-initialization
      vertexTraversed = {};
      edgeTraversed = {};
      cur = iBST["root"];
      cs = createState(iBST);

      // Find vertex
      while (cur != val && cur != null) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        currentVertexClass = iBST[cur]["vertexClassNumber"];

        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        vertexTraversed[cur] = true;

        //cs["status"] = "Searching for node " + val + " to remove";  //status_remove_1
        cs["status"] = '搜索并删除节点{val}<br>'.replace("{val}", val);
        cs["lineNo"] = 1;
        sl.push(cs);

        if (parseInt(val) > parseInt(cur))
          cur = iBST[cur]["rightChild"];
        else
          cur = iBST[cur]["leftChild"];

        if (cur == null) break;

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        var edgeHighlighted = iBST[cur]["vertexClassNumber"];
        edgeTraversed[edgeHighlighted] = true;

        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;

        //cs["status"] = "Searching for node " + val + " to remove";  //status_remove_1
        cs["status"] = '搜索并删除节点{val}<br>'.replace("{val}", val);
        cs["lineNo"] = 1;
        sl.push(cs);
      }

      if (cur != null) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        currentVertexClass = iBST[cur]["vertexClassNumber"];

        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        //cs["status"] = "Searching for node " + val + " to remove";  //status_remove_1
        cs["status"] = '搜索并删除节点{val}<br>'.replace("{val}", val);
        cs["lineNo"] = 1;
        sl.push(cs);
      }
      // Vertex is not inside the tree
      else {
        cs = createState(iBST);
        //cs["status"] = "Node " + val + " is not in the BST";  //status_remove_2
        cs["status"] = '节点{val}不在BST<br>'.replace("{val}", val);
        cs["lineNo"] = 0; //Node {val} is not in the BST
        sl.push(cs);
        continue;
      }

      // Vertex found; begin deletion
      // Case 1: no child
      if (iBST[cur]["leftChild"] == null && iBST[cur]["rightChild"] == null) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        //cs["status"] = "Node " + val + " has no children. It is a leaf."; //status_remove_3
        cs["status"] = '节点{val}没有子节点。 它是叶节点。'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 2;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        var parentVertex = iBST[cur]["parent"];

        if (parentVertex != null) {
          if (parseInt(parentVertex) < parseInt(cur))
            iBST[parentVertex]["rightChild"] = null;
          else
            iBST[parentVertex]["leftChild"] = null;
        }
        else
          iBST["root"] = null;

        currentVertexClass = iBST[cur]["vertexClassNumber"];
        delete iBST[cur];
        delete vertexTraversed[cur];
        delete edgeTraversed[currentVertexClass];

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        //cs["status"] = "Remove leaf " + val;  //status_remove_4
        cs["status"] = '删除叶节点{val}'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 3;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        vertexCheckBf = parentVertex;
      }
      // Case 2: One child
      else if (iBST[cur]["leftChild"] == null) { // Only right child
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        //cs["status"] = "Node " + val + " has a right child only"; //status_remove_5
        cs["status"] = '节点{val}只有一个右子节点'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 4;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        var parentVertex = iBST[cur]["parent"];
        var rightChildVertex = iBST[cur]["rightChild"];

        if (parentVertex != null) {
          if (parseInt(parentVertex) < parseInt(cur))
            iBST[parentVertex]["rightChild"] = rightChildVertex;
          else
            iBST[parentVertex]["leftChild"] = rightChildVertex;
        }
        else
          iBST["root"] = rightChildVertex;

        iBST[rightChildVertex]["parent"] = parentVertex;

        currentVertexClass = iBST[cur]["vertexClassNumber"];
        rightChildVertexClass = iBST[rightChildVertex]["vertexClassNumber"];
        delete iBST[cur];
        delete vertexTraversed[cur];
        delete edgeTraversed[currentVertexClass];

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        cs["vl"][rightChildVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        if (parentVertex != null)
          cs["el"][rightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

        //cs["status"] = "Delete node " + val + " and connect its parent to its right child"; //status_remove_6
        cs["status"] = '删除节点{val}并将其父节点连接到其右子节点'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 5;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        recalculatePosition();

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        cs["vl"][rightChildVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        if (parentVertex != null)
          cs["el"][rightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

        //cs["status"] = "Re-layout the tree";  //status_remove_7
        cs["status"] = '重新布局搜索树<br>';
        if (!isAVL) cs["lineNo"] = 5;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        vertexCheckBf = rightChildVertex;
      }
      else if (iBST[cur]["rightChild"] == null) { // Only left child
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        //cs["status"] = "Node " + val + " has a left child only";  //status_remove_8
        cs["status"] = '节点{val}只有一个左子节点'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 4;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        var parentVertex = iBST[cur]["parent"];
        var leftChildVertex = iBST[cur]["leftChild"];

        if (parentVertex != null) {
          if (parseInt(parentVertex) < parseInt(cur))
            iBST[parentVertex]["rightChild"] = leftChildVertex;
          else
            iBST[parentVertex]["leftChild"] = leftChildVertex;
        }
        else
          iBST["root"] = leftChildVertex;

        iBST[leftChildVertex]["parent"] = parentVertex;

        currentVertexClass = iBST[cur]["vertexClassNumber"];
        leftChildVertexClass = iBST[leftChildVertex]["vertexClassNumber"];
        delete iBST[cur];
        delete vertexTraversed[cur];
        delete edgeTraversed[currentVertexClass];

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        cs["vl"][leftChildVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        if (parentVertex != null)
          cs["el"][leftChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

        //cs["status"] = "Delete node " + val + " and connect its parent to its left child";  //status_remove_9
        cs["status"] = '删除节点{val}并将其父节点连接到其左子节点'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 5;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        recalculatePosition();

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        cs["vl"][leftChildVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        if (parentVertex != null)
          cs["el"][leftChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

        //cs["status"] = "Re-layout the tree";  //status_remove_7
        cs["status"] = '重新布局搜索树<br>';
        if (!isAVL) cs["lineNo"] = 5;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        vertexCheckBf = leftChildVertex;
      }
      else { // Case 3: two children
        var parentVertex = iBST[cur]["parent"];
        var leftChildVertex = iBST[cur]["leftChild"];
        var rightChildVertex = iBST[cur]["rightChild"];
        var successorVertex = iBST[cur]["rightChild"];
        var successorVertexClass = iBST[successorVertex]["vertexClassNumber"];

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        cs["el"][successorVertexClass]["state"] = EDGE_TRAVERSED;
        cs["el"][successorVertexClass]["animateHighlighted"] = true;

        //cs["status"] = "Finding successor of " + val; //status_remove_10
        cs["status"] = '寻找 {val} 的后继'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 6;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        edgeTraversed[successorVertexClass] = true;
        vertexTraversed[successorVertex] = true;

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][successorVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        //cs["status"] = "Finding successor of " + val; //status_remove_10
        cs["status"] = '寻找 {val} 的后继'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 6;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        while (iBST[successorVertex]["leftChild"] != null) {
          successorVertex = iBST[successorVertex]["leftChild"];
          successorVertexClass = iBST[successorVertex]["vertexClassNumber"];

          cs = createState(iBST, vertexTraversed, edgeTraversed);

          cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

          cs["el"][successorVertexClass]["state"] = EDGE_TRAVERSED;
          cs["el"][successorVertexClass]["animateHighlighted"] = true;

          //cs["status"] = "Finding successor of " + val; //status_remove_10
          cs["status"] = '寻找 {val} 的后继'.replace("{val}", val);
          if (!isAVL) cs["lineNo"] = 6;
          else        cs["lineNo"] = 1;
          sl.push(cs);

          edgeTraversed[successorVertexClass] = true;
          vertexTraversed[successorVertex] = true;

          cs = createState(iBST, vertexTraversed, edgeTraversed);

          cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
          cs["vl"][successorVertexClass]["state"] = VERTEX_HIGHLIGHTED;

          //cs["status"] = "Finding successor of " + val; //status_remove_10
          cs["status"] = '寻找 {val} 的后继'.replace("{val}", val);
          if (!isAVL) cs["lineNo"] = 6;
          else        cs["lineNo"] = 1;
          sl.push(cs);
        }

        var successorParentVertex = iBST[successorVertex]["parent"]
        var successorRightChildVertex = iBST[successorVertex]["rightChild"];

        // Update internal representation
        if (parentVertex != null) {
          if (parseInt(parentVertex) < parseInt(cur))
            iBST[parentVertex]["rightChild"] = successorVertex;
          else
            iBST[parentVertex]["leftChild"] = successorVertex;
        }
        else
          iBST["root"] = successorVertex;

        iBST[successorVertex]["parent"] = parentVertex;
        iBST[successorVertex]["leftChild"] = leftChildVertex;

        iBST[leftChildVertex]["parent"] = successorVertex;

        if (successorVertex != rightChildVertex) {
          iBST[successorVertex]["rightChild"] = rightChildVertex;
          iBST[rightChildVertex]["parent"] = successorVertex;

          if (successorRightChildVertex != null) {
            if (parseInt(successorParentVertex) < parseInt(successorVertex))
              iBST[successorParentVertex]["rightChild"] = successorRightChildVertex;
            else
              iBST[successorParentVertex]["leftChild"] = successorRightChildVertex;
            iBST[successorRightChildVertex]["parent"] = successorParentVertex;
          }
          else {
            if (parseInt(successorParentVertex) < parseInt(successorVertex))
              iBST[successorParentVertex]["rightChild"] = null;
            else
              iBST[successorParentVertex]["leftChild"] = null;
          }
        }

        delete iBST[cur];
        delete vertexTraversed[cur];
        delete edgeTraversed[currentVertexClass];

        if (parentVertex == null)
          delete edgeTraversed[successorVertexClass];

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        var leftChildVertexClass = iBST[leftChildVertex]["vertexClassNumber"];

        cs["vl"][successorVertexClass]["state"] = VERTEX_HIGHLIGHTED;
        cs["el"][leftChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

        if (parentVertex != null) {
          var parentVertexClass = iBST[parentVertex]["vertexClassNumber"];
          cs["el"][successorVertexClass]["state"] = EDGE_HIGHLIGHTED;
        }

        if (successorVertex != rightChildVertex) {
          var rightChildVertexClass = iBST[rightChildVertex]["vertexClassNumber"];
          cs["el"][rightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

          if (successorRightChildVertex != null) {
            var successorRightChildVertexClass = iBST[successorRightChildVertex]["vertexClassNumber"];
            cs["el"][successorRightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;
          }
        }

        //cs["status"] = "Replace node " + val + " with its successor"; //status_remove_11
        cs["status"] = '将节点{val}替换为其后继节点'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 6;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        recalculatePosition();

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        leftChildVertexClass = iBST[leftChildVertex]["vertexClassNumber"];

        cs["vl"][successorVertexClass]["state"] = VERTEX_HIGHLIGHTED;
        cs["el"][leftChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

        if (parentVertex != null) {
          var parentVertexClass = iBST[parentVertex]["vertexClassNumber"];
          cs["el"][successorVertexClass]["state"] = EDGE_HIGHLIGHTED;
        }

        if (successorVertex != rightChildVertex) {
          var rightChildVertexClass = iBST[rightChildVertex]["vertexClassNumber"];
          cs["el"][rightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

          if (successorRightChildVertex != null) {
            var successorRightChildVertexClass = iBST[successorRightChildVertex]["vertexClassNumber"];
            cs["el"][successorRightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;
          }
        }

        //cs["status"] = "Re-layout the tree";  //status_remove_7
        cs["status"] = '重新布局搜索树<br>';
        if (!isAVL) cs["lineNo"] = 6;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        vertexCheckBf = successorVertex;
        if (successorVertex != rightChildVertex)
          vertexCheckBf = successorParentVertex;
      }

      cs = createState(iBST);
      //cs["status"] = "Removal of " + val + " completed";  //status_remove_12
      cs["status"] = '移除{val}的操作完成'.replace("{val}", val);
      if (!isAVL) cs["lineNo"] = 0;
      else        cs["lineNo"] = 1;
      sl.push(cs);

      if (isAVL) {
        recalculateBalanceFactor();
        // console.log(iBST);

        while (vertexCheckBf != null) {
          var vertexCheckBfClass = iBST[vertexCheckBf]["vertexClassNumber"];

          var bf = iBST[vertexCheckBf]["balanceFactor"];

          cs = createState(iBST);
          cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
          //cs["status"] = "Balance factor of " + vertexCheckBf + " is " + bf + ".";  //status_remove_13
          cs["status"] = '{vertexCheckBf}的平衡因子是{bf}。<br>'.replace("{vertexCheckBf}", vertexCheckBf).replace("{bf}", bf);
          cs["lineNo"] = 2;
          sl.push(cs);

          if (bf == 2) {
            var vertexCheckBfLeft = iBST[vertexCheckBf]["leftChild"];
            var vertexCheckBfLeftClass = iBST[vertexCheckBfLeft]["vertexClassNumber"];
            var bfLeft = iBST[vertexCheckBfLeft]["balanceFactor"];

            cs = createState(iBST);
            cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
            cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
            //cs["status"] = "And balance factor of " + vertexCheckBfLeft + " is " + bfLeft + ".";  //status_remove_14
            cs["status"] = '{vertexCheckBf}的平衡因子是{bf}。'.replace("{vertexCheckBfLeft}", vertexCheckBf).replace("{bfLeft}", bf);
            cs["lineNo"] = 2;
            sl.push(cs);

            if (bfLeft == 1 || bfLeft == 0) {
              rotateRight(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeft)
                cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate right " + vertexCheckBf + "."; //status_remove_15
              cs["status"] = '向右旋转{vertexCheckBf}。<br>'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 3;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeft)
                cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_remove_7
              cs["status"] = '重新布局搜索树<br>';
              cs["lineNo"] = 3;
              sl.push(cs);
            }
            else if (bfLeft == -1) {
              var vertexCheckBfLeftRight = iBST[vertexCheckBfLeft]["rightChild"];
              var vertexCheckBfLeftRightClass = iBST[vertexCheckBfLeftRight]["vertexClassNumber"];

              rotateLeft(vertexCheckBfLeft);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate left " + vertexCheckBfLeft + ".";  //status_remove_16
              cs["status"] = '向左旋转{vertexCheckBf}。'.replace("{vertexCheckBf}", vertexCheckBfLeft);
              cs["lineNo"] = 4;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_remove_7
              cs["status"] = '重新布局搜索树<br>';
              cs["lineNo"] = 4;
              sl.push(cs);

              rotateRight(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeftRight)
                cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate right " + vertexCheckBf + "."; //status_remove_15
              cs["status"] = '向右旋转{vertexCheckBf}。<br>'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 4;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeftRight)
                cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_remove_7
              cs["status"] = '重新布局搜索树<br>';
              cs["lineNo"] = 4;
              sl.push(cs);
            }
          }
          else if (bf == -2) {
            var vertexCheckBfRight = iBST[vertexCheckBf]["rightChild"];
            var vertexCheckBfRightClass = iBST[vertexCheckBfRight]["vertexClassNumber"];
            var bfRight = iBST[vertexCheckBfRight]["balanceFactor"];

            cs = createState(iBST);
            cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
            cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
            //cs["status"] = "And balance factor of " + vertexCheckBfRight + " is " + bfRight + ".";  //status_remove_14
            cs["status"] = '{vertexCheckBf}的平衡因子是{bf}。'.replace("{vertexCheckBf}", vertexCheckBfRight).replace("{bf}", bfRight);
            cs["lineNo"] = 2;
            sl.push(cs);

            if (bfRight == 1) {
              var vertexCheckBfRightLeft = iBST[vertexCheckBfRight]["leftChild"];
              var vertexCheckBfRightLeftClass = iBST[vertexCheckBfRightLeft]["vertexClassNumber"];

              rotateRight(vertexCheckBfRight);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate right " + vertexCheckBfRight + ".";  //status_remove_15
              cs["status"] = '向右旋转{vertexCheckBf}。<br>'.replace("{vertexCheckBf}", vertexCheckBfRight);
              cs["lineNo"] = 6;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_remove_7
              cs["status"] = '重新布局搜索树<br>';
              cs["lineNo"] = 6;
              sl.push(cs);

              rotateLeft(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRightLeft)
                cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate left " + vertexCheckBf + ".";  //status_remove_16
              cs["status"] = '向左旋转{vertexCheckBf}。'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 6;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRightLeft)
                cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_remove_7
              cs["status"] = '重新布局搜索树<br>';
              cs["lineNo"] = 6;
              sl.push(cs);
            }
            else if (bfRight == -1 || bfRight == 0) {
              rotateLeft(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRight)
                cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate left " + vertexCheckBf + ".";  //status_remove_16
              cs["status"] = '向左旋转{vertexCheckBf}。'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 5;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);

              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRight)
                cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_remove_7
              cs["status"] = '重新布局搜索树<br>';
              cs["lineNo"] = 5;
              sl.push(cs);
            }
          }

          if (vertexCheckBf != iBST["root"]) {
            cs = createState(iBST);
            cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
            //cs["status"] = "Check the parent vertex...";  //status_remove_17
            cs["status"] = '检查父节点...';
            cs["lineNo"] = 2;
            sl.push(cs);
          }

          vertexCheckBf = iBST[vertexCheckBf]["parent"];
        }

        cs = createState(iBST);
        cs["status"] = '搜索树现在是平衡的了。';
        cs["lineNo"] = 7;
        sl.push(cs);
      }
    }

    gw.startAnimation(sl, callback);
    if (isAVL) populatePseudocode(7);
    else       populatePseudocode(5);
    return true;
  };

  function init(initArr) {
    var i;

    clearScreen();

    for (i = 0; i < initArr.length; i++) {
      var parentVertex = iBST["root"];
      var newVertex = parseInt(initArr[i]);

      if (parentVertex == null) {
        iBST["root"] = parseInt(newVertex);
        iBST[newVertex] = {
          "parent": null,
          "leftChild": null,
          "rightChild": null,
          "vertexClassNumber": amountVertex
        };
      }
      else {
        while (true) {
          if (parentVertex < newVertex) {
            if (iBST[parentVertex]["rightChild"] == null) break;
            parentVertex = iBST[parentVertex]["rightChild"];
          }
          else {
            if (iBST[parentVertex]["leftChild"] == null) break;
            parentVertex = iBST[parentVertex]["leftChild"];
          }
        }

        if (parentVertex < newVertex)
          iBST[parentVertex]["rightChild"] = newVertex;
        else
          iBST[parentVertex]["leftChild"] = newVertex;

        iBST[newVertex] = {
          "parent": parentVertex,
          "leftChild": null,
          "rightChild": null,
          "vertexClassNumber": amountVertex
        }
      }

      amountVertex++;
    }

    recalculatePosition();

    for (key in iBST) {
      if (key == "root") continue;
      gw.addVertex(iBST[key]["cx"], iBST[key]["cy"], key, iBST[key]["vertexClassNumber"], true);
    }

    for (key in iBST) {
      if (key == "root") continue;
      if (key == iBST["root"]) continue;
      var parentVertex = iBST[key]["parent"];
      gw.addEdge(iBST[parentVertex]["vertexClassNumber"], iBST[key]["vertexClassNumber"], iBST[key]["vertexClassNumber"], EDGE_TYPE_UDE, 1, true);
    }
  }

  function clearScreen() {
    var key;

    for (key in iBST) {
      if (key == "root") continue;
      gw.removeEdge(iBST[key]["vertexClassNumber"]);
    }

    for (key in iBST) {
      if (key == "root") continue;
      gw.removeVertex(iBST[key]["vertexClassNumber"]);
    }

    iBST = {};
    iBST["root"] = null;
    amountVertex = 0;
  }

  // Pseudocode for rotateLeft:
  /*
   * BSTVertex rotateLeft(BSTVertex T) // pre-req: T.right != null
   * BSTVertex w = T.right
   * w.parent = T.parent
   * T.parent = w
   * T.right = w.left
   * if (w.left != null) w.left.parent = T
   * w.left = T
   * // Update the height of T and then w
   * return w
   */

  function rotateLeft(val) {
    // Refer to pseudocode

    var t = parseInt(val);
    var w = iBST[t]["rightChild"];

    iBST[w]["parent"] = iBST[t]["parent"];
    if (iBST[t]["parent"] != null) {
      if (iBST[t]["parent"] < t) {
        var tParent = iBST[t]["parent"];
        iBST[tParent]["rightChild"] = w;
      }
      else {
        var tParent = iBST[t]["parent"];
        iBST[tParent]["leftChild"] = w;
      }
    }

    iBST[t]["parent"] = w;
    iBST[t]["rightChild"] = iBST[w]["leftChild"];
    if (iBST[w]["leftChild"] != null)
      iBST[iBST[w]["leftChild"]]["parent"] = t;
    iBST[w]["leftChild"] = t;

    if (t == iBST["root"])
      iBST["root"] = w;

    recalculateBalanceFactor();
  }

  function rotateRight(val) {
    // Refer to pseudocode

    var t = parseInt(val);
    var w = iBST[t]["leftChild"];

    iBST[w]["parent"] = iBST[t]["parent"];
    if (iBST[t]["parent"] != null) {
      if (iBST[t]["parent"] < t) {
        var tParent = iBST[t]["parent"];
        iBST[tParent]["rightChild"] = w;
      }
      else {
        var tParent = iBST[t]["parent"];
        iBST[tParent]["leftChild"] = w;
      }
    }

    iBST[t]["parent"] = w;
    iBST[t]["leftChild"] = iBST[w]["rightChild"];
    if (iBST[w]["rightChild"] != null)
      iBST[iBST[w]["rightChild"]]["parent"] = t;
    iBST[w]["rightChild"] = t;

    if (t == iBST["root"])
      iBST["root"] = w;

    recalculateBalanceFactor();
  }

  /*
   * iBSTObject: a JS object with the same structure of iBST. This means the BST doen't have to be the BST stored in this class
   * vertexTraversed: JS object with the vertexes of the BST which are to be marked as traversed as the key
   * edgeTraversed: JS object with the edges of the BST which are to be marked as traversed as the key
   */

  function createState(iBSTObject, vertexTraversed, edgeTraversed) {
    if (vertexTraversed == null || vertexTraversed == undefined || !(vertexTraversed instanceof Object))
      vertexTraversed = {};
    if (edgeTraversed == null || edgeTraversed == undefined || !(edgeTraversed instanceof Object))
      edgeTraversed = {};

    var state = {
      "vl": {},
      "el": {}
    };

    var key;
    var vertexClass;

    // something may be inconsistent during remove (AVL?), generates mini D3 error..., hunt for that bug
    for (key in iBSTObject) {
      if (key == "root") continue;

      vertexClass = iBSTObject[key]["vertexClassNumber"]

      state["vl"][vertexClass] = {};
      state["vl"][vertexClass]["cx"] = iBSTObject[key]["cx"];
      state["vl"][vertexClass]["cy"] = iBSTObject[key]["cy"];
      state["vl"][vertexClass]["text"] = key;
      state["vl"][vertexClass]["state"] = VERTEX_DEFAULT;

      if (iBSTObject[key]["parent"] == null) continue;

      parentChildEdgeId = iBSTObject[key]["vertexClassNumber"];

      state["el"][parentChildEdgeId] = {};
      state["el"][parentChildEdgeId]["vertexA"] = iBSTObject[iBSTObject[key]["parent"]]["vertexClassNumber"];
      state["el"][parentChildEdgeId]["vertexB"] = iBSTObject[key]["vertexClassNumber"];
      state["el"][parentChildEdgeId]["type"] = EDGE_TYPE_UDE;
      state["el"][parentChildEdgeId]["weight"] = 1;
      state["el"][parentChildEdgeId]["state"] = EDGE_DEFAULT;
      state["el"][parentChildEdgeId]["animateHighlighted"] = false;
    }

    for (key in vertexTraversed) {
      vertexClass = iBSTObject[key]["vertexClassNumber"];
      state["vl"][vertexClass]["state"] = VERTEX_TRAVERSED;
    }

    for (key in edgeTraversed) {
      state["el"][key]["state"] = EDGE_TRAVERSED;
    }

    return state;
  }

  function recalculatePosition() {
    calcHeight(iBST["root"], 0);
    updatePosition(iBST["root"]);

    function calcHeight(cur, currentHeight) {
      if (cur == null) return;
      iBST[cur]["height"] = currentHeight;
      calcHeight(iBST[cur]["leftChild"], currentHeight+1);
      calcHeight(iBST[cur]["rightChild"], currentHeight+1);
    }

    function updatePosition(cur) {
      if (cur == null) return;

      if (cur == iBST["root"])
        iBST[cur]["cx"] = MAIN_SVG_WIDTH/2;
      else {
        var i;
        var xAxisOffset = MAIN_SVG_WIDTH/2-16;
        var parentVertex = iBST[cur]["parent"]
        for (i = 0; i < iBST[cur]["height"]; i++) xAxisOffset /= 2;

        if (parseInt(cur) > parseInt(parentVertex))
          iBST[cur]["cx"] = iBST[parentVertex]["cx"]+xAxisOffset;
        else
          iBST[cur]["cx"] = iBST[parentVertex]["cx"]-xAxisOffset;
      }

      iBST[cur]["cy"] = 50 + 50*iBST[cur]["height"];
      updatePosition(iBST[cur]["leftChild"]);
      updatePosition(iBST[cur]["rightChild"]);
    }
  }

  function recalculateBalanceFactor() {
    balanceFactorRecursion(iBST["root"]);

    function balanceFactorRecursion(val) {
      if (val == null) return -1;

      var balanceFactorHeightLeft = balanceFactorRecursion(iBST[val]["leftChild"]);
      var balanceFactorHeightRight = balanceFactorRecursion(iBST[val]["rightChild"]);

      iBST[val]["balanceFactorHeight"] = Math.max(balanceFactorHeightLeft, balanceFactorHeightRight) + 1;
      iBST[val]["balanceFactor"] = balanceFactorHeightLeft - balanceFactorHeightRight;

      return iBST[val]["balanceFactorHeight"];
    }
  }

  // 1: Max
  // 2: Min
  function populatePseudocode(act) {
    switch (act) {
      case 1: // findMinMax
      case 2:
        //$('#code1').html('if this is null return empty'); // code_minmax_1
        $('#code1').html('if this is null return empty');
        if (act == 1) {
          //$('#code2').html('if right != null'); // code_max_2
          //$('#code3').html('&nbsp&nbspgo right'); // code_max_3
          $('#code2').html('if right != null');
          $('#code3').html('&nbsp&nbspgo right');
        }
        else {
          //$('#code2').html('if left != null');  // code_min_2
          //$('#code3').html('&nbsp;&nbsp;go left');  // code_min_3
          $('#code2').html('if left != null');
          $('#code3').html('&nbsp;&nbsp;go left');
        }
        //$('#code4').html('else return this key'); // code_minmax_4
        $('#code4').html('else return this key');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 4: // search
        //$('#code1').html('if this == null');  //code_search_1
        $('#code1').html('if this == null');
        //$('#code2').html('&nbsp;&nbsp;return null');  //code_search_2
        $('#code2').html('&nbsp;&nbsp;return null');
        //$('#code3').html('else if this key == search value'); //code_search_3
        $('#code3').html('else if this key == search value');
        //$('#code4').html('&nbsp;&nbsp;return this');  //code_search_4
        $('#code4').html('&nbsp;&nbsp;return this');
        //$('#code5').html('else if this key < search value');  //code_search_5
        $('#code5').html('else if this key < search value');
        //$('#code6').html('&nbsp;&nbsp;search right'); //code_search_6
        $('#code6').html('&nbsp;&nbsp;search right');
        //$('#code7').html('else search left'); //code_search_7
        $('#code7').html('else search left');
        break;
      case 0: // Insert
        //$('#code1').html('if insertion point is found');  //code_insert_1
        $('#code1').html('if insertion point is found');
        //$('#code2').html('&nbsp;&nbsp;create new vertex');  //code_insert_2
        $('#code2').html('创建新的顶点<div><br></div>');
        //$('#code3').html('if value to be inserted < this key'); //code_insert_3
        $('#code3').html('if value to be inserted < this key');
        //$('#code4').html('&nbsp;&nbsp;go left');  //code_insert_4
        $('#code4').html('&nbsp;&nbsp;go left');
        //$('#code5').html('else go right');  //code_insert_5
        $('#code5').html('else go right');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 5: // remove
        //$('#code1').html('search for v'); //code_remove_1
        $('#code1').html('查找V');
        //$('#code2').html('if v is a leaf'); //code_remove_2
        $('#code2').html('if v is a leaf');
        //$('#code3').html('&nbsp;&nbsp;delete leaf v');  //code_remove_3
        $('#code3').html('&nbsp;&nbsp;delete leaf v');
        //$('#code4').html('else if v has 1 child');  //code_remove_4
        $('#code4').html('else if v has 1 child');
        //$('#code5').html('&nbsp;&nbsp;bypass v'); //code_remove_5
        $('#code5').html('&nbsp;&nbsp;bypass v');
        //$('#code6').html('else replace v with successor');  //code_remove_6
        $('#code6').html('else replace v with successor');
        $('#code7').html('');
        break;
      case 6: // insert with rotations
      case 7: // remove with rotations
        if (act == 6) {
          //$('#code1').html('insert v'); //code_insert_avl_1
          $('#code1').html('insert v');
        } else {
          //$('#code1').html('remove v'); //code_remove_avl_1
          $('#code1').html('remove v');
        }
        //$('#code2').html('check balance factor of this and its children');  //code_avl_2
        $('#code2').html('check balance factor of this and its children');
        //$('#code3').html('&nbsp;&nbsp;case1: this.rotateRight');  //code_avl_3
        $('#code3').html('&nbsp;&nbsp;case1: this.rotateRight');
        //$('#code4').html('&nbsp;&nbsp;case2: this.left.rotateLeft, this.rotateRight');  //code_avl_4
        $('#code4').html('&nbsp;&nbsp;case2: this.left.rotateLeft, this.rotateRight');
        //$('#code5').html('&nbsp;&nbsp;case3: this.rotateLeft'); //code_avl_5
        $('#code5').html('&nbsp;&nbsp;case3: this.rotateLeft ');
        //$('#code6').html('&nbsp;&nbsp;case4: this.right.rotateRight, this.rotateLeft'); //code_avl_6
        $('#code6').html('&nbsp;&nbsp;case4: this.right.rotateRight, this.rotateLeft ');
        //$('#code7').html('&nbsp;&nbsp;this is balanced'); //code_avl_7
        $('#code7').html('这个是平衡的');
        break;
      case 8: // successor
      case 9: // predecessor
        if (act == 8) {
          //$('#code1').html('if this.right != null return findMin(this.right)'); //code_successor_1
          //$('#code4').html('&nbsp;&nbsp;while(p != null && T == p.right)'); //code_successor_4
          $('#code1').html('if this.right != null return findMin(this.right) ');
          $('#code4').html('&nbsp;&nbsp;while(p != null &amp;&amp; T == p.right) ');
        }
        else {
          //$('#code1').html('if this.left != null return findMax(this.left)'); //code_predecessor_1
          //$('#code4').html('&nbsp;&nbsp;while(p != null && T == p.left)');  //code_predecessor_4
          $('#code1').html('if this.left != null return findMax(this.left) ');
          $('#code4').html('&nbsp;&nbsp;while(p != null &amp;&amp; T == p.left) ');
        }
        //$('#code2').html('else'); //code_predsucc_2
        $('#code2').html('else ');
        //$('#code3').html('&nbsp;&nbsp;p = this.parent, T = this');  //code_predsucc_3
        $('#code3').html('&nbsp;&nbsp;p = this.parent, T = this');
        //$('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;T = p, p = T.parent');  //code_predsucc_5
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;T = p, p = T.parent');
        //$('#code6').html('&nbsp;&nbsp;if p is null return -1'); //code_predsucc_6
        $('#code6').html('如果P等于null返回-1');
        //$('#code7').html('&nbsp;&nbsp;else return p');  //code_predsucc_7
        $('#code7').html('否则返回P');
        break;
      case 3: // inorder traversal
        //$('#code1').html('if this is null');  //code_inorder_1
        $('#code1').html('如果这是null');
        //$('#code2').html('&nbsp;&nbsp;return'); //code_inorder_2
        $('#code2').html('返回');
        //$('#code3').html('inOrder(left)');  //code_inorder_3
        $('#code3').html('inOrder(left)');
        //$('#code4').html('visit this, then inOrder(right)');  //code_inorder_4
        $('#code4').html('访问这个，然后inOrder(right)');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
    }
  }
}



// BSTaction.js
var actionsWidth = 150;
var statusCodetraceWidth = 420;

var isCreateOpen = false, isSearchOpen = false, isInsertOpen = false, isRemoveOpen = false, isPredSuccOpen = false, isInorderOpen = false;

function openCreate() {
  if (!isCreateOpen) {
    $('.create').fadeIn('fast');
    isCreateOpen = true;
  }
}

function closeCreate() {
  if (isCreateOpen) {
    $('.create').fadeOut('fast');
    $('#create-err').html("");
    isCreateOpen = false;
  }
}

function openSearch() {
  if (!isSearchOpen) {
    $('.search').fadeIn('fast');
    isSearchOpen = true;
  }
}

function closeSearch() {
  if (isSearchOpen) {
    $('.search').fadeOut('fast');
    $('#search-err').html("");
    isSearchOpen = false;
  }
}

function openInsert() {
  if (!isInsertOpen) {
    $('.insert').fadeIn('fast');
    isInsertOpen = true;
  }
}

function closeInsert() {
  if (isInsertOpen) {
    $('.insert').fadeOut('fast');
    $('#insert-err').html("");
    isInsertOpen = false;
  }
}

function openRemove() {
  if (!isRemoveOpen) {
    $('.remove').fadeIn('fast');
    isRemoveOpen = true;
  }
}

function closeRemove() {
  if (isRemoveOpen) {
    $('.remove').fadeOut('fast');
    $('#remove-err').html("");
    isRemoveOpen = false;
  }
}

function openPredSucc() {
  if (!isPredSuccOpen) {
    $('.predsucc').fadeIn('fast');
    isPredSuccOpen = true;
  }
}

function closePredSucc() {
  if (isPredSuccOpen) {
    $('.predsucc').fadeOut('fast');
    $('#predsucc-err').html("");
    isPredSuccOpen = false;
  }
}

function openInorder() {
  if (!isInorderOpen) {
    $('.inorder').fadeIn('fast');
    isInorderOpen = true;
  }
}

function closeInorder() {
  if (isInorderOpen) {
    $('.inorder').fadeOut('fast');
    isInorderOpen = false;
  }
}

function hideEntireActionsPanel() {
  closeCreate();
  closeSearch();
  closeInsert();
  closeRemove();
  closePredSucc();
  closeInorder();
  hideActionsPanel();
}


// local
var bw, gw;

$(function() {
  $('#play').hide();
  bw = new BST();
  gw = bw.getGraphWidget();
  bw.generateRandom();

  var bstMode = getQueryVariable("mode");
  if (bstMode.length > 0)
    $('#title-' + bstMode).click();
  var createBST = getQueryVariable("create");
  if (createBST.length > 0) {
    var newBST = createBST.split(",");
    bw.generate(newBST);
  }

  $('#create').click(function() {
    openCreate();
    closeSearch();
    closeInsert();
    closeRemove();
    closePredSucc();
    closeInorder();
  });
  $('#search').click(function() {
    closeCreate();
    openSearch();
    closeInsert();
    closeRemove();
    closePredSucc();
    closeInorder();
  });
  $('#insert').click(function() {
    closeCreate();
    closeSearch();
    openInsert();
    closeRemove();
    closePredSucc();
    closeInorder();
  });
  $('#remove').click(function() {
    closeCreate();
    closeSearch();
    closeInsert();
    openRemove();
    closePredSucc();
    closeInorder();
  });
  $('#predsucc').click(function() {
    closeCreate();
    closeSearch();
    closeInsert();
    closeRemove();
    openPredSucc();
    closeInorder();
  });
  $('#inorder').click(function() {
    closeCreate();
    closeSearch();
    closeInsert();
    closeRemove();
    closePredSucc();
    openInorder();
  });
});

// title changing
$('#title-BST').click(function() {
  if (isPlaying) stop();
  showActionsPanel();
  hideStatusPanel();
  hideCodetracePanel();
  bw.isAVL(false);
});

$('#title-AVL').click(function() {
  if (isPlaying) stop();
  showActionsPanel();
  hideStatusPanel();
  hideCodetracePanel();
  bw.isAVL(true);
});

function empty() {
  if (isPlaying) stop();
  setTimeout(function() {
    if (bw.generateEmpty()) { // (mode == "exploration") && 
      $('#progress-bar').slider("option", "max", 0);
      closeCreate();
      isPlaying = false;
    }
  }, 500);
}

function example(id) {
  if (isPlaying) stop();
  setTimeout(function() {
    if (bw.generateExample(id)) { // (mode == "exploration") && 
      $('#progress-bar').slider("option", "max", 0);
      closeCreate();
      isPlaying = false;
    }
  }, 500);
}

function random() {
  if (isPlaying) stop();
  setTimeout(function() {
    if (bw.generateRandom()) { // (mode == "exploration") &&  
      $('#progress-bar').slider("option", "max", 0);
      closeCreate();
      isPlaying = false;
    }
  }, 500);
}

function skewed(side) {
  if (isPlaying) stop();
  setTimeout(function() {
    if (bw.generateSkewed(side)) { // (mode == "exploration") && 
      $('#progress-bar').slider("option", "max", 0);
      closeCreate();
      isPlaying = false;
    }
  }, 500);
}

function findMinMax(isMin, callback) {
  if (isPlaying) stop();
  commonAction(bw.findMinMax(isMin, callback), (isMin ? "找到最小值" : "找到最大值"));
}

function searchVertex(callback) {
  if (isPlaying) stop();
  var input = $('#v-search').val();
  commonAction(bw.search(input, callback), "搜索 " + input);
  setTimeout(function() {
    if (Math.random() >= 0.5) $("#v-search").val(bw.getRandomInBST()); // 50% an existing value
    else                      $("#v-search").val(bw.getRandomNotInBST()); // 50% a NON existing value
  }, 500);
}

function insertVertex(callback) {
  if (isPlaying) stop();
  var input = $('#v-insert').val();
  commonAction(bw.insertArr(input.split(","), callback), "插入 " + input);
  setTimeout(function() { $("#v-insert").val(bw.getRandomNotInBST()); }, 500); // randomized for next click, a NON existing value in BST
}

function removeVertex(callback) {
  if (isPlaying) stop();
  var input = $('#v-remove').val();
  commonAction(bw.removeArr(input.split(","), callback), "移除 " + input);
  setTimeout(function() { $("#v-remove").val(bw.getRandomInBST()); }, 500); // randomized for next click, an existing value in BST
}

function predsucc(isPred, callback) {
  if (isPlaying) stop();
  var input = $('#v-predsucc').val();
  commonAction(bw.findPredSucc(input.split(","), isPred, callback), (isPred ? "前驱(" : "后继者(") + input + ")");
  setTimeout(function() { $("#v-predsucc").val(bw.getRandomInBST()); }, 500);
}

function inorderTraversal(callback) {
  // if (mode != "exploration") return;
  if (isPlaying) stop();
  commonAction(bw.inorderTraversal(callback), "中序遍历");
}

// Implement these functions in each visualisation
var userGraph = {
  'vl': {},
  'el': {},
};

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  //if (bw) userGraph = bw.getGraph();
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  //loadGraph(userGraph);
}

// Lecture action functions
function CUSTOM_ACTION(action, data, mode) {
  if (action == 'search') {
    hideSlide(function() {
      $('#v-search').val(data); // force
      searchVertex(showSlide);
    });
  }
  else if (action == 'findmin') {
    hideSlide(function() {
      findMinMax(true, showSlide);
    });
  }
  else if (action == 'findmax') {
    hideSlide(function() {
      findMinMax(false, showSlide);
    });
  }
  else if (action == 'successor') {
    hideSlide(function() {
      $('#v-predsucc').val(data); // force
      predsucc(false, showSlide);
    });
  }
  else if (action == 'successor_max') {
    hideSlide(function() {
      $('#v-predsucc').val(bw.findMax()); // force the max
      predsucc(false, showSlide);
    });
  }
  else if (action == 'predecessor') {
    hideSlide(function() {
      $('#v-predsucc').val(data); // force
      predsucc(true, showSlide);
    });
  }
  else if (action == 'inorder') {
    hideSlide(function() {
      inorderTraversal(showSlide);
    });
  }
  else if (action == 'insert') {
    hideSlide(function() {
      $('#v-insert').val(data); // force
      insertVertex(showSlide);
    });
  }
  else if (action == 'insert_max_plus_1') {
    hideSlide(function() {
      $('#v-insert').val(bw.findMax()+1); // force the max plus 1
      insertVertex(showSlide);
    });
  }
  else if (action == 'remove') {
    hideSlide(function() {
      $('#v-remove').val(data); // force
      removeVertex(showSlide);
    });
  }
  else if (action == 'remove_max') {
    hideSlide(function() {
      $('#v-remove').val(bw.findMax()); // force the max
      removeVertex(showSlide);
    });
  }
}
</script>
</body>
</html>
